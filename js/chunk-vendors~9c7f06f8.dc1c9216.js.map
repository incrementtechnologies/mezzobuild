{"version":3,"sources":["webpack:///./node_modules/google-p12-pem/node_modules/node-forge/lib/x509.js","webpack:///./node_modules/google-p12-pem/node_modules/node-forge/lib/util.js"],"names":["forge","asn1","pki","module","exports","oids","_shortNames","publicKeyValidator","rsa","x509CertificateValidator","name","tagClass","Class","UNIVERSAL","type","Type","SEQUENCE","constructed","value","captureAsn1","CONTEXT_SPECIFIC","optional","INTEGER","capture","OID","UTCTIME","GENERALIZEDTIME","BITSTRING","captureBitStringValue","rsassaPssParameterValidator","certificationRequestInfoValidator","SET","certificationRequestValidator","_getAttribute","obj","options","shortName","attr","rval","i","attributes","length","RDNAttributesAsArray","rdn","md","set","si","derToOid","valueTagClass","update","push","CRIAttributesAsArray","seq","values","vi","extensionRequest","extensions","ei","certificateExtensionFromAsn1","_readSignatureParameters","oid","fillDefaults","params","hash","algorithmOid","mgf","saltLength","errors","validate","error","Error","undefined","hashOid","maskGenOid","maskGenHashOid","charCodeAt","_dnToAsn1","create","attrs","PRINTABLESTRING","UTF8","util","encodeUtf8","oidToDer","getBytes","_fillMissingFields","attribute","valueConstructed","certificateExtensionToAsn1","_fillMissingExtensionFields","e","id","extension","unused","b2","b3","digitalSignature","nonRepudiation","keyEncipherment","dataEncipherment","keyAgreement","keyCertSign","cRLSign","encipherOnly","decipherOnly","String","fromCharCode","cA","BOOLEAN","integerToDer","pathLenConstraint","key","indexOf","client","server","email","objsign","reserved","sslCA","emailCA","objCA","n","altNames","altName","ip","bytesFromIP","cert","test","comment","IA5STRING","ski","generateSubjectKeyIdentifier","subjectKeyIdentifier","toHex","OCTETSTRING","keyIdentifier","authorityCertIssuer","issuer","serialNumber","hexToBytes","subSeq","fullNameGeneralNames","_signatureParametersToAsn1","parts","NULL","_CRIAttributesToAsn1","csr","certificateFromPem","pem","computeHash","strict","msg","decode","headerType","procType","fromDer","body","certificateFromAsn1","certificateToPem","maxline","toDer","certificateToAsn1","encode","publicKeyFromPem","publicKeyFromAsn1","publicKeyToPem","publicKeyToAsn1","publicKeyToRSAPublicKeyPem","publicKeyToRSAPublicKey","getPublicKeyFingerprint","bytes","sha1","start","digest","encoding","hex","delimiter","match","join","certificationRequestFromPem","certificationRequestFromAsn1","certificationRequestToPem","certificationRequestToAsn1","createCertificate","siginfo","validity","notBefore","Date","notAfter","getField","sn","addField","subject","publicKey","setSubject","uniqueId","setIssuer","setExtensions","exts","getExtension","ext","sign","algorithm","signatureOid","tbsCertificate","getTBSCertificate","signature","verify","child","issued","expectedIssuer","actualIssuer","md5","sha256","sha384","sha512","scheme","sha1WithRSAEncryption","signatureParameters","message","pss","isIssuer","parent","s","iattr","sattr","verifySubjectKeyIdentifier","publicKeyOid","rsaEncryption","version","certVersion","serial","createBuffer","certSerialNumber","certSignatureOid","certSignatureParams","certinfoSignatureOid","parameters","certinfoSignatureParams","certSignature","certValidity1UTCTime","utcTimeToDate","certValidity2GeneralizedTime","generalizedTimeToDate","certValidity3UTCTime","certValidity4GeneralizedTime","imd","certIssuer","certIssuerUniqueId","smd","certSubject","certSubjectUniqueId","certExtensions","certificateExtensionsFromAsn1","subjectPublicKeyInfo","extseq","critical","ev","derToInteger","gn","bytesToIP","bytesToHex","createCertificationRequest","csrVersion","csrSignatureOid","csrSignatureParams","csrSignature","certificationRequestInfo","certificationRequestInfoSubject","getAttribute","addAttribute","certificationRequestInfoAttributes","setAttributes","getCertificationRequestInfo","cri","jan_1_1950","jan_1_2050","_dateToAsn1","date","dateToUtcTime","dateToGeneralizedTime","tbs","certificateExtensionsToAsn1","distinguishedNameToAsn1","dn","createCaStore","certs","caStore","getBySubject","ensureSubjectHasHash","getIssuer","addCertificate","hasCertificate","tmp","isArray","der1","der2","listAllCertificates","certList","hasOwnProperty","removeCertificate","result","splice","certificateError","bad_certificate","unsupported_certificate","certificate_revoked","certificate_expired","certificate_unknown","unknown_ca","verifyCertificateChain","chain","slice","validityCheckDate","first","depth","shift","selfSigned","now","parents","verified","ex","se","keyUsage","basicConstraints","bcExt","keyUsageExt","pathLen","vfd","ret","baseN","_checkBitsParam","ByteStringBuffer","b","this","data","read","isArrayBuffer","isArrayBufferView","Buffer","toString","arr","Uint8Array","apply","putByte","_constructedStringLength","process","nextTick","browser","setImmediate","arguments","callback","setTimeout","window","postMessage","callbacks","handler","event","source","stopPropagation","copy","forEach","addEventListener","MutationObserver","div","document","createElement","observe","oldSetImmediate","setAttribute","isNodejs","versions","node","globalScope","global","self","Array","x","Object","prototype","call","ArrayBuffer","buffer","byteLength","ByteBuffer","_MAX_CONSTRUCTED_STRING_LENGTH","DataBuffer","readOffset","growSize","DataView","byteOffset","write","writeOffset","putBytes","_optimizeConstructedString","substr","isEmpty","fillWithByte","d","putString","str","putInt16","putInt24","putInt32","putInt16Le","putInt24Le","putInt32Le","putInt","putSignedInt","putBuffer","getByte","getInt16","getInt24","getInt32","getInt16Le","getInt24Le","getInt32Le","getInt","getSignedInt","max","count","Math","min","clear","at","setAt","last","c","compact","truncate","len","decodeUtf8","accommodate","amount","src","dst","setUint8","view","ceil","binary","base64","raw","Uint16Array","text","utf16","setInt16","setInt8","setInt32","getInt8","getUint8","utf8","input","fillString","xorBytes","s1","s2","s3","t","parseInt","int32ToBytes","_base64","_base64Idx","_base58","encode64","chr1","chr2","chr3","line","output","charAt","isNaN","decode64","replace","enc1","enc2","enc3","enc4","unescape","encodeURIComponent","decodeURIComponent","escape","base58","offset","out","j","subarray","k","deflate","api","flg","substring","inflate","_setStorageObject","removeItem","JSON","stringify","setItem","_getStorageObject","getItem","init","parse","_setItem","_getItem","_removeItem","empty","prop","_clearItems","_callStorageFunction","func","args","location","done","exception","idx","localStorage","clearItems","parseUrl","regex","lastIndex","m","exec","url","full","host","port","path","fullHost","_queryVariables","getQueryVariables","query","q","kvpairs","split","val","pos","search","parseFragment","fragment","fp","fq","pathString","queryString","makeRequest","reqString","frag","req","getPath","getQuery","getQueryLast","_default","vals","makeLink","jQuery","qstr","param","format","part","re","argi","code","formatNumber","number","decimals","dec_point","thousands_sep","abs","toFixed","formatSize","size","bytesFromIPv4","bytesFromIPv6","num","blanks","filter","zeros","bytesToIPv4","bytesToIPv6","zeroGroups","zeroMaxGroup","end","group","unshift","estimateCores","cores","navigator","hardwareConcurrency","Worker","Blob","blobUrl","URL","createObjectURL","st","et","sample","samples","numWorkers","avg","floor","reduce","revokeObjectURL","map","err","results","workers","worker","terminate","overlaps","r1","overlap","r2"],"mappings":"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","file":"js/chunk-vendors~9c7f06f8.dc1c9216.js","sourcesContent":["/**\n * Javascript implementation of X.509 and related components (such as\n * Certification Signing Requests) of a Public Key Infrastructure.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2010-2014 Digital Bazaar, Inc.\n *\n * The ASN.1 representation of an X.509v3 certificate is as follows\n * (see RFC 2459):\n *\n * Certificate ::= SEQUENCE {\n *   tbsCertificate       TBSCertificate,\n *   signatureAlgorithm   AlgorithmIdentifier,\n *   signatureValue       BIT STRING\n * }\n *\n * TBSCertificate ::= SEQUENCE {\n *   version         [0]  EXPLICIT Version DEFAULT v1,\n *   serialNumber         CertificateSerialNumber,\n *   signature            AlgorithmIdentifier,\n *   issuer               Name,\n *   validity             Validity,\n *   subject              Name,\n *   subjectPublicKeyInfo SubjectPublicKeyInfo,\n *   issuerUniqueID  [1]  IMPLICIT UniqueIdentifier OPTIONAL,\n *                        -- If present, version shall be v2 or v3\n *   subjectUniqueID [2]  IMPLICIT UniqueIdentifier OPTIONAL,\n *                        -- If present, version shall be v2 or v3\n *   extensions      [3]  EXPLICIT Extensions OPTIONAL\n *                        -- If present, version shall be v3\n * }\n *\n * Version ::= INTEGER  { v1(0), v2(1), v3(2) }\n *\n * CertificateSerialNumber ::= INTEGER\n *\n * Name ::= CHOICE {\n *   // only one possible choice for now\n *   RDNSequence\n * }\n *\n * RDNSequence ::= SEQUENCE OF RelativeDistinguishedName\n *\n * RelativeDistinguishedName ::= SET OF AttributeTypeAndValue\n *\n * AttributeTypeAndValue ::= SEQUENCE {\n *   type     AttributeType,\n *   value    AttributeValue\n * }\n * AttributeType ::= OBJECT IDENTIFIER\n * AttributeValue ::= ANY DEFINED BY AttributeType\n *\n * Validity ::= SEQUENCE {\n *   notBefore      Time,\n *   notAfter       Time\n * }\n *\n * Time ::= CHOICE {\n *   utcTime        UTCTime,\n *   generalTime    GeneralizedTime\n * }\n *\n * UniqueIdentifier ::= BIT STRING\n *\n * SubjectPublicKeyInfo ::= SEQUENCE {\n *   algorithm            AlgorithmIdentifier,\n *   subjectPublicKey     BIT STRING\n * }\n *\n * Extensions ::= SEQUENCE SIZE (1..MAX) OF Extension\n *\n * Extension ::= SEQUENCE {\n *   extnID      OBJECT IDENTIFIER,\n *   critical    BOOLEAN DEFAULT FALSE,\n *   extnValue   OCTET STRING\n * }\n *\n * The only key algorithm currently supported for PKI is RSA.\n *\n * RSASSA-PSS signatures are described in RFC 3447 and RFC 4055.\n *\n * PKCS#10 v1.7 describes certificate signing requests:\n *\n * CertificationRequestInfo:\n *\n * CertificationRequestInfo ::= SEQUENCE {\n *   version       INTEGER { v1(0) } (v1,...),\n *   subject       Name,\n *   subjectPKInfo SubjectPublicKeyInfo{{ PKInfoAlgorithms }},\n *   attributes    [0] Attributes{{ CRIAttributes }}\n * }\n *\n * Attributes { ATTRIBUTE:IOSet } ::= SET OF Attribute{{ IOSet }}\n *\n * CRIAttributes  ATTRIBUTE  ::= {\n *   ... -- add any locally defined attributes here -- }\n *\n * Attribute { ATTRIBUTE:IOSet } ::= SEQUENCE {\n *   type   ATTRIBUTE.&id({IOSet}),\n *   values SET SIZE(1..MAX) OF ATTRIBUTE.&Type({IOSet}{@type})\n * }\n *\n * CertificationRequest ::= SEQUENCE {\n *   certificationRequestInfo CertificationRequestInfo,\n *   signatureAlgorithm AlgorithmIdentifier{{ SignatureAlgorithms }},\n *   signature          BIT STRING\n * }\n */\nvar forge = require('./forge');\nrequire('./aes');\nrequire('./asn1');\nrequire('./des');\nrequire('./md');\nrequire('./mgf');\nrequire('./oids');\nrequire('./pem');\nrequire('./pss');\nrequire('./rsa');\nrequire('./util');\n\n// shortcut for asn.1 API\nvar asn1 = forge.asn1;\n\n/* Public Key Infrastructure (PKI) implementation. */\nvar pki = module.exports = forge.pki = forge.pki || {};\nvar oids = pki.oids;\n\n// short name OID mappings\nvar _shortNames = {};\n_shortNames['CN'] = oids['commonName'];\n_shortNames['commonName'] = 'CN';\n_shortNames['C'] = oids['countryName'];\n_shortNames['countryName'] = 'C';\n_shortNames['L'] = oids['localityName'];\n_shortNames['localityName'] = 'L';\n_shortNames['ST'] = oids['stateOrProvinceName'];\n_shortNames['stateOrProvinceName'] = 'ST';\n_shortNames['O'] = oids['organizationName'];\n_shortNames['organizationName'] = 'O';\n_shortNames['OU'] = oids['organizationalUnitName'];\n_shortNames['organizationalUnitName'] = 'OU';\n_shortNames['E'] = oids['emailAddress'];\n_shortNames['emailAddress'] = 'E';\n\n// validator for an SubjectPublicKeyInfo structure\n// Note: Currently only works with an RSA public key\nvar publicKeyValidator = forge.pki.rsa.publicKeyValidator;\n\n// validator for an X.509v3 certificate\nvar x509CertificateValidator = {\n  name: 'Certificate',\n  tagClass: asn1.Class.UNIVERSAL,\n  type: asn1.Type.SEQUENCE,\n  constructed: true,\n  value: [{\n    name: 'Certificate.TBSCertificate',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SEQUENCE,\n    constructed: true,\n    captureAsn1: 'tbsCertificate',\n    value: [{\n      name: 'Certificate.TBSCertificate.version',\n      tagClass: asn1.Class.CONTEXT_SPECIFIC,\n      type: 0,\n      constructed: true,\n      optional: true,\n      value: [{\n        name: 'Certificate.TBSCertificate.version.integer',\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.INTEGER,\n        constructed: false,\n        capture: 'certVersion'\n      }]\n    }, {\n      name: 'Certificate.TBSCertificate.serialNumber',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.INTEGER,\n      constructed: false,\n      capture: 'certSerialNumber'\n    }, {\n      name: 'Certificate.TBSCertificate.signature',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.SEQUENCE,\n      constructed: true,\n      value: [{\n        name: 'Certificate.TBSCertificate.signature.algorithm',\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.OID,\n        constructed: false,\n        capture: 'certinfoSignatureOid'\n      }, {\n        name: 'Certificate.TBSCertificate.signature.parameters',\n        tagClass: asn1.Class.UNIVERSAL,\n        optional: true,\n        captureAsn1: 'certinfoSignatureParams'\n      }]\n    }, {\n      name: 'Certificate.TBSCertificate.issuer',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.SEQUENCE,\n      constructed: true,\n      captureAsn1: 'certIssuer'\n    }, {\n      name: 'Certificate.TBSCertificate.validity',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.SEQUENCE,\n      constructed: true,\n      // Note: UTC and generalized times may both appear so the capture\n      // names are based on their detected order, the names used below\n      // are only for the common case, which validity time really means\n      // \"notBefore\" and which means \"notAfter\" will be determined by order\n      value: [{\n        // notBefore (Time) (UTC time case)\n        name: 'Certificate.TBSCertificate.validity.notBefore (utc)',\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.UTCTIME,\n        constructed: false,\n        optional: true,\n        capture: 'certValidity1UTCTime'\n      }, {\n        // notBefore (Time) (generalized time case)\n        name: 'Certificate.TBSCertificate.validity.notBefore (generalized)',\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.GENERALIZEDTIME,\n        constructed: false,\n        optional: true,\n        capture: 'certValidity2GeneralizedTime'\n      }, {\n        // notAfter (Time) (only UTC time is supported)\n        name: 'Certificate.TBSCertificate.validity.notAfter (utc)',\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.UTCTIME,\n        constructed: false,\n        optional: true,\n        capture: 'certValidity3UTCTime'\n      }, {\n        // notAfter (Time) (only UTC time is supported)\n        name: 'Certificate.TBSCertificate.validity.notAfter (generalized)',\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.GENERALIZEDTIME,\n        constructed: false,\n        optional: true,\n        capture: 'certValidity4GeneralizedTime'\n      }]\n    }, {\n      // Name (subject) (RDNSequence)\n      name: 'Certificate.TBSCertificate.subject',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.SEQUENCE,\n      constructed: true,\n      captureAsn1: 'certSubject'\n    },\n    // SubjectPublicKeyInfo\n    publicKeyValidator,\n    {\n      // issuerUniqueID (optional)\n      name: 'Certificate.TBSCertificate.issuerUniqueID',\n      tagClass: asn1.Class.CONTEXT_SPECIFIC,\n      type: 1,\n      constructed: true,\n      optional: true,\n      value: [{\n        name: 'Certificate.TBSCertificate.issuerUniqueID.id',\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.BITSTRING,\n        constructed: false,\n        // TODO: support arbitrary bit length ids\n        captureBitStringValue: 'certIssuerUniqueId'\n      }]\n    }, {\n      // subjectUniqueID (optional)\n      name: 'Certificate.TBSCertificate.subjectUniqueID',\n      tagClass: asn1.Class.CONTEXT_SPECIFIC,\n      type: 2,\n      constructed: true,\n      optional: true,\n      value: [{\n        name: 'Certificate.TBSCertificate.subjectUniqueID.id',\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.BITSTRING,\n        constructed: false,\n        // TODO: support arbitrary bit length ids\n        captureBitStringValue: 'certSubjectUniqueId'\n      }]\n    }, {\n      // Extensions (optional)\n      name: 'Certificate.TBSCertificate.extensions',\n      tagClass: asn1.Class.CONTEXT_SPECIFIC,\n      type: 3,\n      constructed: true,\n      captureAsn1: 'certExtensions',\n      optional: true\n    }]\n  }, {\n    // AlgorithmIdentifier (signature algorithm)\n    name: 'Certificate.signatureAlgorithm',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SEQUENCE,\n    constructed: true,\n    value: [{\n      // algorithm\n      name: 'Certificate.signatureAlgorithm.algorithm',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.OID,\n      constructed: false,\n      capture: 'certSignatureOid'\n    }, {\n      name: 'Certificate.TBSCertificate.signature.parameters',\n      tagClass: asn1.Class.UNIVERSAL,\n      optional: true,\n      captureAsn1: 'certSignatureParams'\n    }]\n  }, {\n    // SignatureValue\n    name: 'Certificate.signatureValue',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.BITSTRING,\n    constructed: false,\n    captureBitStringValue: 'certSignature'\n  }]\n};\n\nvar rsassaPssParameterValidator = {\n  name: 'rsapss',\n  tagClass: asn1.Class.UNIVERSAL,\n  type: asn1.Type.SEQUENCE,\n  constructed: true,\n  value: [{\n    name: 'rsapss.hashAlgorithm',\n    tagClass: asn1.Class.CONTEXT_SPECIFIC,\n    type: 0,\n    constructed: true,\n    value: [{\n      name: 'rsapss.hashAlgorithm.AlgorithmIdentifier',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Class.SEQUENCE,\n      constructed: true,\n      optional: true,\n      value: [{\n        name: 'rsapss.hashAlgorithm.AlgorithmIdentifier.algorithm',\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.OID,\n        constructed: false,\n        capture: 'hashOid'\n        /* parameter block omitted, for SHA1 NULL anyhow. */\n      }]\n    }]\n  }, {\n    name: 'rsapss.maskGenAlgorithm',\n    tagClass: asn1.Class.CONTEXT_SPECIFIC,\n    type: 1,\n    constructed: true,\n    value: [{\n      name: 'rsapss.maskGenAlgorithm.AlgorithmIdentifier',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Class.SEQUENCE,\n      constructed: true,\n      optional: true,\n      value: [{\n        name: 'rsapss.maskGenAlgorithm.AlgorithmIdentifier.algorithm',\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.OID,\n        constructed: false,\n        capture: 'maskGenOid'\n      }, {\n        name: 'rsapss.maskGenAlgorithm.AlgorithmIdentifier.params',\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.SEQUENCE,\n        constructed: true,\n        value: [{\n          name: 'rsapss.maskGenAlgorithm.AlgorithmIdentifier.params.algorithm',\n          tagClass: asn1.Class.UNIVERSAL,\n          type: asn1.Type.OID,\n          constructed: false,\n          capture: 'maskGenHashOid'\n          /* parameter block omitted, for SHA1 NULL anyhow. */\n        }]\n      }]\n    }]\n  }, {\n    name: 'rsapss.saltLength',\n    tagClass: asn1.Class.CONTEXT_SPECIFIC,\n    type: 2,\n    optional: true,\n    value: [{\n      name: 'rsapss.saltLength.saltLength',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Class.INTEGER,\n      constructed: false,\n      capture: 'saltLength'\n    }]\n  }, {\n    name: 'rsapss.trailerField',\n    tagClass: asn1.Class.CONTEXT_SPECIFIC,\n    type: 3,\n    optional: true,\n    value: [{\n      name: 'rsapss.trailer.trailer',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Class.INTEGER,\n      constructed: false,\n      capture: 'trailer'\n    }]\n  }]\n};\n\n// validator for a CertificationRequestInfo structure\nvar certificationRequestInfoValidator = {\n  name: 'CertificationRequestInfo',\n  tagClass: asn1.Class.UNIVERSAL,\n  type: asn1.Type.SEQUENCE,\n  constructed: true,\n  captureAsn1: 'certificationRequestInfo',\n  value: [{\n    name: 'CertificationRequestInfo.integer',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.INTEGER,\n    constructed: false,\n    capture: 'certificationRequestInfoVersion'\n  }, {\n    // Name (subject) (RDNSequence)\n    name: 'CertificationRequestInfo.subject',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SEQUENCE,\n    constructed: true,\n    captureAsn1: 'certificationRequestInfoSubject'\n  },\n  // SubjectPublicKeyInfo\n  publicKeyValidator,\n  {\n    name: 'CertificationRequestInfo.attributes',\n    tagClass: asn1.Class.CONTEXT_SPECIFIC,\n    type: 0,\n    constructed: true,\n    optional: true,\n    capture: 'certificationRequestInfoAttributes',\n    value: [{\n      name: 'CertificationRequestInfo.attributes',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.SEQUENCE,\n      constructed: true,\n      value: [{\n        name: 'CertificationRequestInfo.attributes.type',\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.OID,\n        constructed: false\n      }, {\n        name: 'CertificationRequestInfo.attributes.value',\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.SET,\n        constructed: true\n      }]\n    }]\n  }]\n};\n\n// validator for a CertificationRequest structure\nvar certificationRequestValidator = {\n  name: 'CertificationRequest',\n  tagClass: asn1.Class.UNIVERSAL,\n  type: asn1.Type.SEQUENCE,\n  constructed: true,\n  captureAsn1: 'csr',\n  value: [\n    certificationRequestInfoValidator, {\n      // AlgorithmIdentifier (signature algorithm)\n      name: 'CertificationRequest.signatureAlgorithm',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.SEQUENCE,\n      constructed: true,\n      value: [{\n        // algorithm\n        name: 'CertificationRequest.signatureAlgorithm.algorithm',\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.OID,\n        constructed: false,\n        capture: 'csrSignatureOid'\n      }, {\n        name: 'CertificationRequest.signatureAlgorithm.parameters',\n        tagClass: asn1.Class.UNIVERSAL,\n        optional: true,\n        captureAsn1: 'csrSignatureParams'\n      }]\n    }, {\n      // signature\n      name: 'CertificationRequest.signature',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.BITSTRING,\n      constructed: false,\n      captureBitStringValue: 'csrSignature'\n    }\n  ]\n};\n\n/**\n * Converts an RDNSequence of ASN.1 DER-encoded RelativeDistinguishedName\n * sets into an array with objects that have type and value properties.\n *\n * @param rdn the RDNSequence to convert.\n * @param md a message digest to append type and value to if provided.\n */\npki.RDNAttributesAsArray = function(rdn, md) {\n  var rval = [];\n\n  // each value in 'rdn' in is a SET of RelativeDistinguishedName\n  var set, attr, obj;\n  for(var si = 0; si < rdn.value.length; ++si) {\n    // get the RelativeDistinguishedName set\n    set = rdn.value[si];\n\n    // each value in the SET is an AttributeTypeAndValue sequence\n    // containing first a type (an OID) and second a value (defined by\n    // the OID)\n    for(var i = 0; i < set.value.length; ++i) {\n      obj = {};\n      attr = set.value[i];\n      obj.type = asn1.derToOid(attr.value[0].value);\n      obj.value = attr.value[1].value;\n      obj.valueTagClass = attr.value[1].type;\n      // if the OID is known, get its name and short name\n      if(obj.type in oids) {\n        obj.name = oids[obj.type];\n        if(obj.name in _shortNames) {\n          obj.shortName = _shortNames[obj.name];\n        }\n      }\n      if(md) {\n        md.update(obj.type);\n        md.update(obj.value);\n      }\n      rval.push(obj);\n    }\n  }\n\n  return rval;\n};\n\n/**\n * Converts ASN.1 CRIAttributes into an array with objects that have type and\n * value properties.\n *\n * @param attributes the CRIAttributes to convert.\n */\npki.CRIAttributesAsArray = function(attributes) {\n  var rval = [];\n\n  // each value in 'attributes' in is a SEQUENCE with an OID and a SET\n  for(var si = 0; si < attributes.length; ++si) {\n    // get the attribute sequence\n    var seq = attributes[si];\n\n    // each value in the SEQUENCE containing first a type (an OID) and\n    // second a set of values (defined by the OID)\n    var type = asn1.derToOid(seq.value[0].value);\n    var values = seq.value[1].value;\n    for(var vi = 0; vi < values.length; ++vi) {\n      var obj = {};\n      obj.type = type;\n      obj.value = values[vi].value;\n      obj.valueTagClass = values[vi].type;\n      // if the OID is known, get its name and short name\n      if(obj.type in oids) {\n        obj.name = oids[obj.type];\n        if(obj.name in _shortNames) {\n          obj.shortName = _shortNames[obj.name];\n        }\n      }\n      // parse extensions\n      if(obj.type === oids.extensionRequest) {\n        obj.extensions = [];\n        for(var ei = 0; ei < obj.value.length; ++ei) {\n          obj.extensions.push(pki.certificateExtensionFromAsn1(obj.value[ei]));\n        }\n      }\n      rval.push(obj);\n    }\n  }\n\n  return rval;\n};\n\n/**\n * Gets an issuer or subject attribute from its name, type, or short name.\n *\n * @param obj the issuer or subject object.\n * @param options a short name string or an object with:\n *          shortName the short name for the attribute.\n *          name the name for the attribute.\n *          type the type for the attribute.\n *\n * @return the attribute.\n */\nfunction _getAttribute(obj, options) {\n  if(typeof options === 'string') {\n    options = {shortName: options};\n  }\n\n  var rval = null;\n  var attr;\n  for(var i = 0; rval === null && i < obj.attributes.length; ++i) {\n    attr = obj.attributes[i];\n    if(options.type && options.type === attr.type) {\n      rval = attr;\n    } else if(options.name && options.name === attr.name) {\n      rval = attr;\n    } else if(options.shortName && options.shortName === attr.shortName) {\n      rval = attr;\n    }\n  }\n  return rval;\n}\n\n/**\n * Converts signature parameters from ASN.1 structure.\n *\n * Currently only RSASSA-PSS supported.  The PKCS#1 v1.5 signature scheme had\n * no parameters.\n *\n * RSASSA-PSS-params  ::=  SEQUENCE  {\n *   hashAlgorithm      [0] HashAlgorithm DEFAULT\n *                             sha1Identifier,\n *   maskGenAlgorithm   [1] MaskGenAlgorithm DEFAULT\n *                             mgf1SHA1Identifier,\n *   saltLength         [2] INTEGER DEFAULT 20,\n *   trailerField       [3] INTEGER DEFAULT 1\n * }\n *\n * HashAlgorithm  ::=  AlgorithmIdentifier\n *\n * MaskGenAlgorithm  ::=  AlgorithmIdentifier\n *\n * AlgorithmIdentifer ::= SEQUENCE {\n *   algorithm OBJECT IDENTIFIER,\n *   parameters ANY DEFINED BY algorithm OPTIONAL\n * }\n *\n * @param oid The OID specifying the signature algorithm\n * @param obj The ASN.1 structure holding the parameters\n * @param fillDefaults Whether to use return default values where omitted\n * @return signature parameter object\n */\nvar _readSignatureParameters = function(oid, obj, fillDefaults) {\n  var params = {};\n\n  if(oid !== oids['RSASSA-PSS']) {\n    return params;\n  }\n\n  if(fillDefaults) {\n    params = {\n      hash: {\n        algorithmOid: oids['sha1']\n      },\n      mgf: {\n        algorithmOid: oids['mgf1'],\n        hash: {\n          algorithmOid: oids['sha1']\n        }\n      },\n      saltLength: 20\n    };\n  }\n\n  var capture = {};\n  var errors = [];\n  if(!asn1.validate(obj, rsassaPssParameterValidator, capture, errors)) {\n    var error = new Error('Cannot read RSASSA-PSS parameter block.');\n    error.errors = errors;\n    throw error;\n  }\n\n  if(capture.hashOid !== undefined) {\n    params.hash = params.hash || {};\n    params.hash.algorithmOid = asn1.derToOid(capture.hashOid);\n  }\n\n  if(capture.maskGenOid !== undefined) {\n    params.mgf = params.mgf || {};\n    params.mgf.algorithmOid = asn1.derToOid(capture.maskGenOid);\n    params.mgf.hash = params.mgf.hash || {};\n    params.mgf.hash.algorithmOid = asn1.derToOid(capture.maskGenHashOid);\n  }\n\n  if(capture.saltLength !== undefined) {\n    params.saltLength = capture.saltLength.charCodeAt(0);\n  }\n\n  return params;\n};\n\n/**\n * Converts an X.509 certificate from PEM format.\n *\n * Note: If the certificate is to be verified then compute hash should\n * be set to true. This will scan the TBSCertificate part of the ASN.1\n * object while it is converted so it doesn't need to be converted back\n * to ASN.1-DER-encoding later.\n *\n * @param pem the PEM-formatted certificate.\n * @param computeHash true to compute the hash for verification.\n * @param strict true to be strict when checking ASN.1 value lengths, false to\n *          allow truncated values (default: true).\n *\n * @return the certificate.\n */\npki.certificateFromPem = function(pem, computeHash, strict) {\n  var msg = forge.pem.decode(pem)[0];\n\n  if(msg.type !== 'CERTIFICATE' &&\n    msg.type !== 'X509 CERTIFICATE' &&\n    msg.type !== 'TRUSTED CERTIFICATE') {\n    var error = new Error(\n      'Could not convert certificate from PEM; PEM header type ' +\n      'is not \"CERTIFICATE\", \"X509 CERTIFICATE\", or \"TRUSTED CERTIFICATE\".');\n    error.headerType = msg.type;\n    throw error;\n  }\n  if(msg.procType && msg.procType.type === 'ENCRYPTED') {\n    throw new Error(\n      'Could not convert certificate from PEM; PEM is encrypted.');\n  }\n\n  // convert DER to ASN.1 object\n  var obj = asn1.fromDer(msg.body, strict);\n\n  return pki.certificateFromAsn1(obj, computeHash);\n};\n\n/**\n * Converts an X.509 certificate to PEM format.\n *\n * @param cert the certificate.\n * @param maxline the maximum characters per line, defaults to 64.\n *\n * @return the PEM-formatted certificate.\n */\npki.certificateToPem = function(cert, maxline) {\n  // convert to ASN.1, then DER, then PEM-encode\n  var msg = {\n    type: 'CERTIFICATE',\n    body: asn1.toDer(pki.certificateToAsn1(cert)).getBytes()\n  };\n  return forge.pem.encode(msg, {maxline: maxline});\n};\n\n/**\n * Converts an RSA public key from PEM format.\n *\n * @param pem the PEM-formatted public key.\n *\n * @return the public key.\n */\npki.publicKeyFromPem = function(pem) {\n  var msg = forge.pem.decode(pem)[0];\n\n  if(msg.type !== 'PUBLIC KEY' && msg.type !== 'RSA PUBLIC KEY') {\n    var error = new Error('Could not convert public key from PEM; PEM header ' +\n      'type is not \"PUBLIC KEY\" or \"RSA PUBLIC KEY\".');\n    error.headerType = msg.type;\n    throw error;\n  }\n  if(msg.procType && msg.procType.type === 'ENCRYPTED') {\n    throw new Error('Could not convert public key from PEM; PEM is encrypted.');\n  }\n\n  // convert DER to ASN.1 object\n  var obj = asn1.fromDer(msg.body);\n\n  return pki.publicKeyFromAsn1(obj);\n};\n\n/**\n * Converts an RSA public key to PEM format (using a SubjectPublicKeyInfo).\n *\n * @param key the public key.\n * @param maxline the maximum characters per line, defaults to 64.\n *\n * @return the PEM-formatted public key.\n */\npki.publicKeyToPem = function(key, maxline) {\n  // convert to ASN.1, then DER, then PEM-encode\n  var msg = {\n    type: 'PUBLIC KEY',\n    body: asn1.toDer(pki.publicKeyToAsn1(key)).getBytes()\n  };\n  return forge.pem.encode(msg, {maxline: maxline});\n};\n\n/**\n * Converts an RSA public key to PEM format (using an RSAPublicKey).\n *\n * @param key the public key.\n * @param maxline the maximum characters per line, defaults to 64.\n *\n * @return the PEM-formatted public key.\n */\npki.publicKeyToRSAPublicKeyPem = function(key, maxline) {\n  // convert to ASN.1, then DER, then PEM-encode\n  var msg = {\n    type: 'RSA PUBLIC KEY',\n    body: asn1.toDer(pki.publicKeyToRSAPublicKey(key)).getBytes()\n  };\n  return forge.pem.encode(msg, {maxline: maxline});\n};\n\n/**\n * Gets a fingerprint for the given public key.\n *\n * @param options the options to use.\n *          [md] the message digest object to use (defaults to forge.md.sha1).\n *          [type] the type of fingerprint, such as 'RSAPublicKey',\n *            'SubjectPublicKeyInfo' (defaults to 'RSAPublicKey').\n *          [encoding] an alternative output encoding, such as 'hex'\n *            (defaults to none, outputs a byte buffer).\n *          [delimiter] the delimiter to use between bytes for 'hex' encoded\n *            output, eg: ':' (defaults to none).\n *\n * @return the fingerprint as a byte buffer or other encoding based on options.\n */\npki.getPublicKeyFingerprint = function(key, options) {\n  options = options || {};\n  var md = options.md || forge.md.sha1.create();\n  var type = options.type || 'RSAPublicKey';\n\n  var bytes;\n  switch(type) {\n    case 'RSAPublicKey':\n      bytes = asn1.toDer(pki.publicKeyToRSAPublicKey(key)).getBytes();\n      break;\n    case 'SubjectPublicKeyInfo':\n      bytes = asn1.toDer(pki.publicKeyToAsn1(key)).getBytes();\n      break;\n    default:\n      throw new Error('Unknown fingerprint type \"' + options.type + '\".');\n  }\n\n  // hash public key bytes\n  md.start();\n  md.update(bytes);\n  var digest = md.digest();\n  if(options.encoding === 'hex') {\n    var hex = digest.toHex();\n    if(options.delimiter) {\n      return hex.match(/.{2}/g).join(options.delimiter);\n    }\n    return hex;\n  } else if(options.encoding === 'binary') {\n    return digest.getBytes();\n  } else if(options.encoding) {\n    throw new Error('Unknown encoding \"' + options.encoding + '\".');\n  }\n  return digest;\n};\n\n/**\n * Converts a PKCS#10 certification request (CSR) from PEM format.\n *\n * Note: If the certification request is to be verified then compute hash\n * should be set to true. This will scan the CertificationRequestInfo part of\n * the ASN.1 object while it is converted so it doesn't need to be converted\n * back to ASN.1-DER-encoding later.\n *\n * @param pem the PEM-formatted certificate.\n * @param computeHash true to compute the hash for verification.\n * @param strict true to be strict when checking ASN.1 value lengths, false to\n *          allow truncated values (default: true).\n *\n * @return the certification request (CSR).\n */\npki.certificationRequestFromPem = function(pem, computeHash, strict) {\n  var msg = forge.pem.decode(pem)[0];\n\n  if(msg.type !== 'CERTIFICATE REQUEST') {\n    var error = new Error('Could not convert certification request from PEM; ' +\n      'PEM header type is not \"CERTIFICATE REQUEST\".');\n    error.headerType = msg.type;\n    throw error;\n  }\n  if(msg.procType && msg.procType.type === 'ENCRYPTED') {\n    throw new Error('Could not convert certification request from PEM; ' +\n      'PEM is encrypted.');\n  }\n\n  // convert DER to ASN.1 object\n  var obj = asn1.fromDer(msg.body, strict);\n\n  return pki.certificationRequestFromAsn1(obj, computeHash);\n};\n\n/**\n * Converts a PKCS#10 certification request (CSR) to PEM format.\n *\n * @param csr the certification request.\n * @param maxline the maximum characters per line, defaults to 64.\n *\n * @return the PEM-formatted certification request.\n */\npki.certificationRequestToPem = function(csr, maxline) {\n  // convert to ASN.1, then DER, then PEM-encode\n  var msg = {\n    type: 'CERTIFICATE REQUEST',\n    body: asn1.toDer(pki.certificationRequestToAsn1(csr)).getBytes()\n  };\n  return forge.pem.encode(msg, {maxline: maxline});\n};\n\n/**\n * Creates an empty X.509v3 RSA certificate.\n *\n * @return the certificate.\n */\npki.createCertificate = function() {\n  var cert = {};\n  cert.version = 0x02;\n  cert.serialNumber = '00';\n  cert.signatureOid = null;\n  cert.signature = null;\n  cert.siginfo = {};\n  cert.siginfo.algorithmOid = null;\n  cert.validity = {};\n  cert.validity.notBefore = new Date();\n  cert.validity.notAfter = new Date();\n\n  cert.issuer = {};\n  cert.issuer.getField = function(sn) {\n    return _getAttribute(cert.issuer, sn);\n  };\n  cert.issuer.addField = function(attr) {\n    _fillMissingFields([attr]);\n    cert.issuer.attributes.push(attr);\n  };\n  cert.issuer.attributes = [];\n  cert.issuer.hash = null;\n\n  cert.subject = {};\n  cert.subject.getField = function(sn) {\n    return _getAttribute(cert.subject, sn);\n  };\n  cert.subject.addField = function(attr) {\n    _fillMissingFields([attr]);\n    cert.subject.attributes.push(attr);\n  };\n  cert.subject.attributes = [];\n  cert.subject.hash = null;\n\n  cert.extensions = [];\n  cert.publicKey = null;\n  cert.md = null;\n\n  /**\n   * Sets the subject of this certificate.\n   *\n   * @param attrs the array of subject attributes to use.\n   * @param uniqueId an optional a unique ID to use.\n   */\n  cert.setSubject = function(attrs, uniqueId) {\n    // set new attributes, clear hash\n    _fillMissingFields(attrs);\n    cert.subject.attributes = attrs;\n    delete cert.subject.uniqueId;\n    if(uniqueId) {\n      // TODO: support arbitrary bit length ids\n      cert.subject.uniqueId = uniqueId;\n    }\n    cert.subject.hash = null;\n  };\n\n  /**\n   * Sets the issuer of this certificate.\n   *\n   * @param attrs the array of issuer attributes to use.\n   * @param uniqueId an optional a unique ID to use.\n   */\n  cert.setIssuer = function(attrs, uniqueId) {\n    // set new attributes, clear hash\n    _fillMissingFields(attrs);\n    cert.issuer.attributes = attrs;\n    delete cert.issuer.uniqueId;\n    if(uniqueId) {\n      // TODO: support arbitrary bit length ids\n      cert.issuer.uniqueId = uniqueId;\n    }\n    cert.issuer.hash = null;\n  };\n\n  /**\n   * Sets the extensions of this certificate.\n   *\n   * @param exts the array of extensions to use.\n   */\n  cert.setExtensions = function(exts) {\n    for(var i = 0; i < exts.length; ++i) {\n      _fillMissingExtensionFields(exts[i], {cert: cert});\n    }\n    // set new extensions\n    cert.extensions = exts;\n  };\n\n  /**\n   * Gets an extension by its name or id.\n   *\n   * @param options the name to use or an object with:\n   *          name the name to use.\n   *          id the id to use.\n   *\n   * @return the extension or null if not found.\n   */\n  cert.getExtension = function(options) {\n    if(typeof options === 'string') {\n      options = {name: options};\n    }\n\n    var rval = null;\n    var ext;\n    for(var i = 0; rval === null && i < cert.extensions.length; ++i) {\n      ext = cert.extensions[i];\n      if(options.id && ext.id === options.id) {\n        rval = ext;\n      } else if(options.name && ext.name === options.name) {\n        rval = ext;\n      }\n    }\n    return rval;\n  };\n\n  /**\n   * Signs this certificate using the given private key.\n   *\n   * @param key the private key to sign with.\n   * @param md the message digest object to use (defaults to forge.md.sha1).\n   */\n  cert.sign = function(key, md) {\n    // TODO: get signature OID from private key\n    cert.md = md || forge.md.sha1.create();\n    var algorithmOid = oids[cert.md.algorithm + 'WithRSAEncryption'];\n    if(!algorithmOid) {\n      var error = new Error('Could not compute certificate digest. ' +\n        'Unknown message digest algorithm OID.');\n      error.algorithm = cert.md.algorithm;\n      throw error;\n    }\n    cert.signatureOid = cert.siginfo.algorithmOid = algorithmOid;\n\n    // get TBSCertificate, convert to DER\n    cert.tbsCertificate = pki.getTBSCertificate(cert);\n    var bytes = asn1.toDer(cert.tbsCertificate);\n\n    // digest and sign\n    cert.md.update(bytes.getBytes());\n    cert.signature = key.sign(cert.md);\n  };\n\n  /**\n   * Attempts verify the signature on the passed certificate using this\n   * certificate's public key.\n   *\n   * @param child the certificate to verify.\n   *\n   * @return true if verified, false if not.\n   */\n  cert.verify = function(child) {\n    var rval = false;\n\n    if(!cert.issued(child)) {\n      var issuer = child.issuer;\n      var subject = cert.subject;\n      var error = new Error(\n        'The parent certificate did not issue the given child ' +\n        'certificate; the child certificate\\'s issuer does not match the ' +\n        'parent\\'s subject.');\n      error.expectedIssuer = issuer.attributes;\n      error.actualIssuer = subject.attributes;\n      throw error;\n    }\n\n    var md = child.md;\n    if(md === null) {\n      // check signature OID for supported signature types\n      if(child.signatureOid in oids) {\n        var oid = oids[child.signatureOid];\n        switch(oid) {\n          case 'sha1WithRSAEncryption':\n            md = forge.md.sha1.create();\n            break;\n          case 'md5WithRSAEncryption':\n            md = forge.md.md5.create();\n            break;\n          case 'sha256WithRSAEncryption':\n            md = forge.md.sha256.create();\n            break;\n          case 'sha384WithRSAEncryption':\n            md = forge.md.sha384.create();\n            break;\n          case 'sha512WithRSAEncryption':\n            md = forge.md.sha512.create();\n            break;\n          case 'RSASSA-PSS':\n            md = forge.md.sha256.create();\n            break;\n        }\n      }\n      if(md === null) {\n        var error = new Error('Could not compute certificate digest. ' +\n          'Unknown signature OID.');\n        error.signatureOid = child.signatureOid;\n        throw error;\n      }\n\n      // produce DER formatted TBSCertificate and digest it\n      var tbsCertificate = child.tbsCertificate || pki.getTBSCertificate(child);\n      var bytes = asn1.toDer(tbsCertificate);\n      md.update(bytes.getBytes());\n    }\n\n    if(md !== null) {\n      var scheme;\n\n      switch(child.signatureOid) {\n        case oids.sha1WithRSAEncryption:\n          scheme = undefined; /* use PKCS#1 v1.5 padding scheme */\n          break;\n        case oids['RSASSA-PSS']:\n          var hash, mgf;\n\n          /* initialize mgf */\n          hash = oids[child.signatureParameters.mgf.hash.algorithmOid];\n          if(hash === undefined || forge.md[hash] === undefined) {\n            var error = new Error('Unsupported MGF hash function.');\n            error.oid = child.signatureParameters.mgf.hash.algorithmOid;\n            error.name = hash;\n            throw error;\n          }\n\n          mgf = oids[child.signatureParameters.mgf.algorithmOid];\n          if(mgf === undefined || forge.mgf[mgf] === undefined) {\n            var error = new Error('Unsupported MGF function.');\n            error.oid = child.signatureParameters.mgf.algorithmOid;\n            error.name = mgf;\n            throw error;\n          }\n\n          mgf = forge.mgf[mgf].create(forge.md[hash].create());\n\n          /* initialize hash function */\n          hash = oids[child.signatureParameters.hash.algorithmOid];\n          if(hash === undefined || forge.md[hash] === undefined) {\n            throw {\n              message: 'Unsupported RSASSA-PSS hash function.',\n              oid: child.signatureParameters.hash.algorithmOid,\n              name: hash\n            };\n          }\n\n          scheme = forge.pss.create(forge.md[hash].create(), mgf,\n            child.signatureParameters.saltLength);\n          break;\n      }\n\n      // verify signature on cert using public key\n      rval = cert.publicKey.verify(\n        md.digest().getBytes(), child.signature, scheme);\n    }\n\n    return rval;\n  };\n\n  /**\n   * Returns true if this certificate's issuer matches the passed\n   * certificate's subject. Note that no signature check is performed.\n   *\n   * @param parent the certificate to check.\n   *\n   * @return true if this certificate's issuer matches the passed certificate's\n   *         subject.\n   */\n  cert.isIssuer = function(parent) {\n    var rval = false;\n\n    var i = cert.issuer;\n    var s = parent.subject;\n\n    // compare hashes if present\n    if(i.hash && s.hash) {\n      rval = (i.hash === s.hash);\n    } else if(i.attributes.length === s.attributes.length) {\n      // all attributes are the same so issuer matches subject\n      rval = true;\n      var iattr, sattr;\n      for(var n = 0; rval && n < i.attributes.length; ++n) {\n        iattr = i.attributes[n];\n        sattr = s.attributes[n];\n        if(iattr.type !== sattr.type || iattr.value !== sattr.value) {\n          // attribute mismatch\n          rval = false;\n        }\n      }\n    }\n\n    return rval;\n  };\n\n  /**\n   * Returns true if this certificate's subject matches the issuer of the\n   * given certificate). Note that not signature check is performed.\n   *\n   * @param child the certificate to check.\n   *\n   * @return true if this certificate's subject matches the passed\n   *         certificate's issuer.\n   */\n  cert.issued = function(child) {\n    return child.isIssuer(cert);\n  };\n\n  /**\n   * Generates the subjectKeyIdentifier for this certificate as byte buffer.\n   *\n   * @return the subjectKeyIdentifier for this certificate as byte buffer.\n   */\n  cert.generateSubjectKeyIdentifier = function() {\n    /* See: 4.2.1.2 section of the the RFC3280, keyIdentifier is either:\n\n      (1) The keyIdentifier is composed of the 160-bit SHA-1 hash of the\n        value of the BIT STRING subjectPublicKey (excluding the tag,\n        length, and number of unused bits).\n\n      (2) The keyIdentifier is composed of a four bit type field with\n        the value 0100 followed by the least significant 60 bits of the\n        SHA-1 hash of the value of the BIT STRING subjectPublicKey\n        (excluding the tag, length, and number of unused bit string bits).\n    */\n\n    // skipping the tag, length, and number of unused bits is the same\n    // as just using the RSAPublicKey (for RSA keys, which are the\n    // only ones supported)\n    return pki.getPublicKeyFingerprint(cert.publicKey, {type: 'RSAPublicKey'});\n  };\n\n  /**\n   * Verifies the subjectKeyIdentifier extension value for this certificate\n   * against its public key. If no extension is found, false will be\n   * returned.\n   *\n   * @return true if verified, false if not.\n   */\n  cert.verifySubjectKeyIdentifier = function() {\n    var oid = oids['subjectKeyIdentifier'];\n    for(var i = 0; i < cert.extensions.length; ++i) {\n      var ext = cert.extensions[i];\n      if(ext.id === oid) {\n        var ski = cert.generateSubjectKeyIdentifier().getBytes();\n        return (forge.util.hexToBytes(ext.subjectKeyIdentifier) === ski);\n      }\n    }\n    return false;\n  };\n\n  return cert;\n};\n\n/**\n * Converts an X.509v3 RSA certificate from an ASN.1 object.\n *\n * Note: If the certificate is to be verified then compute hash should\n * be set to true. There is currently no implementation for converting\n * a certificate back to ASN.1 so the TBSCertificate part of the ASN.1\n * object needs to be scanned before the cert object is created.\n *\n * @param obj the asn1 representation of an X.509v3 RSA certificate.\n * @param computeHash true to compute the hash for verification.\n *\n * @return the certificate.\n */\npki.certificateFromAsn1 = function(obj, computeHash) {\n  // validate certificate and capture data\n  var capture = {};\n  var errors = [];\n  if(!asn1.validate(obj, x509CertificateValidator, capture, errors)) {\n    var error = new Error('Cannot read X.509 certificate. ' +\n      'ASN.1 object is not an X509v3 Certificate.');\n    error.errors = errors;\n    throw error;\n  }\n\n  // get oid\n  var oid = asn1.derToOid(capture.publicKeyOid);\n  if(oid !== pki.oids.rsaEncryption) {\n    throw new Error('Cannot read public key. OID is not RSA.');\n  }\n\n  // create certificate\n  var cert = pki.createCertificate();\n  cert.version = capture.certVersion ?\n    capture.certVersion.charCodeAt(0) : 0;\n  var serial = forge.util.createBuffer(capture.certSerialNumber);\n  cert.serialNumber = serial.toHex();\n  cert.signatureOid = forge.asn1.derToOid(capture.certSignatureOid);\n  cert.signatureParameters = _readSignatureParameters(\n    cert.signatureOid, capture.certSignatureParams, true);\n  cert.siginfo.algorithmOid = forge.asn1.derToOid(capture.certinfoSignatureOid);\n  cert.siginfo.parameters = _readSignatureParameters(cert.siginfo.algorithmOid,\n    capture.certinfoSignatureParams, false);\n  cert.signature = capture.certSignature;\n\n  var validity = [];\n  if(capture.certValidity1UTCTime !== undefined) {\n    validity.push(asn1.utcTimeToDate(capture.certValidity1UTCTime));\n  }\n  if(capture.certValidity2GeneralizedTime !== undefined) {\n    validity.push(asn1.generalizedTimeToDate(\n      capture.certValidity2GeneralizedTime));\n  }\n  if(capture.certValidity3UTCTime !== undefined) {\n    validity.push(asn1.utcTimeToDate(capture.certValidity3UTCTime));\n  }\n  if(capture.certValidity4GeneralizedTime !== undefined) {\n    validity.push(asn1.generalizedTimeToDate(\n      capture.certValidity4GeneralizedTime));\n  }\n  if(validity.length > 2) {\n    throw new Error('Cannot read notBefore/notAfter validity times; more ' +\n      'than two times were provided in the certificate.');\n  }\n  if(validity.length < 2) {\n    throw new Error('Cannot read notBefore/notAfter validity times; they ' +\n      'were not provided as either UTCTime or GeneralizedTime.');\n  }\n  cert.validity.notBefore = validity[0];\n  cert.validity.notAfter = validity[1];\n\n  // keep TBSCertificate to preserve signature when exporting\n  cert.tbsCertificate = capture.tbsCertificate;\n\n  if(computeHash) {\n    // check signature OID for supported signature types\n    cert.md = null;\n    if(cert.signatureOid in oids) {\n      var oid = oids[cert.signatureOid];\n      switch(oid) {\n        case 'sha1WithRSAEncryption':\n          cert.md = forge.md.sha1.create();\n          break;\n        case 'md5WithRSAEncryption':\n          cert.md = forge.md.md5.create();\n          break;\n        case 'sha256WithRSAEncryption':\n          cert.md = forge.md.sha256.create();\n          break;\n        case 'sha384WithRSAEncryption':\n          cert.md = forge.md.sha384.create();\n          break;\n        case 'sha512WithRSAEncryption':\n          cert.md = forge.md.sha512.create();\n          break;\n        case 'RSASSA-PSS':\n          cert.md = forge.md.sha256.create();\n          break;\n      }\n    }\n    if(cert.md === null) {\n      var error = new Error('Could not compute certificate digest. ' +\n        'Unknown signature OID.');\n      error.signatureOid = cert.signatureOid;\n      throw error;\n    }\n\n    // produce DER formatted TBSCertificate and digest it\n    var bytes = asn1.toDer(cert.tbsCertificate);\n    cert.md.update(bytes.getBytes());\n  }\n\n  // handle issuer, build issuer message digest\n  var imd = forge.md.sha1.create();\n  cert.issuer.getField = function(sn) {\n    return _getAttribute(cert.issuer, sn);\n  };\n  cert.issuer.addField = function(attr) {\n    _fillMissingFields([attr]);\n    cert.issuer.attributes.push(attr);\n  };\n  cert.issuer.attributes = pki.RDNAttributesAsArray(capture.certIssuer, imd);\n  if(capture.certIssuerUniqueId) {\n    cert.issuer.uniqueId = capture.certIssuerUniqueId;\n  }\n  cert.issuer.hash = imd.digest().toHex();\n\n  // handle subject, build subject message digest\n  var smd = forge.md.sha1.create();\n  cert.subject.getField = function(sn) {\n    return _getAttribute(cert.subject, sn);\n  };\n  cert.subject.addField = function(attr) {\n    _fillMissingFields([attr]);\n    cert.subject.attributes.push(attr);\n  };\n  cert.subject.attributes = pki.RDNAttributesAsArray(capture.certSubject, smd);\n  if(capture.certSubjectUniqueId) {\n    cert.subject.uniqueId = capture.certSubjectUniqueId;\n  }\n  cert.subject.hash = smd.digest().toHex();\n\n  // handle extensions\n  if(capture.certExtensions) {\n    cert.extensions = pki.certificateExtensionsFromAsn1(capture.certExtensions);\n  } else {\n    cert.extensions = [];\n  }\n\n  // convert RSA public key from ASN.1\n  cert.publicKey = pki.publicKeyFromAsn1(capture.subjectPublicKeyInfo);\n\n  return cert;\n};\n\n/**\n * Converts an ASN.1 extensions object (with extension sequences as its\n * values) into an array of extension objects with types and values.\n *\n * Supported extensions:\n *\n * id-ce-keyUsage OBJECT IDENTIFIER ::=  { id-ce 15 }\n * KeyUsage ::= BIT STRING {\n *   digitalSignature        (0),\n *   nonRepudiation          (1),\n *   keyEncipherment         (2),\n *   dataEncipherment        (3),\n *   keyAgreement            (4),\n *   keyCertSign             (5),\n *   cRLSign                 (6),\n *   encipherOnly            (7),\n *   decipherOnly            (8)\n * }\n *\n * id-ce-basicConstraints OBJECT IDENTIFIER ::=  { id-ce 19 }\n * BasicConstraints ::= SEQUENCE {\n *   cA                      BOOLEAN DEFAULT FALSE,\n *   pathLenConstraint       INTEGER (0..MAX) OPTIONAL\n * }\n *\n * subjectAltName EXTENSION ::= {\n *   SYNTAX GeneralNames\n *   IDENTIFIED BY id-ce-subjectAltName\n * }\n *\n * GeneralNames ::= SEQUENCE SIZE (1..MAX) OF GeneralName\n *\n * GeneralName ::= CHOICE {\n *   otherName      [0] INSTANCE OF OTHER-NAME,\n *   rfc822Name     [1] IA5String,\n *   dNSName        [2] IA5String,\n *   x400Address    [3] ORAddress,\n *   directoryName  [4] Name,\n *   ediPartyName   [5] EDIPartyName,\n *   uniformResourceIdentifier [6] IA5String,\n *   IPAddress      [7] OCTET STRING,\n *   registeredID   [8] OBJECT IDENTIFIER\n * }\n *\n * OTHER-NAME ::= TYPE-IDENTIFIER\n *\n * EDIPartyName ::= SEQUENCE {\n *   nameAssigner [0] DirectoryString {ub-name} OPTIONAL,\n *   partyName    [1] DirectoryString {ub-name}\n * }\n *\n * @param exts the extensions ASN.1 with extension sequences to parse.\n *\n * @return the array.\n */\npki.certificateExtensionsFromAsn1 = function(exts) {\n  var rval = [];\n  for(var i = 0; i < exts.value.length; ++i) {\n    // get extension sequence\n    var extseq = exts.value[i];\n    for(var ei = 0; ei < extseq.value.length; ++ei) {\n      rval.push(pki.certificateExtensionFromAsn1(extseq.value[ei]));\n    }\n  }\n\n  return rval;\n};\n\n/**\n * Parses a single certificate extension from ASN.1.\n *\n * @param ext the extension in ASN.1 format.\n *\n * @return the parsed extension as an object.\n */\npki.certificateExtensionFromAsn1 = function(ext) {\n  // an extension has:\n  // [0] extnID      OBJECT IDENTIFIER\n  // [1] critical    BOOLEAN DEFAULT FALSE\n  // [2] extnValue   OCTET STRING\n  var e = {};\n  e.id = asn1.derToOid(ext.value[0].value);\n  e.critical = false;\n  if(ext.value[1].type === asn1.Type.BOOLEAN) {\n    e.critical = (ext.value[1].value.charCodeAt(0) !== 0x00);\n    e.value = ext.value[2].value;\n  } else {\n    e.value = ext.value[1].value;\n  }\n  // if the oid is known, get its name\n  if(e.id in oids) {\n    e.name = oids[e.id];\n\n    // handle key usage\n    if(e.name === 'keyUsage') {\n      // get value as BIT STRING\n      var ev = asn1.fromDer(e.value);\n      var b2 = 0x00;\n      var b3 = 0x00;\n      if(ev.value.length > 1) {\n        // skip first byte, just indicates unused bits which\n        // will be padded with 0s anyway\n        // get bytes with flag bits\n        b2 = ev.value.charCodeAt(1);\n        b3 = ev.value.length > 2 ? ev.value.charCodeAt(2) : 0;\n      }\n      // set flags\n      e.digitalSignature = (b2 & 0x80) === 0x80;\n      e.nonRepudiation = (b2 & 0x40) === 0x40;\n      e.keyEncipherment = (b2 & 0x20) === 0x20;\n      e.dataEncipherment = (b2 & 0x10) === 0x10;\n      e.keyAgreement = (b2 & 0x08) === 0x08;\n      e.keyCertSign = (b2 & 0x04) === 0x04;\n      e.cRLSign = (b2 & 0x02) === 0x02;\n      e.encipherOnly = (b2 & 0x01) === 0x01;\n      e.decipherOnly = (b3 & 0x80) === 0x80;\n    } else if(e.name === 'basicConstraints') {\n      // handle basic constraints\n      // get value as SEQUENCE\n      var ev = asn1.fromDer(e.value);\n      // get cA BOOLEAN flag (defaults to false)\n      if(ev.value.length > 0 && ev.value[0].type === asn1.Type.BOOLEAN) {\n        e.cA = (ev.value[0].value.charCodeAt(0) !== 0x00);\n      } else {\n        e.cA = false;\n      }\n      // get path length constraint\n      var value = null;\n      if(ev.value.length > 0 && ev.value[0].type === asn1.Type.INTEGER) {\n        value = ev.value[0].value;\n      } else if(ev.value.length > 1) {\n        value = ev.value[1].value;\n      }\n      if(value !== null) {\n        e.pathLenConstraint = asn1.derToInteger(value);\n      }\n    } else if(e.name === 'extKeyUsage') {\n      // handle extKeyUsage\n      // value is a SEQUENCE of OIDs\n      var ev = asn1.fromDer(e.value);\n      for(var vi = 0; vi < ev.value.length; ++vi) {\n        var oid = asn1.derToOid(ev.value[vi].value);\n        if(oid in oids) {\n          e[oids[oid]] = true;\n        } else {\n          e[oid] = true;\n        }\n      }\n    } else if(e.name === 'nsCertType') {\n      // handle nsCertType\n      // get value as BIT STRING\n      var ev = asn1.fromDer(e.value);\n      var b2 = 0x00;\n      if(ev.value.length > 1) {\n        // skip first byte, just indicates unused bits which\n        // will be padded with 0s anyway\n        // get bytes with flag bits\n        b2 = ev.value.charCodeAt(1);\n      }\n      // set flags\n      e.client = (b2 & 0x80) === 0x80;\n      e.server = (b2 & 0x40) === 0x40;\n      e.email = (b2 & 0x20) === 0x20;\n      e.objsign = (b2 & 0x10) === 0x10;\n      e.reserved = (b2 & 0x08) === 0x08;\n      e.sslCA = (b2 & 0x04) === 0x04;\n      e.emailCA = (b2 & 0x02) === 0x02;\n      e.objCA = (b2 & 0x01) === 0x01;\n    } else if(\n      e.name === 'subjectAltName' ||\n      e.name === 'issuerAltName') {\n      // handle subjectAltName/issuerAltName\n      e.altNames = [];\n\n      // ev is a SYNTAX SEQUENCE\n      var gn;\n      var ev = asn1.fromDer(e.value);\n      for(var n = 0; n < ev.value.length; ++n) {\n        // get GeneralName\n        gn = ev.value[n];\n\n        var altName = {\n          type: gn.type,\n          value: gn.value\n        };\n        e.altNames.push(altName);\n\n        // Note: Support for types 1,2,6,7,8\n        switch(gn.type) {\n          // rfc822Name\n          case 1:\n          // dNSName\n          case 2:\n          // uniformResourceIdentifier (URI)\n          case 6:\n            break;\n          // IPAddress\n          case 7:\n            // convert to IPv4/IPv6 string representation\n            altName.ip = forge.util.bytesToIP(gn.value);\n            break;\n          // registeredID\n          case 8:\n            altName.oid = asn1.derToOid(gn.value);\n            break;\n          default:\n            // unsupported\n        }\n      }\n    } else if(e.name === 'subjectKeyIdentifier') {\n      // value is an OCTETSTRING w/the hash of the key-type specific\n      // public key structure (eg: RSAPublicKey)\n      var ev = asn1.fromDer(e.value);\n      e.subjectKeyIdentifier = forge.util.bytesToHex(ev.value);\n    }\n  }\n  return e;\n};\n\n/**\n * Converts a PKCS#10 certification request (CSR) from an ASN.1 object.\n *\n * Note: If the certification request is to be verified then compute hash\n * should be set to true. There is currently no implementation for converting\n * a certificate back to ASN.1 so the CertificationRequestInfo part of the\n * ASN.1 object needs to be scanned before the csr object is created.\n *\n * @param obj the asn1 representation of a PKCS#10 certification request (CSR).\n * @param computeHash true to compute the hash for verification.\n *\n * @return the certification request (CSR).\n */\npki.certificationRequestFromAsn1 = function(obj, computeHash) {\n  // validate certification request and capture data\n  var capture = {};\n  var errors = [];\n  if(!asn1.validate(obj, certificationRequestValidator, capture, errors)) {\n    var error = new Error('Cannot read PKCS#10 certificate request. ' +\n      'ASN.1 object is not a PKCS#10 CertificationRequest.');\n    error.errors = errors;\n    throw error;\n  }\n\n  // get oid\n  var oid = asn1.derToOid(capture.publicKeyOid);\n  if(oid !== pki.oids.rsaEncryption) {\n    throw new Error('Cannot read public key. OID is not RSA.');\n  }\n\n  // create certification request\n  var csr = pki.createCertificationRequest();\n  csr.version = capture.csrVersion ? capture.csrVersion.charCodeAt(0) : 0;\n  csr.signatureOid = forge.asn1.derToOid(capture.csrSignatureOid);\n  csr.signatureParameters = _readSignatureParameters(\n    csr.signatureOid, capture.csrSignatureParams, true);\n  csr.siginfo.algorithmOid = forge.asn1.derToOid(capture.csrSignatureOid);\n  csr.siginfo.parameters = _readSignatureParameters(\n    csr.siginfo.algorithmOid, capture.csrSignatureParams, false);\n  csr.signature = capture.csrSignature;\n\n  // keep CertificationRequestInfo to preserve signature when exporting\n  csr.certificationRequestInfo = capture.certificationRequestInfo;\n\n  if(computeHash) {\n    // check signature OID for supported signature types\n    csr.md = null;\n    if(csr.signatureOid in oids) {\n      var oid = oids[csr.signatureOid];\n      switch(oid) {\n        case 'sha1WithRSAEncryption':\n          csr.md = forge.md.sha1.create();\n          break;\n        case 'md5WithRSAEncryption':\n          csr.md = forge.md.md5.create();\n          break;\n        case 'sha256WithRSAEncryption':\n          csr.md = forge.md.sha256.create();\n          break;\n        case 'sha384WithRSAEncryption':\n          csr.md = forge.md.sha384.create();\n          break;\n        case 'sha512WithRSAEncryption':\n          csr.md = forge.md.sha512.create();\n          break;\n        case 'RSASSA-PSS':\n          csr.md = forge.md.sha256.create();\n          break;\n      }\n    }\n    if(csr.md === null) {\n      var error = new Error('Could not compute certification request digest. ' +\n        'Unknown signature OID.');\n      error.signatureOid = csr.signatureOid;\n      throw error;\n    }\n\n    // produce DER formatted CertificationRequestInfo and digest it\n    var bytes = asn1.toDer(csr.certificationRequestInfo);\n    csr.md.update(bytes.getBytes());\n  }\n\n  // handle subject, build subject message digest\n  var smd = forge.md.sha1.create();\n  csr.subject.getField = function(sn) {\n    return _getAttribute(csr.subject, sn);\n  };\n  csr.subject.addField = function(attr) {\n    _fillMissingFields([attr]);\n    csr.subject.attributes.push(attr);\n  };\n  csr.subject.attributes = pki.RDNAttributesAsArray(\n    capture.certificationRequestInfoSubject, smd);\n  csr.subject.hash = smd.digest().toHex();\n\n  // convert RSA public key from ASN.1\n  csr.publicKey = pki.publicKeyFromAsn1(capture.subjectPublicKeyInfo);\n\n  // convert attributes from ASN.1\n  csr.getAttribute = function(sn) {\n    return _getAttribute(csr, sn);\n  };\n  csr.addAttribute = function(attr) {\n    _fillMissingFields([attr]);\n    csr.attributes.push(attr);\n  };\n  csr.attributes = pki.CRIAttributesAsArray(\n    capture.certificationRequestInfoAttributes || []);\n\n  return csr;\n};\n\n/**\n * Creates an empty certification request (a CSR or certificate signing\n * request). Once created, its public key and attributes can be set and then\n * it can be signed.\n *\n * @return the empty certification request.\n */\npki.createCertificationRequest = function() {\n  var csr = {};\n  csr.version = 0x00;\n  csr.signatureOid = null;\n  csr.signature = null;\n  csr.siginfo = {};\n  csr.siginfo.algorithmOid = null;\n\n  csr.subject = {};\n  csr.subject.getField = function(sn) {\n    return _getAttribute(csr.subject, sn);\n  };\n  csr.subject.addField = function(attr) {\n    _fillMissingFields([attr]);\n    csr.subject.attributes.push(attr);\n  };\n  csr.subject.attributes = [];\n  csr.subject.hash = null;\n\n  csr.publicKey = null;\n  csr.attributes = [];\n  csr.getAttribute = function(sn) {\n    return _getAttribute(csr, sn);\n  };\n  csr.addAttribute = function(attr) {\n    _fillMissingFields([attr]);\n    csr.attributes.push(attr);\n  };\n  csr.md = null;\n\n  /**\n   * Sets the subject of this certification request.\n   *\n   * @param attrs the array of subject attributes to use.\n   */\n  csr.setSubject = function(attrs) {\n    // set new attributes\n    _fillMissingFields(attrs);\n    csr.subject.attributes = attrs;\n    csr.subject.hash = null;\n  };\n\n  /**\n   * Sets the attributes of this certification request.\n   *\n   * @param attrs the array of attributes to use.\n   */\n  csr.setAttributes = function(attrs) {\n    // set new attributes\n    _fillMissingFields(attrs);\n    csr.attributes = attrs;\n  };\n\n  /**\n   * Signs this certification request using the given private key.\n   *\n   * @param key the private key to sign with.\n   * @param md the message digest object to use (defaults to forge.md.sha1).\n   */\n  csr.sign = function(key, md) {\n    // TODO: get signature OID from private key\n    csr.md = md || forge.md.sha1.create();\n    var algorithmOid = oids[csr.md.algorithm + 'WithRSAEncryption'];\n    if(!algorithmOid) {\n      var error = new Error('Could not compute certification request digest. ' +\n        'Unknown message digest algorithm OID.');\n      error.algorithm = csr.md.algorithm;\n      throw error;\n    }\n    csr.signatureOid = csr.siginfo.algorithmOid = algorithmOid;\n\n    // get CertificationRequestInfo, convert to DER\n    csr.certificationRequestInfo = pki.getCertificationRequestInfo(csr);\n    var bytes = asn1.toDer(csr.certificationRequestInfo);\n\n    // digest and sign\n    csr.md.update(bytes.getBytes());\n    csr.signature = key.sign(csr.md);\n  };\n\n  /**\n   * Attempts verify the signature on the passed certification request using\n   * its public key.\n   *\n   * A CSR that has been exported to a file in PEM format can be verified using\n   * OpenSSL using this command:\n   *\n   * openssl req -in <the-csr-pem-file> -verify -noout -text\n   *\n   * @return true if verified, false if not.\n   */\n  csr.verify = function() {\n    var rval = false;\n\n    var md = csr.md;\n    if(md === null) {\n      // check signature OID for supported signature types\n      if(csr.signatureOid in oids) {\n        // TODO: create DRY `OID to md` function\n        var oid = oids[csr.signatureOid];\n        switch(oid) {\n          case 'sha1WithRSAEncryption':\n            md = forge.md.sha1.create();\n            break;\n          case 'md5WithRSAEncryption':\n            md = forge.md.md5.create();\n            break;\n          case 'sha256WithRSAEncryption':\n            md = forge.md.sha256.create();\n            break;\n          case 'sha384WithRSAEncryption':\n            md = forge.md.sha384.create();\n            break;\n          case 'sha512WithRSAEncryption':\n            md = forge.md.sha512.create();\n            break;\n          case 'RSASSA-PSS':\n            md = forge.md.sha256.create();\n            break;\n        }\n      }\n      if(md === null) {\n        var error = new Error(\n          'Could not compute certification request digest. ' +\n          'Unknown signature OID.');\n        error.signatureOid = csr.signatureOid;\n        throw error;\n      }\n\n      // produce DER formatted CertificationRequestInfo and digest it\n      var cri = csr.certificationRequestInfo ||\n        pki.getCertificationRequestInfo(csr);\n      var bytes = asn1.toDer(cri);\n      md.update(bytes.getBytes());\n    }\n\n    if(md !== null) {\n      var scheme;\n\n      switch(csr.signatureOid) {\n        case oids.sha1WithRSAEncryption:\n          /* use PKCS#1 v1.5 padding scheme */\n          break;\n        case oids['RSASSA-PSS']:\n          var hash, mgf;\n\n          /* initialize mgf */\n          hash = oids[csr.signatureParameters.mgf.hash.algorithmOid];\n          if(hash === undefined || forge.md[hash] === undefined) {\n            var error = new Error('Unsupported MGF hash function.');\n            error.oid = csr.signatureParameters.mgf.hash.algorithmOid;\n            error.name = hash;\n            throw error;\n          }\n\n          mgf = oids[csr.signatureParameters.mgf.algorithmOid];\n          if(mgf === undefined || forge.mgf[mgf] === undefined) {\n            var error = new Error('Unsupported MGF function.');\n            error.oid = csr.signatureParameters.mgf.algorithmOid;\n            error.name = mgf;\n            throw error;\n          }\n\n          mgf = forge.mgf[mgf].create(forge.md[hash].create());\n\n          /* initialize hash function */\n          hash = oids[csr.signatureParameters.hash.algorithmOid];\n          if(hash === undefined || forge.md[hash] === undefined) {\n            var error = new Error('Unsupported RSASSA-PSS hash function.');\n            error.oid = csr.signatureParameters.hash.algorithmOid;\n            error.name = hash;\n            throw error;\n          }\n\n          scheme = forge.pss.create(forge.md[hash].create(), mgf,\n            csr.signatureParameters.saltLength);\n          break;\n      }\n\n      // verify signature on csr using its public key\n      rval = csr.publicKey.verify(\n        md.digest().getBytes(), csr.signature, scheme);\n    }\n\n    return rval;\n  };\n\n  return csr;\n};\n\n/**\n * Converts an X.509 subject or issuer to an ASN.1 RDNSequence.\n *\n * @param obj the subject or issuer (distinguished name).\n *\n * @return the ASN.1 RDNSequence.\n */\nfunction _dnToAsn1(obj) {\n  // create an empty RDNSequence\n  var rval = asn1.create(\n    asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);\n\n  // iterate over attributes\n  var attr, set;\n  var attrs = obj.attributes;\n  for(var i = 0; i < attrs.length; ++i) {\n    attr = attrs[i];\n    var value = attr.value;\n\n    // reuse tag class for attribute value if available\n    var valueTagClass = asn1.Type.PRINTABLESTRING;\n    if('valueTagClass' in attr) {\n      valueTagClass = attr.valueTagClass;\n\n      if(valueTagClass === asn1.Type.UTF8) {\n        value = forge.util.encodeUtf8(value);\n      }\n      // FIXME: handle more encodings\n    }\n\n    // create a RelativeDistinguishedName set\n    // each value in the set is an AttributeTypeAndValue first\n    // containing the type (an OID) and second the value\n    set = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n        // AttributeType\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\n          asn1.oidToDer(attr.type).getBytes()),\n        // AttributeValue\n        asn1.create(asn1.Class.UNIVERSAL, valueTagClass, false, value)\n      ])\n    ]);\n    rval.value.push(set);\n  }\n\n  return rval;\n}\n\n/**\n * Gets all printable attributes (typically of an issuer or subject) in a\n * simplified JSON format for display.\n *\n * @param attrs the attributes.\n *\n * @return the JSON for display.\n */\nfunction _getAttributesAsJson(attrs) {\n  var rval = {};\n  for(var i = 0; i < attrs.length; ++i) {\n    var attr = attrs[i];\n    if(attr.shortName && (\n      attr.valueTagClass === asn1.Type.UTF8 ||\n      attr.valueTagClass === asn1.Type.PRINTABLESTRING ||\n      attr.valueTagClass === asn1.Type.IA5STRING)) {\n      var value = attr.value;\n      if(attr.valueTagClass === asn1.Type.UTF8) {\n        value = forge.util.encodeUtf8(attr.value);\n      }\n      if(!(attr.shortName in rval)) {\n        rval[attr.shortName] = value;\n      } else if(forge.util.isArray(rval[attr.shortName])) {\n        rval[attr.shortName].push(value);\n      } else {\n        rval[attr.shortName] = [rval[attr.shortName], value];\n      }\n    }\n  }\n  return rval;\n}\n\n/**\n * Fills in missing fields in attributes.\n *\n * @param attrs the attributes to fill missing fields in.\n */\nfunction _fillMissingFields(attrs) {\n  var attr;\n  for(var i = 0; i < attrs.length; ++i) {\n    attr = attrs[i];\n\n    // populate missing name\n    if(typeof attr.name === 'undefined') {\n      if(attr.type && attr.type in pki.oids) {\n        attr.name = pki.oids[attr.type];\n      } else if(attr.shortName && attr.shortName in _shortNames) {\n        attr.name = pki.oids[_shortNames[attr.shortName]];\n      }\n    }\n\n    // populate missing type (OID)\n    if(typeof attr.type === 'undefined') {\n      if(attr.name && attr.name in pki.oids) {\n        attr.type = pki.oids[attr.name];\n      } else {\n        var error = new Error('Attribute type not specified.');\n        error.attribute = attr;\n        throw error;\n      }\n    }\n\n    // populate missing shortname\n    if(typeof attr.shortName === 'undefined') {\n      if(attr.name && attr.name in _shortNames) {\n        attr.shortName = _shortNames[attr.name];\n      }\n    }\n\n    // convert extensions to value\n    if(attr.type === oids.extensionRequest) {\n      attr.valueConstructed = true;\n      attr.valueTagClass = asn1.Type.SEQUENCE;\n      if(!attr.value && attr.extensions) {\n        attr.value = [];\n        for(var ei = 0; ei < attr.extensions.length; ++ei) {\n          attr.value.push(pki.certificateExtensionToAsn1(\n            _fillMissingExtensionFields(attr.extensions[ei])));\n        }\n      }\n    }\n\n    if(typeof attr.value === 'undefined') {\n      var error = new Error('Attribute value not specified.');\n      error.attribute = attr;\n      throw error;\n    }\n  }\n}\n\n/**\n * Fills in missing fields in certificate extensions.\n *\n * @param e the extension.\n * @param [options] the options to use.\n *          [cert] the certificate the extensions are for.\n *\n * @return the extension.\n */\nfunction _fillMissingExtensionFields(e, options) {\n  options = options || {};\n\n  // populate missing name\n  if(typeof e.name === 'undefined') {\n    if(e.id && e.id in pki.oids) {\n      e.name = pki.oids[e.id];\n    }\n  }\n\n  // populate missing id\n  if(typeof e.id === 'undefined') {\n    if(e.name && e.name in pki.oids) {\n      e.id = pki.oids[e.name];\n    } else {\n      var error = new Error('Extension ID not specified.');\n      error.extension = e;\n      throw error;\n    }\n  }\n\n  if(typeof e.value !== 'undefined') {\n    return e;\n  }\n\n  // handle missing value:\n\n  // value is a BIT STRING\n  if(e.name === 'keyUsage') {\n    // build flags\n    var unused = 0;\n    var b2 = 0x00;\n    var b3 = 0x00;\n    if(e.digitalSignature) {\n      b2 |= 0x80;\n      unused = 7;\n    }\n    if(e.nonRepudiation) {\n      b2 |= 0x40;\n      unused = 6;\n    }\n    if(e.keyEncipherment) {\n      b2 |= 0x20;\n      unused = 5;\n    }\n    if(e.dataEncipherment) {\n      b2 |= 0x10;\n      unused = 4;\n    }\n    if(e.keyAgreement) {\n      b2 |= 0x08;\n      unused = 3;\n    }\n    if(e.keyCertSign) {\n      b2 |= 0x04;\n      unused = 2;\n    }\n    if(e.cRLSign) {\n      b2 |= 0x02;\n      unused = 1;\n    }\n    if(e.encipherOnly) {\n      b2 |= 0x01;\n      unused = 0;\n    }\n    if(e.decipherOnly) {\n      b3 |= 0x80;\n      unused = 7;\n    }\n\n    // create bit string\n    var value = String.fromCharCode(unused);\n    if(b3 !== 0) {\n      value += String.fromCharCode(b2) + String.fromCharCode(b3);\n    } else if(b2 !== 0) {\n      value += String.fromCharCode(b2);\n    }\n    e.value = asn1.create(\n      asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, value);\n  } else if(e.name === 'basicConstraints') {\n    // basicConstraints is a SEQUENCE\n    e.value = asn1.create(\n      asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);\n    // cA BOOLEAN flag defaults to false\n    if(e.cA) {\n      e.value.value.push(asn1.create(\n        asn1.Class.UNIVERSAL, asn1.Type.BOOLEAN, false,\n        String.fromCharCode(0xFF)));\n    }\n    if('pathLenConstraint' in e) {\n      e.value.value.push(asn1.create(\n        asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\n        asn1.integerToDer(e.pathLenConstraint).getBytes()));\n    }\n  } else if(e.name === 'extKeyUsage') {\n    // extKeyUsage is a SEQUENCE of OIDs\n    e.value = asn1.create(\n      asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);\n    var seq = e.value.value;\n    for(var key in e) {\n      if(e[key] !== true) {\n        continue;\n      }\n      // key is name in OID map\n      if(key in oids) {\n        seq.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID,\n          false, asn1.oidToDer(oids[key]).getBytes()));\n      } else if(key.indexOf('.') !== -1) {\n        // assume key is an OID\n        seq.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID,\n          false, asn1.oidToDer(key).getBytes()));\n      }\n    }\n  } else if(e.name === 'nsCertType') {\n    // nsCertType is a BIT STRING\n    // build flags\n    var unused = 0;\n    var b2 = 0x00;\n\n    if(e.client) {\n      b2 |= 0x80;\n      unused = 7;\n    }\n    if(e.server) {\n      b2 |= 0x40;\n      unused = 6;\n    }\n    if(e.email) {\n      b2 |= 0x20;\n      unused = 5;\n    }\n    if(e.objsign) {\n      b2 |= 0x10;\n      unused = 4;\n    }\n    if(e.reserved) {\n      b2 |= 0x08;\n      unused = 3;\n    }\n    if(e.sslCA) {\n      b2 |= 0x04;\n      unused = 2;\n    }\n    if(e.emailCA) {\n      b2 |= 0x02;\n      unused = 1;\n    }\n    if(e.objCA) {\n      b2 |= 0x01;\n      unused = 0;\n    }\n\n    // create bit string\n    var value = String.fromCharCode(unused);\n    if(b2 !== 0) {\n      value += String.fromCharCode(b2);\n    }\n    e.value = asn1.create(\n      asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, value);\n  } else if(e.name === 'subjectAltName' || e.name === 'issuerAltName') {\n    // SYNTAX SEQUENCE\n    e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);\n\n    var altName;\n    for(var n = 0; n < e.altNames.length; ++n) {\n      altName = e.altNames[n];\n      var value = altName.value;\n      // handle IP\n      if(altName.type === 7 && altName.ip) {\n        value = forge.util.bytesFromIP(altName.ip);\n        if(value === null) {\n          var error = new Error(\n            'Extension \"ip\" value is not a valid IPv4 or IPv6 address.');\n          error.extension = e;\n          throw error;\n        }\n      } else if(altName.type === 8) {\n        // handle OID\n        if(altName.oid) {\n          value = asn1.oidToDer(asn1.oidToDer(altName.oid));\n        } else {\n          // deprecated ... convert value to OID\n          value = asn1.oidToDer(value);\n        }\n      }\n      e.value.value.push(asn1.create(\n        asn1.Class.CONTEXT_SPECIFIC, altName.type, false,\n        value));\n    }\n  } else if(e.name === 'nsComment' && options.cert) {\n    // sanity check value is ASCII (req'd) and not too big\n    if(!(/^[\\x00-\\x7F]*$/.test(e.comment)) ||\n      (e.comment.length < 1) || (e.comment.length > 128)) {\n      throw new Error('Invalid \"nsComment\" content.');\n    }\n    // IA5STRING opaque comment\n    e.value = asn1.create(\n      asn1.Class.UNIVERSAL, asn1.Type.IA5STRING, false, e.comment);\n  } else if(e.name === 'subjectKeyIdentifier' && options.cert) {\n    var ski = options.cert.generateSubjectKeyIdentifier();\n    e.subjectKeyIdentifier = ski.toHex();\n    // OCTETSTRING w/digest\n    e.value = asn1.create(\n      asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, ski.getBytes());\n  } else if(e.name === 'authorityKeyIdentifier' && options.cert) {\n    // SYNTAX SEQUENCE\n    e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);\n    var seq = e.value.value;\n\n    if(e.keyIdentifier) {\n      var keyIdentifier = (e.keyIdentifier === true ?\n        options.cert.generateSubjectKeyIdentifier().getBytes() :\n        e.keyIdentifier);\n      seq.push(\n        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, false, keyIdentifier));\n    }\n\n    if(e.authorityCertIssuer) {\n      var authorityCertIssuer = [\n        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 4, true, [\n          _dnToAsn1(e.authorityCertIssuer === true ?\n            options.cert.issuer : e.authorityCertIssuer)\n        ])\n      ];\n      seq.push(\n        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, authorityCertIssuer));\n    }\n\n    if(e.serialNumber) {\n      var serialNumber = forge.util.hexToBytes(e.serialNumber === true ?\n        options.cert.serialNumber : e.serialNumber);\n      seq.push(\n        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, false, serialNumber));\n    }\n  } else if(e.name === 'cRLDistributionPoints') {\n    e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);\n    var seq = e.value.value;\n\n    // Create sub SEQUENCE of DistributionPointName\n    var subSeq = asn1.create(\n      asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);\n\n    // Create fullName CHOICE\n    var fullNameGeneralNames = asn1.create(\n      asn1.Class.CONTEXT_SPECIFIC, 0, true, []);\n    var altName;\n    for(var n = 0; n < e.altNames.length; ++n) {\n      altName = e.altNames[n];\n      var value = altName.value;\n      // handle IP\n      if(altName.type === 7 && altName.ip) {\n        value = forge.util.bytesFromIP(altName.ip);\n        if(value === null) {\n          var error = new Error(\n            'Extension \"ip\" value is not a valid IPv4 or IPv6 address.');\n          error.extension = e;\n          throw error;\n        }\n      } else if(altName.type === 8) {\n        // handle OID\n        if(altName.oid) {\n          value = asn1.oidToDer(asn1.oidToDer(altName.oid));\n        } else {\n          // deprecated ... convert value to OID\n          value = asn1.oidToDer(value);\n        }\n      }\n      fullNameGeneralNames.value.push(asn1.create(\n        asn1.Class.CONTEXT_SPECIFIC, altName.type, false,\n        value));\n    }\n\n    // Add to the parent SEQUENCE\n    subSeq.value.push(asn1.create(\n      asn1.Class.CONTEXT_SPECIFIC, 0, true, [fullNameGeneralNames]));\n    seq.push(subSeq);\n  }\n\n  // ensure value has been defined by now\n  if(typeof e.value === 'undefined') {\n    var error = new Error('Extension value not specified.');\n    error.extension = e;\n    throw error;\n  }\n\n  return e;\n}\n\n/**\n * Convert signature parameters object to ASN.1\n *\n * @param {String} oid Signature algorithm OID\n * @param params The signature parametrs object\n * @return ASN.1 object representing signature parameters\n */\nfunction _signatureParametersToAsn1(oid, params) {\n  switch(oid) {\n    case oids['RSASSA-PSS']:\n      var parts = [];\n\n      if(params.hash.algorithmOid !== undefined) {\n        parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\n          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\n              asn1.oidToDer(params.hash.algorithmOid).getBytes()),\n            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')\n          ])\n        ]));\n      }\n\n      if(params.mgf.algorithmOid !== undefined) {\n        parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, [\n          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\n              asn1.oidToDer(params.mgf.algorithmOid).getBytes()),\n            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\n                asn1.oidToDer(params.mgf.hash.algorithmOid).getBytes()),\n              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')\n            ])\n          ])\n        ]));\n      }\n\n      if(params.saltLength !== undefined) {\n        parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, true, [\n          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\n            asn1.integerToDer(params.saltLength).getBytes())\n        ]));\n      }\n\n      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, parts);\n\n    default:\n      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '');\n  }\n}\n\n/**\n * Converts a certification request's attributes to an ASN.1 set of\n * CRIAttributes.\n *\n * @param csr certification request.\n *\n * @return the ASN.1 set of CRIAttributes.\n */\nfunction _CRIAttributesToAsn1(csr) {\n  // create an empty context-specific container\n  var rval = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, []);\n\n  // no attributes, return empty container\n  if(csr.attributes.length === 0) {\n    return rval;\n  }\n\n  // each attribute has a sequence with a type and a set of values\n  var attrs = csr.attributes;\n  for(var i = 0; i < attrs.length; ++i) {\n    var attr = attrs[i];\n    var value = attr.value;\n\n    // reuse tag class for attribute value if available\n    var valueTagClass = asn1.Type.UTF8;\n    if('valueTagClass' in attr) {\n      valueTagClass = attr.valueTagClass;\n    }\n    if(valueTagClass === asn1.Type.UTF8) {\n      value = forge.util.encodeUtf8(value);\n    }\n    var valueConstructed = false;\n    if('valueConstructed' in attr) {\n      valueConstructed = attr.valueConstructed;\n    }\n    // FIXME: handle more encodings\n\n    // create a RelativeDistinguishedName set\n    // each value in the set is an AttributeTypeAndValue first\n    // containing the type (an OID) and second the value\n    var seq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n      // AttributeType\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\n        asn1.oidToDer(attr.type).getBytes()),\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [\n        // AttributeValue\n        asn1.create(\n          asn1.Class.UNIVERSAL, valueTagClass, valueConstructed, value)\n      ])\n    ]);\n    rval.value.push(seq);\n  }\n\n  return rval;\n}\n\nvar jan_1_1950 = new Date('1950-01-01T00:00:00Z');\nvar jan_1_2050 = new Date('2050-01-01T00:00:00Z');\n\n/**\n * Converts a Date object to ASN.1\n * Handles the different format before and after 1st January 2050\n *\n * @param date date object.\n *\n * @return the ASN.1 object representing the date.\n */\nfunction _dateToAsn1(date) {\n  if(date >= jan_1_1950 && date < jan_1_2050) {\n    return asn1.create(\n      asn1.Class.UNIVERSAL, asn1.Type.UTCTIME, false,\n      asn1.dateToUtcTime(date));\n  } else {\n    return asn1.create(\n      asn1.Class.UNIVERSAL, asn1.Type.GENERALIZEDTIME, false,\n      asn1.dateToGeneralizedTime(date));\n  }\n}\n\n/**\n * Gets the ASN.1 TBSCertificate part of an X.509v3 certificate.\n *\n * @param cert the certificate.\n *\n * @return the asn1 TBSCertificate.\n */\npki.getTBSCertificate = function(cert) {\n  // TBSCertificate\n  var notBefore = _dateToAsn1(cert.validity.notBefore);\n  var notAfter = _dateToAsn1(cert.validity.notAfter);\n  var tbs = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n    // version\n    asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\n      // integer\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\n        asn1.integerToDer(cert.version).getBytes())\n    ]),\n    // serialNumber\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\n      forge.util.hexToBytes(cert.serialNumber)),\n    // signature\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n      // algorithm\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\n        asn1.oidToDer(cert.siginfo.algorithmOid).getBytes()),\n      // parameters\n      _signatureParametersToAsn1(\n        cert.siginfo.algorithmOid, cert.siginfo.parameters)\n    ]),\n    // issuer\n    _dnToAsn1(cert.issuer),\n    // validity\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n      notBefore,\n      notAfter\n    ]),\n    // subject\n    _dnToAsn1(cert.subject),\n    // SubjectPublicKeyInfo\n    pki.publicKeyToAsn1(cert.publicKey)\n  ]);\n\n  if(cert.issuer.uniqueId) {\n    // issuerUniqueID (optional)\n    tbs.value.push(\n      asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, [\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false,\n          // TODO: support arbitrary bit length ids\n          String.fromCharCode(0x00) +\n          cert.issuer.uniqueId\n        )\n      ])\n    );\n  }\n  if(cert.subject.uniqueId) {\n    // subjectUniqueID (optional)\n    tbs.value.push(\n      asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, true, [\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false,\n          // TODO: support arbitrary bit length ids\n          String.fromCharCode(0x00) +\n          cert.subject.uniqueId\n        )\n      ])\n    );\n  }\n\n  if(cert.extensions.length > 0) {\n    // extensions (optional)\n    tbs.value.push(pki.certificateExtensionsToAsn1(cert.extensions));\n  }\n\n  return tbs;\n};\n\n/**\n * Gets the ASN.1 CertificationRequestInfo part of a\n * PKCS#10 CertificationRequest.\n *\n * @param csr the certification request.\n *\n * @return the asn1 CertificationRequestInfo.\n */\npki.getCertificationRequestInfo = function(csr) {\n  // CertificationRequestInfo\n  var cri = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n    // version\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\n      asn1.integerToDer(csr.version).getBytes()),\n    // subject\n    _dnToAsn1(csr.subject),\n    // SubjectPublicKeyInfo\n    pki.publicKeyToAsn1(csr.publicKey),\n    // attributes\n    _CRIAttributesToAsn1(csr)\n  ]);\n\n  return cri;\n};\n\n/**\n * Converts a DistinguishedName (subject or issuer) to an ASN.1 object.\n *\n * @param dn the DistinguishedName.\n *\n * @return the asn1 representation of a DistinguishedName.\n */\npki.distinguishedNameToAsn1 = function(dn) {\n  return _dnToAsn1(dn);\n};\n\n/**\n * Converts an X.509v3 RSA certificate to an ASN.1 object.\n *\n * @param cert the certificate.\n *\n * @return the asn1 representation of an X.509v3 RSA certificate.\n */\npki.certificateToAsn1 = function(cert) {\n  // prefer cached TBSCertificate over generating one\n  var tbsCertificate = cert.tbsCertificate || pki.getTBSCertificate(cert);\n\n  // Certificate\n  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n    // TBSCertificate\n    tbsCertificate,\n    // AlgorithmIdentifier (signature algorithm)\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n      // algorithm\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\n        asn1.oidToDer(cert.signatureOid).getBytes()),\n      // parameters\n      _signatureParametersToAsn1(cert.signatureOid, cert.signatureParameters)\n    ]),\n    // SignatureValue\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false,\n      String.fromCharCode(0x00) + cert.signature)\n  ]);\n};\n\n/**\n * Converts X.509v3 certificate extensions to ASN.1.\n *\n * @param exts the extensions to convert.\n *\n * @return the extensions in ASN.1 format.\n */\npki.certificateExtensionsToAsn1 = function(exts) {\n  // create top-level extension container\n  var rval = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 3, true, []);\n\n  // create extension sequence (stores a sequence for each extension)\n  var seq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);\n  rval.value.push(seq);\n\n  for(var i = 0; i < exts.length; ++i) {\n    seq.value.push(pki.certificateExtensionToAsn1(exts[i]));\n  }\n\n  return rval;\n};\n\n/**\n * Converts a single certificate extension to ASN.1.\n *\n * @param ext the extension to convert.\n *\n * @return the extension in ASN.1 format.\n */\npki.certificateExtensionToAsn1 = function(ext) {\n  // create a sequence for each extension\n  var extseq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);\n\n  // extnID (OID)\n  extseq.value.push(asn1.create(\n    asn1.Class.UNIVERSAL, asn1.Type.OID, false,\n    asn1.oidToDer(ext.id).getBytes()));\n\n  // critical defaults to false\n  if(ext.critical) {\n    // critical BOOLEAN DEFAULT FALSE\n    extseq.value.push(asn1.create(\n      asn1.Class.UNIVERSAL, asn1.Type.BOOLEAN, false,\n      String.fromCharCode(0xFF)));\n  }\n\n  var value = ext.value;\n  if(typeof ext.value !== 'string') {\n    // value is asn.1\n    value = asn1.toDer(value).getBytes();\n  }\n\n  // extnValue (OCTET STRING)\n  extseq.value.push(asn1.create(\n    asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, value));\n\n  return extseq;\n};\n\n/**\n * Converts a PKCS#10 certification request to an ASN.1 object.\n *\n * @param csr the certification request.\n *\n * @return the asn1 representation of a certification request.\n */\npki.certificationRequestToAsn1 = function(csr) {\n  // prefer cached CertificationRequestInfo over generating one\n  var cri = csr.certificationRequestInfo ||\n    pki.getCertificationRequestInfo(csr);\n\n  // Certificate\n  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n    // CertificationRequestInfo\n    cri,\n    // AlgorithmIdentifier (signature algorithm)\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n      // algorithm\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\n        asn1.oidToDer(csr.signatureOid).getBytes()),\n      // parameters\n      _signatureParametersToAsn1(csr.signatureOid, csr.signatureParameters)\n    ]),\n    // signature\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false,\n      String.fromCharCode(0x00) + csr.signature)\n  ]);\n};\n\n/**\n * Creates a CA store.\n *\n * @param certs an optional array of certificate objects or PEM-formatted\n *          certificate strings to add to the CA store.\n *\n * @return the CA store.\n */\npki.createCaStore = function(certs) {\n  // create CA store\n  var caStore = {\n    // stored certificates\n    certs: {}\n  };\n\n  /**\n   * Gets the certificate that issued the passed certificate or its\n   * 'parent'.\n   *\n   * @param cert the certificate to get the parent for.\n   *\n   * @return the parent certificate or null if none was found.\n   */\n  caStore.getIssuer = function(cert) {\n    var rval = getBySubject(cert.issuer);\n\n    // see if there are multiple matches\n    /*if(forge.util.isArray(rval)) {\n      // TODO: resolve multiple matches by checking\n      // authorityKey/subjectKey/issuerUniqueID/other identifiers, etc.\n      // FIXME: or alternatively do authority key mapping\n      // if possible (X.509v1 certs can't work?)\n      throw new Error('Resolving multiple issuer matches not implemented yet.');\n    }*/\n\n    return rval;\n  };\n\n  /**\n   * Adds a trusted certificate to the store.\n   *\n   * @param cert the certificate to add as a trusted certificate (either a\n   *          pki.certificate object or a PEM-formatted certificate).\n   */\n  caStore.addCertificate = function(cert) {\n    // convert from pem if necessary\n    if(typeof cert === 'string') {\n      cert = forge.pki.certificateFromPem(cert);\n    }\n\n    ensureSubjectHasHash(cert.subject);\n\n    if(!caStore.hasCertificate(cert)) { // avoid duplicate certificates in store\n      if(cert.subject.hash in caStore.certs) {\n        // subject hash already exists, append to array\n        var tmp = caStore.certs[cert.subject.hash];\n        if(!forge.util.isArray(tmp)) {\n          tmp = [tmp];\n        }\n        tmp.push(cert);\n        caStore.certs[cert.subject.hash] = tmp;\n      } else {\n        caStore.certs[cert.subject.hash] = cert;\n      }\n    }\n  };\n\n  /**\n   * Checks to see if the given certificate is in the store.\n   *\n   * @param cert the certificate to check (either a pki.certificate or a\n   *          PEM-formatted certificate).\n   *\n   * @return true if the certificate is in the store, false if not.\n   */\n  caStore.hasCertificate = function(cert) {\n    // convert from pem if necessary\n    if(typeof cert === 'string') {\n      cert = forge.pki.certificateFromPem(cert);\n    }\n\n    var match = getBySubject(cert.subject);\n    if(!match) {\n      return false;\n    }\n    if(!forge.util.isArray(match)) {\n      match = [match];\n    }\n    // compare DER-encoding of certificates\n    var der1 = asn1.toDer(pki.certificateToAsn1(cert)).getBytes();\n    for(var i = 0; i < match.length; ++i) {\n      var der2 = asn1.toDer(pki.certificateToAsn1(match[i])).getBytes();\n      if(der1 === der2) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  /**\n   * Lists all of the certificates kept in the store.\n   *\n   * @return an array of all of the pki.certificate objects in the store.\n   */\n  caStore.listAllCertificates = function() {\n    var certList = [];\n\n    for(var hash in caStore.certs) {\n      if(caStore.certs.hasOwnProperty(hash)) {\n        var value = caStore.certs[hash];\n        if(!forge.util.isArray(value)) {\n          certList.push(value);\n        } else {\n          for(var i = 0; i < value.length; ++i) {\n            certList.push(value[i]);\n          }\n        }\n      }\n    }\n\n    return certList;\n  };\n\n  /**\n   * Removes a certificate from the store.\n   *\n   * @param cert the certificate to remove (either a pki.certificate or a\n   *          PEM-formatted certificate).\n   *\n   * @return the certificate that was removed or null if the certificate\n   *           wasn't in store.\n   */\n  caStore.removeCertificate = function(cert) {\n    var result;\n\n    // convert from pem if necessary\n    if(typeof cert === 'string') {\n      cert = forge.pki.certificateFromPem(cert);\n    }\n    ensureSubjectHasHash(cert.subject);\n    if(!caStore.hasCertificate(cert)) {\n      return null;\n    }\n\n    var match = getBySubject(cert.subject);\n\n    if(!forge.util.isArray(match)) {\n      result = caStore.certs[cert.subject.hash];\n      delete caStore.certs[cert.subject.hash];\n      return result;\n    }\n\n    // compare DER-encoding of certificates\n    var der1 = asn1.toDer(pki.certificateToAsn1(cert)).getBytes();\n    for(var i = 0; i < match.length; ++i) {\n      var der2 = asn1.toDer(pki.certificateToAsn1(match[i])).getBytes();\n      if(der1 === der2) {\n        result = match[i];\n        match.splice(i, 1);\n      }\n    }\n    if(match.length === 0) {\n      delete caStore.certs[cert.subject.hash];\n    }\n\n    return result;\n  };\n\n  function getBySubject(subject) {\n    ensureSubjectHasHash(subject);\n    return caStore.certs[subject.hash] || null;\n  }\n\n  function ensureSubjectHasHash(subject) {\n    // produce subject hash if it doesn't exist\n    if(!subject.hash) {\n      var md = forge.md.sha1.create();\n      subject.attributes = pki.RDNAttributesAsArray(_dnToAsn1(subject), md);\n      subject.hash = md.digest().toHex();\n    }\n  }\n\n  // auto-add passed in certs\n  if(certs) {\n    // parse PEM-formatted certificates as necessary\n    for(var i = 0; i < certs.length; ++i) {\n      var cert = certs[i];\n      caStore.addCertificate(cert);\n    }\n  }\n\n  return caStore;\n};\n\n/**\n * Certificate verification errors, based on TLS.\n */\npki.certificateError = {\n  bad_certificate: 'forge.pki.BadCertificate',\n  unsupported_certificate: 'forge.pki.UnsupportedCertificate',\n  certificate_revoked: 'forge.pki.CertificateRevoked',\n  certificate_expired: 'forge.pki.CertificateExpired',\n  certificate_unknown: 'forge.pki.CertificateUnknown',\n  unknown_ca: 'forge.pki.UnknownCertificateAuthority'\n};\n\n/**\n * Verifies a certificate chain against the given Certificate Authority store\n * with an optional custom verify callback.\n *\n * @param caStore a certificate store to verify against.\n * @param chain the certificate chain to verify, with the root or highest\n *          authority at the end (an array of certificates).\n * @param options a callback to be called for every certificate in the chain or\n *                  an object with:\n *                  verify a callback to be called for every certificate in the\n *                    chain\n *                  validityCheckDate the date against which the certificate\n *                    validity period should be checked. Pass null to not check\n *                    the validity period. By default, the current date is used.\n *\n * The verify callback has the following signature:\n *\n * verified - Set to true if certificate was verified, otherwise the\n *   pki.certificateError for why the certificate failed.\n * depth - The current index in the chain, where 0 is the end point's cert.\n * certs - The certificate chain, *NOTE* an empty chain indicates an anonymous\n *   end point.\n *\n * The function returns true on success and on failure either the appropriate\n * pki.certificateError or an object with 'error' set to the appropriate\n * pki.certificateError and 'message' set to a custom error message.\n *\n * @return true if successful, error thrown if not.\n */\npki.verifyCertificateChain = function(caStore, chain, options) {\n  /* From: RFC3280 - Internet X.509 Public Key Infrastructure Certificate\n    Section 6: Certification Path Validation\n    See inline parentheticals related to this particular implementation.\n\n    The primary goal of path validation is to verify the binding between\n    a subject distinguished name or a subject alternative name and subject\n    public key, as represented in the end entity certificate, based on the\n    public key of the trust anchor. This requires obtaining a sequence of\n    certificates that support that binding. That sequence should be provided\n    in the passed 'chain'. The trust anchor should be in the given CA\n    store. The 'end entity' certificate is the certificate provided by the\n    end point (typically a server) and is the first in the chain.\n\n    To meet this goal, the path validation process verifies, among other\n    things, that a prospective certification path (a sequence of n\n    certificates or a 'chain') satisfies the following conditions:\n\n    (a) for all x in {1, ..., n-1}, the subject of certificate x is\n          the issuer of certificate x+1;\n\n    (b) certificate 1 is issued by the trust anchor;\n\n    (c) certificate n is the certificate to be validated; and\n\n    (d) for all x in {1, ..., n}, the certificate was valid at the\n          time in question.\n\n    Note that here 'n' is index 0 in the chain and 1 is the last certificate\n    in the chain and it must be signed by a certificate in the connection's\n    CA store.\n\n    The path validation process also determines the set of certificate\n    policies that are valid for this path, based on the certificate policies\n    extension, policy mapping extension, policy constraints extension, and\n    inhibit any-policy extension.\n\n    Note: Policy mapping extension not supported (Not Required).\n\n    Note: If the certificate has an unsupported critical extension, then it\n    must be rejected.\n\n    Note: A certificate is self-issued if the DNs that appear in the subject\n    and issuer fields are identical and are not empty.\n\n    The path validation algorithm assumes the following seven inputs are\n    provided to the path processing logic. What this specific implementation\n    will use is provided parenthetically:\n\n    (a) a prospective certification path of length n (the 'chain')\n    (b) the current date/time: ('now').\n    (c) user-initial-policy-set: A set of certificate policy identifiers\n          naming the policies that are acceptable to the certificate user.\n          The user-initial-policy-set contains the special value any-policy\n          if the user is not concerned about certificate policy\n          (Not implemented. Any policy is accepted).\n    (d) trust anchor information, describing a CA that serves as a trust\n          anchor for the certification path. The trust anchor information\n          includes:\n\n      (1)  the trusted issuer name,\n      (2)  the trusted public key algorithm,\n      (3)  the trusted public key, and\n      (4)  optionally, the trusted public key parameters associated\n             with the public key.\n\n      (Trust anchors are provided via certificates in the CA store).\n\n      The trust anchor information may be provided to the path processing\n      procedure in the form of a self-signed certificate. The trusted anchor\n      information is trusted because it was delivered to the path processing\n      procedure by some trustworthy out-of-band procedure. If the trusted\n      public key algorithm requires parameters, then the parameters are\n      provided along with the trusted public key (No parameters used in this\n      implementation).\n\n    (e) initial-policy-mapping-inhibit, which indicates if policy mapping is\n          allowed in the certification path.\n          (Not implemented, no policy checking)\n\n    (f) initial-explicit-policy, which indicates if the path must be valid\n          for at least one of the certificate policies in the user-initial-\n          policy-set.\n          (Not implemented, no policy checking)\n\n    (g) initial-any-policy-inhibit, which indicates whether the\n          anyPolicy OID should be processed if it is included in a\n          certificate.\n          (Not implemented, so any policy is valid provided that it is\n          not marked as critical) */\n\n  /* Basic Path Processing:\n\n    For each certificate in the 'chain', the following is checked:\n\n    1. The certificate validity period includes the current time.\n    2. The certificate was signed by its parent (where the parent is either\n       the next in the chain or from the CA store). Allow processing to\n       continue to the next step if no parent is found but the certificate is\n       in the CA store.\n    3. TODO: The certificate has not been revoked.\n    4. The certificate issuer name matches the parent's subject name.\n    5. TODO: If the certificate is self-issued and not the final certificate\n       in the chain, skip this step, otherwise verify that the subject name\n       is within one of the permitted subtrees of X.500 distinguished names\n       and that each of the alternative names in the subjectAltName extension\n       (critical or non-critical) is within one of the permitted subtrees for\n       that name type.\n    6. TODO: If the certificate is self-issued and not the final certificate\n       in the chain, skip this step, otherwise verify that the subject name\n       is not within one of the excluded subtrees for X.500 distinguished\n       names and none of the subjectAltName extension names are excluded for\n       that name type.\n    7. The other steps in the algorithm for basic path processing involve\n       handling the policy extension which is not presently supported in this\n       implementation. Instead, if a critical policy extension is found, the\n       certificate is rejected as not supported.\n    8. If the certificate is not the first or if its the only certificate in\n       the chain (having no parent from the CA store or is self-signed) and it\n       has a critical key usage extension, verify that the keyCertSign bit is\n       set. If the key usage extension exists, verify that the basic\n       constraints extension exists. If the basic constraints extension exists,\n       verify that the cA flag is set. If pathLenConstraint is set, ensure that\n       the number of certificates that precede in the chain (come earlier\n       in the chain as implemented below), excluding the very first in the\n       chain (typically the end-entity one), isn't greater than the\n       pathLenConstraint. This constraint limits the number of intermediate\n       CAs that may appear below a CA before only end-entity certificates\n       may be issued. */\n\n  // if a verify callback is passed as the third parameter, package it within\n  // the options object. This is to support a legacy function signature that\n  // expected the verify callback as the third parameter.\n  if(typeof options === 'function') {\n    options = {verify: options};\n  }\n  options = options || {};\n\n  // copy cert chain references to another array to protect against changes\n  // in verify callback\n  chain = chain.slice(0);\n  var certs = chain.slice(0);\n\n  var validityCheckDate = options.validityCheckDate;\n  // if no validityCheckDate is specified, default to the current date. Make\n  // sure to maintain the value null because it indicates that the validity\n  // period should not be checked.\n  if(typeof validityCheckDate === 'undefined') {\n    validityCheckDate = new Date();\n  }\n\n  // verify each cert in the chain using its parent, where the parent\n  // is either the next in the chain or from the CA store\n  var first = true;\n  var error = null;\n  var depth = 0;\n  do {\n    var cert = chain.shift();\n    var parent = null;\n    var selfSigned = false;\n\n    if(validityCheckDate) {\n      // 1. check valid time\n      if(validityCheckDate < cert.validity.notBefore ||\n         validityCheckDate > cert.validity.notAfter) {\n        error = {\n          message: 'Certificate is not valid yet or has expired.',\n          error: pki.certificateError.certificate_expired,\n          notBefore: cert.validity.notBefore,\n          notAfter: cert.validity.notAfter,\n          // TODO: we might want to reconsider renaming 'now' to\n          // 'validityCheckDate' should this API be changed in the future.\n          now: validityCheckDate\n        };\n      }\n    }\n\n    // 2. verify with parent from chain or CA store\n    if(error === null) {\n      parent = chain[0] || caStore.getIssuer(cert);\n      if(parent === null) {\n        // check for self-signed cert\n        if(cert.isIssuer(cert)) {\n          selfSigned = true;\n          parent = cert;\n        }\n      }\n\n      if(parent) {\n        // FIXME: current CA store implementation might have multiple\n        // certificates where the issuer can't be determined from the\n        // certificate (happens rarely with, eg: old certificates) so normalize\n        // by always putting parents into an array\n        // TODO: there's may be an extreme degenerate case currently uncovered\n        // where an old intermediate certificate seems to have a matching parent\n        // but none of the parents actually verify ... but the intermediate\n        // is in the CA and it should pass this check; needs investigation\n        var parents = parent;\n        if(!forge.util.isArray(parents)) {\n          parents = [parents];\n        }\n\n        // try to verify with each possible parent (typically only one)\n        var verified = false;\n        while(!verified && parents.length > 0) {\n          parent = parents.shift();\n          try {\n            verified = parent.verify(cert);\n          } catch(ex) {\n            // failure to verify, don't care why, try next one\n          }\n        }\n\n        if(!verified) {\n          error = {\n            message: 'Certificate signature is invalid.',\n            error: pki.certificateError.bad_certificate\n          };\n        }\n      }\n\n      if(error === null && (!parent || selfSigned) &&\n        !caStore.hasCertificate(cert)) {\n        // no parent issuer and certificate itself is not trusted\n        error = {\n          message: 'Certificate is not trusted.',\n          error: pki.certificateError.unknown_ca\n        };\n      }\n    }\n\n    // TODO: 3. check revoked\n\n    // 4. check for matching issuer/subject\n    if(error === null && parent && !cert.isIssuer(parent)) {\n      // parent is not issuer\n      error = {\n        message: 'Certificate issuer is invalid.',\n        error: pki.certificateError.bad_certificate\n      };\n    }\n\n    // 5. TODO: check names with permitted names tree\n\n    // 6. TODO: check names against excluded names tree\n\n    // 7. check for unsupported critical extensions\n    if(error === null) {\n      // supported extensions\n      var se = {\n        keyUsage: true,\n        basicConstraints: true\n      };\n      for(var i = 0; error === null && i < cert.extensions.length; ++i) {\n        var ext = cert.extensions[i];\n        if(ext.critical && !(ext.name in se)) {\n          error = {\n            message:\n              'Certificate has an unsupported critical extension.',\n            error: pki.certificateError.unsupported_certificate\n          };\n        }\n      }\n    }\n\n    // 8. check for CA if cert is not first or is the only certificate\n    // remaining in chain with no parent or is self-signed\n    if(error === null &&\n      (!first || (chain.length === 0 && (!parent || selfSigned)))) {\n      // first check keyUsage extension and then basic constraints\n      var bcExt = cert.getExtension('basicConstraints');\n      var keyUsageExt = cert.getExtension('keyUsage');\n      if(keyUsageExt !== null) {\n        // keyCertSign must be true and there must be a basic\n        // constraints extension\n        if(!keyUsageExt.keyCertSign || bcExt === null) {\n          // bad certificate\n          error = {\n            message:\n              'Certificate keyUsage or basicConstraints conflict ' +\n              'or indicate that the certificate is not a CA. ' +\n              'If the certificate is the only one in the chain or ' +\n              'isn\\'t the first then the certificate must be a ' +\n              'valid CA.',\n            error: pki.certificateError.bad_certificate\n          };\n        }\n      }\n      // basic constraints cA flag must be set\n      if(error === null && bcExt !== null && !bcExt.cA) {\n        // bad certificate\n        error = {\n          message:\n            'Certificate basicConstraints indicates the certificate ' +\n            'is not a CA.',\n          error: pki.certificateError.bad_certificate\n        };\n      }\n      // if error is not null and keyUsage is available, then we know it\n      // has keyCertSign and there is a basic constraints extension too,\n      // which means we can check pathLenConstraint (if it exists)\n      if(error === null && keyUsageExt !== null &&\n        'pathLenConstraint' in bcExt) {\n        // pathLen is the maximum # of intermediate CA certs that can be\n        // found between the current certificate and the end-entity (depth 0)\n        // certificate; this number does not include the end-entity (depth 0,\n        // last in the chain) even if it happens to be a CA certificate itself\n        var pathLen = depth - 1;\n        if(pathLen > bcExt.pathLenConstraint) {\n          // pathLenConstraint violated, bad certificate\n          error = {\n            message:\n              'Certificate basicConstraints pathLenConstraint violated.',\n            error: pki.certificateError.bad_certificate\n          };\n        }\n      }\n    }\n\n    // call application callback\n    var vfd = (error === null) ? true : error.error;\n    var ret = options.verify ? options.verify(vfd, depth, certs) : vfd;\n    if(ret === true) {\n      // clear any set error\n      error = null;\n    } else {\n      // if passed basic tests, set default message and alert\n      if(vfd === true) {\n        error = {\n          message: 'The application rejected the certificate.',\n          error: pki.certificateError.bad_certificate\n        };\n      }\n\n      // check for custom error info\n      if(ret || ret === 0) {\n        // set custom message and error\n        if(typeof ret === 'object' && !forge.util.isArray(ret)) {\n          if(ret.message) {\n            error.message = ret.message;\n          }\n          if(ret.error) {\n            error.error = ret.error;\n          }\n        } else if(typeof ret === 'string') {\n          // set custom error\n          error.error = ret;\n        }\n      }\n\n      // throw error\n      throw error;\n    }\n\n    // no longer first cert in chain\n    first = false;\n    ++depth;\n  } while(chain.length > 0);\n\n  return true;\n};\n","/**\n * Utility functions for web applications.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2010-2018 Digital Bazaar, Inc.\n */\nvar forge = require('./forge');\nvar baseN = require('./baseN');\n\n/* Utilities API */\nvar util = module.exports = forge.util = forge.util || {};\n\n// define setImmediate and nextTick\n(function() {\n  // use native nextTick (unless we're in webpack)\n  // webpack (or better node-libs-browser polyfill) sets process.browser.\n  // this way we can detect webpack properly\n  if(typeof process !== 'undefined' && process.nextTick && !process.browser) {\n    util.nextTick = process.nextTick;\n    if(typeof setImmediate === 'function') {\n      util.setImmediate = setImmediate;\n    } else {\n      // polyfill setImmediate with nextTick, older versions of node\n      // (those w/o setImmediate) won't totally starve IO\n      util.setImmediate = util.nextTick;\n    }\n    return;\n  }\n\n  // polyfill nextTick with native setImmediate\n  if(typeof setImmediate === 'function') {\n    util.setImmediate = function() { return setImmediate.apply(undefined, arguments); };\n    util.nextTick = function(callback) {\n      return setImmediate(callback);\n    };\n    return;\n  }\n\n  /* Note: A polyfill upgrade pattern is used here to allow combining\n  polyfills. For example, MutationObserver is fast, but blocks UI updates,\n  so it needs to allow UI updates periodically, so it falls back on\n  postMessage or setTimeout. */\n\n  // polyfill with setTimeout\n  util.setImmediate = function(callback) {\n    setTimeout(callback, 0);\n  };\n\n  // upgrade polyfill to use postMessage\n  if(typeof window !== 'undefined' &&\n    typeof window.postMessage === 'function') {\n    var msg = 'forge.setImmediate';\n    var callbacks = [];\n    util.setImmediate = function(callback) {\n      callbacks.push(callback);\n      // only send message when one hasn't been sent in\n      // the current turn of the event loop\n      if(callbacks.length === 1) {\n        window.postMessage(msg, '*');\n      }\n    };\n    function handler(event) {\n      if(event.source === window && event.data === msg) {\n        event.stopPropagation();\n        var copy = callbacks.slice();\n        callbacks.length = 0;\n        copy.forEach(function(callback) {\n          callback();\n        });\n      }\n    }\n    window.addEventListener('message', handler, true);\n  }\n\n  // upgrade polyfill to use MutationObserver\n  if(typeof MutationObserver !== 'undefined') {\n    // polyfill with MutationObserver\n    var now = Date.now();\n    var attr = true;\n    var div = document.createElement('div');\n    var callbacks = [];\n    new MutationObserver(function() {\n      var copy = callbacks.slice();\n      callbacks.length = 0;\n      copy.forEach(function(callback) {\n        callback();\n      });\n    }).observe(div, {attributes: true});\n    var oldSetImmediate = util.setImmediate;\n    util.setImmediate = function(callback) {\n      if(Date.now() - now > 15) {\n        now = Date.now();\n        oldSetImmediate(callback);\n      } else {\n        callbacks.push(callback);\n        // only trigger observer when it hasn't been triggered in\n        // the current turn of the event loop\n        if(callbacks.length === 1) {\n          div.setAttribute('a', attr = !attr);\n        }\n      }\n    };\n  }\n\n  util.nextTick = util.setImmediate;\n})();\n\n// check if running under Node.js\nutil.isNodejs =\n  typeof process !== 'undefined' && process.versions && process.versions.node;\n\n\n// 'self' will also work in Web Workers (instance of WorkerGlobalScope) while\n// it will point to `window` in the main thread.\n// To remain compatible with older browsers, we fall back to 'window' if 'self'\n// is not available.\nutil.globalScope = (function() {\n  if(util.isNodejs) {\n    return global;\n  }\n\n  return typeof self === 'undefined' ? window : self;\n})();\n\n// define isArray\nutil.isArray = Array.isArray || function(x) {\n  return Object.prototype.toString.call(x) === '[object Array]';\n};\n\n// define isArrayBuffer\nutil.isArrayBuffer = function(x) {\n  return typeof ArrayBuffer !== 'undefined' && x instanceof ArrayBuffer;\n};\n\n// define isArrayBufferView\nutil.isArrayBufferView = function(x) {\n  return x && util.isArrayBuffer(x.buffer) && x.byteLength !== undefined;\n};\n\n/**\n * Ensure a bits param is 8, 16, 24, or 32. Used to validate input for\n * algorithms where bit manipulation, JavaScript limitations, and/or algorithm\n * design only allow for byte operations of a limited size.\n *\n * @param n number of bits.\n *\n * Throw Error if n invalid.\n */\nfunction _checkBitsParam(n) {\n  if(!(n === 8 || n === 16 || n === 24 || n === 32)) {\n    throw new Error('Only 8, 16, 24, or 32 bits supported: ' + n);\n  }\n}\n\n// TODO: set ByteBuffer to best available backing\nutil.ByteBuffer = ByteStringBuffer;\n\n/** Buffer w/BinaryString backing */\n\n/**\n * Constructor for a binary string backed byte buffer.\n *\n * @param [b] the bytes to wrap (either encoded as string, one byte per\n *          character, or as an ArrayBuffer or Typed Array).\n */\nfunction ByteStringBuffer(b) {\n  // TODO: update to match DataBuffer API\n\n  // the data in this buffer\n  this.data = '';\n  // the pointer for reading from this buffer\n  this.read = 0;\n\n  if(typeof b === 'string') {\n    this.data = b;\n  } else if(util.isArrayBuffer(b) || util.isArrayBufferView(b)) {\n    if(typeof Buffer !== 'undefined' && b instanceof Buffer) {\n      this.data = b.toString('binary');\n    } else {\n      // convert native buffer to forge buffer\n      // FIXME: support native buffers internally instead\n      var arr = new Uint8Array(b);\n      try {\n        this.data = String.fromCharCode.apply(null, arr);\n      } catch(e) {\n        for(var i = 0; i < arr.length; ++i) {\n          this.putByte(arr[i]);\n        }\n      }\n    }\n  } else if(b instanceof ByteStringBuffer ||\n    (typeof b === 'object' && typeof b.data === 'string' &&\n    typeof b.read === 'number')) {\n    // copy existing buffer\n    this.data = b.data;\n    this.read = b.read;\n  }\n\n  // used for v8 optimization\n  this._constructedStringLength = 0;\n}\nutil.ByteStringBuffer = ByteStringBuffer;\n\n/* Note: This is an optimization for V8-based browsers. When V8 concatenates\n  a string, the strings are only joined logically using a \"cons string\" or\n  \"constructed/concatenated string\". These containers keep references to one\n  another and can result in very large memory usage. For example, if a 2MB\n  string is constructed by concatenating 4 bytes together at a time, the\n  memory usage will be ~44MB; so ~22x increase. The strings are only joined\n  together when an operation requiring their joining takes place, such as\n  substr(). This function is called when adding data to this buffer to ensure\n  these types of strings are periodically joined to reduce the memory\n  footprint. */\nvar _MAX_CONSTRUCTED_STRING_LENGTH = 4096;\nutil.ByteStringBuffer.prototype._optimizeConstructedString = function(x) {\n  this._constructedStringLength += x;\n  if(this._constructedStringLength > _MAX_CONSTRUCTED_STRING_LENGTH) {\n    // this substr() should cause the constructed string to join\n    this.data.substr(0, 1);\n    this._constructedStringLength = 0;\n  }\n};\n\n/**\n * Gets the number of bytes in this buffer.\n *\n * @return the number of bytes in this buffer.\n */\nutil.ByteStringBuffer.prototype.length = function() {\n  return this.data.length - this.read;\n};\n\n/**\n * Gets whether or not this buffer is empty.\n *\n * @return true if this buffer is empty, false if not.\n */\nutil.ByteStringBuffer.prototype.isEmpty = function() {\n  return this.length() <= 0;\n};\n\n/**\n * Puts a byte in this buffer.\n *\n * @param b the byte to put.\n *\n * @return this buffer.\n */\nutil.ByteStringBuffer.prototype.putByte = function(b) {\n  return this.putBytes(String.fromCharCode(b));\n};\n\n/**\n * Puts a byte in this buffer N times.\n *\n * @param b the byte to put.\n * @param n the number of bytes of value b to put.\n *\n * @return this buffer.\n */\nutil.ByteStringBuffer.prototype.fillWithByte = function(b, n) {\n  b = String.fromCharCode(b);\n  var d = this.data;\n  while(n > 0) {\n    if(n & 1) {\n      d += b;\n    }\n    n >>>= 1;\n    if(n > 0) {\n      b += b;\n    }\n  }\n  this.data = d;\n  this._optimizeConstructedString(n);\n  return this;\n};\n\n/**\n * Puts bytes in this buffer.\n *\n * @param bytes the bytes (as a binary encoded string) to put.\n *\n * @return this buffer.\n */\nutil.ByteStringBuffer.prototype.putBytes = function(bytes) {\n  this.data += bytes;\n  this._optimizeConstructedString(bytes.length);\n  return this;\n};\n\n/**\n * Puts a UTF-16 encoded string into this buffer.\n *\n * @param str the string to put.\n *\n * @return this buffer.\n */\nutil.ByteStringBuffer.prototype.putString = function(str) {\n  return this.putBytes(util.encodeUtf8(str));\n};\n\n/**\n * Puts a 16-bit integer in this buffer in big-endian order.\n *\n * @param i the 16-bit integer.\n *\n * @return this buffer.\n */\nutil.ByteStringBuffer.prototype.putInt16 = function(i) {\n  return this.putBytes(\n    String.fromCharCode(i >> 8 & 0xFF) +\n    String.fromCharCode(i & 0xFF));\n};\n\n/**\n * Puts a 24-bit integer in this buffer in big-endian order.\n *\n * @param i the 24-bit integer.\n *\n * @return this buffer.\n */\nutil.ByteStringBuffer.prototype.putInt24 = function(i) {\n  return this.putBytes(\n    String.fromCharCode(i >> 16 & 0xFF) +\n    String.fromCharCode(i >> 8 & 0xFF) +\n    String.fromCharCode(i & 0xFF));\n};\n\n/**\n * Puts a 32-bit integer in this buffer in big-endian order.\n *\n * @param i the 32-bit integer.\n *\n * @return this buffer.\n */\nutil.ByteStringBuffer.prototype.putInt32 = function(i) {\n  return this.putBytes(\n    String.fromCharCode(i >> 24 & 0xFF) +\n    String.fromCharCode(i >> 16 & 0xFF) +\n    String.fromCharCode(i >> 8 & 0xFF) +\n    String.fromCharCode(i & 0xFF));\n};\n\n/**\n * Puts a 16-bit integer in this buffer in little-endian order.\n *\n * @param i the 16-bit integer.\n *\n * @return this buffer.\n */\nutil.ByteStringBuffer.prototype.putInt16Le = function(i) {\n  return this.putBytes(\n    String.fromCharCode(i & 0xFF) +\n    String.fromCharCode(i >> 8 & 0xFF));\n};\n\n/**\n * Puts a 24-bit integer in this buffer in little-endian order.\n *\n * @param i the 24-bit integer.\n *\n * @return this buffer.\n */\nutil.ByteStringBuffer.prototype.putInt24Le = function(i) {\n  return this.putBytes(\n    String.fromCharCode(i & 0xFF) +\n    String.fromCharCode(i >> 8 & 0xFF) +\n    String.fromCharCode(i >> 16 & 0xFF));\n};\n\n/**\n * Puts a 32-bit integer in this buffer in little-endian order.\n *\n * @param i the 32-bit integer.\n *\n * @return this buffer.\n */\nutil.ByteStringBuffer.prototype.putInt32Le = function(i) {\n  return this.putBytes(\n    String.fromCharCode(i & 0xFF) +\n    String.fromCharCode(i >> 8 & 0xFF) +\n    String.fromCharCode(i >> 16 & 0xFF) +\n    String.fromCharCode(i >> 24 & 0xFF));\n};\n\n/**\n * Puts an n-bit integer in this buffer in big-endian order.\n *\n * @param i the n-bit integer.\n * @param n the number of bits in the integer (8, 16, 24, or 32).\n *\n * @return this buffer.\n */\nutil.ByteStringBuffer.prototype.putInt = function(i, n) {\n  _checkBitsParam(n);\n  var bytes = '';\n  do {\n    n -= 8;\n    bytes += String.fromCharCode((i >> n) & 0xFF);\n  } while(n > 0);\n  return this.putBytes(bytes);\n};\n\n/**\n * Puts a signed n-bit integer in this buffer in big-endian order. Two's\n * complement representation is used.\n *\n * @param i the n-bit integer.\n * @param n the number of bits in the integer (8, 16, 24, or 32).\n *\n * @return this buffer.\n */\nutil.ByteStringBuffer.prototype.putSignedInt = function(i, n) {\n  // putInt checks n\n  if(i < 0) {\n    i += 2 << (n - 1);\n  }\n  return this.putInt(i, n);\n};\n\n/**\n * Puts the given buffer into this buffer.\n *\n * @param buffer the buffer to put into this one.\n *\n * @return this buffer.\n */\nutil.ByteStringBuffer.prototype.putBuffer = function(buffer) {\n  return this.putBytes(buffer.getBytes());\n};\n\n/**\n * Gets a byte from this buffer and advances the read pointer by 1.\n *\n * @return the byte.\n */\nutil.ByteStringBuffer.prototype.getByte = function() {\n  return this.data.charCodeAt(this.read++);\n};\n\n/**\n * Gets a uint16 from this buffer in big-endian order and advances the read\n * pointer by 2.\n *\n * @return the uint16.\n */\nutil.ByteStringBuffer.prototype.getInt16 = function() {\n  var rval = (\n    this.data.charCodeAt(this.read) << 8 ^\n    this.data.charCodeAt(this.read + 1));\n  this.read += 2;\n  return rval;\n};\n\n/**\n * Gets a uint24 from this buffer in big-endian order and advances the read\n * pointer by 3.\n *\n * @return the uint24.\n */\nutil.ByteStringBuffer.prototype.getInt24 = function() {\n  var rval = (\n    this.data.charCodeAt(this.read) << 16 ^\n    this.data.charCodeAt(this.read + 1) << 8 ^\n    this.data.charCodeAt(this.read + 2));\n  this.read += 3;\n  return rval;\n};\n\n/**\n * Gets a uint32 from this buffer in big-endian order and advances the read\n * pointer by 4.\n *\n * @return the word.\n */\nutil.ByteStringBuffer.prototype.getInt32 = function() {\n  var rval = (\n    this.data.charCodeAt(this.read) << 24 ^\n    this.data.charCodeAt(this.read + 1) << 16 ^\n    this.data.charCodeAt(this.read + 2) << 8 ^\n    this.data.charCodeAt(this.read + 3));\n  this.read += 4;\n  return rval;\n};\n\n/**\n * Gets a uint16 from this buffer in little-endian order and advances the read\n * pointer by 2.\n *\n * @return the uint16.\n */\nutil.ByteStringBuffer.prototype.getInt16Le = function() {\n  var rval = (\n    this.data.charCodeAt(this.read) ^\n    this.data.charCodeAt(this.read + 1) << 8);\n  this.read += 2;\n  return rval;\n};\n\n/**\n * Gets a uint24 from this buffer in little-endian order and advances the read\n * pointer by 3.\n *\n * @return the uint24.\n */\nutil.ByteStringBuffer.prototype.getInt24Le = function() {\n  var rval = (\n    this.data.charCodeAt(this.read) ^\n    this.data.charCodeAt(this.read + 1) << 8 ^\n    this.data.charCodeAt(this.read + 2) << 16);\n  this.read += 3;\n  return rval;\n};\n\n/**\n * Gets a uint32 from this buffer in little-endian order and advances the read\n * pointer by 4.\n *\n * @return the word.\n */\nutil.ByteStringBuffer.prototype.getInt32Le = function() {\n  var rval = (\n    this.data.charCodeAt(this.read) ^\n    this.data.charCodeAt(this.read + 1) << 8 ^\n    this.data.charCodeAt(this.read + 2) << 16 ^\n    this.data.charCodeAt(this.read + 3) << 24);\n  this.read += 4;\n  return rval;\n};\n\n/**\n * Gets an n-bit integer from this buffer in big-endian order and advances the\n * read pointer by ceil(n/8).\n *\n * @param n the number of bits in the integer (8, 16, 24, or 32).\n *\n * @return the integer.\n */\nutil.ByteStringBuffer.prototype.getInt = function(n) {\n  _checkBitsParam(n);\n  var rval = 0;\n  do {\n    // TODO: Use (rval * 0x100) if adding support for 33 to 53 bits.\n    rval = (rval << 8) + this.data.charCodeAt(this.read++);\n    n -= 8;\n  } while(n > 0);\n  return rval;\n};\n\n/**\n * Gets a signed n-bit integer from this buffer in big-endian order, using\n * two's complement, and advances the read pointer by n/8.\n *\n * @param n the number of bits in the integer (8, 16, 24, or 32).\n *\n * @return the integer.\n */\nutil.ByteStringBuffer.prototype.getSignedInt = function(n) {\n  // getInt checks n\n  var x = this.getInt(n);\n  var max = 2 << (n - 2);\n  if(x >= max) {\n    x -= max << 1;\n  }\n  return x;\n};\n\n/**\n * Reads bytes out as a binary encoded string and clears them from the\n * buffer. Note that the resulting string is binary encoded (in node.js this\n * encoding is referred to as `binary`, it is *not* `utf8`).\n *\n * @param count the number of bytes to read, undefined or null for all.\n *\n * @return a binary encoded string of bytes.\n */\nutil.ByteStringBuffer.prototype.getBytes = function(count) {\n  var rval;\n  if(count) {\n    // read count bytes\n    count = Math.min(this.length(), count);\n    rval = this.data.slice(this.read, this.read + count);\n    this.read += count;\n  } else if(count === 0) {\n    rval = '';\n  } else {\n    // read all bytes, optimize to only copy when needed\n    rval = (this.read === 0) ? this.data : this.data.slice(this.read);\n    this.clear();\n  }\n  return rval;\n};\n\n/**\n * Gets a binary encoded string of the bytes from this buffer without\n * modifying the read pointer.\n *\n * @param count the number of bytes to get, omit to get all.\n *\n * @return a string full of binary encoded characters.\n */\nutil.ByteStringBuffer.prototype.bytes = function(count) {\n  return (typeof(count) === 'undefined' ?\n    this.data.slice(this.read) :\n    this.data.slice(this.read, this.read + count));\n};\n\n/**\n * Gets a byte at the given index without modifying the read pointer.\n *\n * @param i the byte index.\n *\n * @return the byte.\n */\nutil.ByteStringBuffer.prototype.at = function(i) {\n  return this.data.charCodeAt(this.read + i);\n};\n\n/**\n * Puts a byte at the given index without modifying the read pointer.\n *\n * @param i the byte index.\n * @param b the byte to put.\n *\n * @return this buffer.\n */\nutil.ByteStringBuffer.prototype.setAt = function(i, b) {\n  this.data = this.data.substr(0, this.read + i) +\n    String.fromCharCode(b) +\n    this.data.substr(this.read + i + 1);\n  return this;\n};\n\n/**\n * Gets the last byte without modifying the read pointer.\n *\n * @return the last byte.\n */\nutil.ByteStringBuffer.prototype.last = function() {\n  return this.data.charCodeAt(this.data.length - 1);\n};\n\n/**\n * Creates a copy of this buffer.\n *\n * @return the copy.\n */\nutil.ByteStringBuffer.prototype.copy = function() {\n  var c = util.createBuffer(this.data);\n  c.read = this.read;\n  return c;\n};\n\n/**\n * Compacts this buffer.\n *\n * @return this buffer.\n */\nutil.ByteStringBuffer.prototype.compact = function() {\n  if(this.read > 0) {\n    this.data = this.data.slice(this.read);\n    this.read = 0;\n  }\n  return this;\n};\n\n/**\n * Clears this buffer.\n *\n * @return this buffer.\n */\nutil.ByteStringBuffer.prototype.clear = function() {\n  this.data = '';\n  this.read = 0;\n  return this;\n};\n\n/**\n * Shortens this buffer by triming bytes off of the end of this buffer.\n *\n * @param count the number of bytes to trim off.\n *\n * @return this buffer.\n */\nutil.ByteStringBuffer.prototype.truncate = function(count) {\n  var len = Math.max(0, this.length() - count);\n  this.data = this.data.substr(this.read, len);\n  this.read = 0;\n  return this;\n};\n\n/**\n * Converts this buffer to a hexadecimal string.\n *\n * @return a hexadecimal string.\n */\nutil.ByteStringBuffer.prototype.toHex = function() {\n  var rval = '';\n  for(var i = this.read; i < this.data.length; ++i) {\n    var b = this.data.charCodeAt(i);\n    if(b < 16) {\n      rval += '0';\n    }\n    rval += b.toString(16);\n  }\n  return rval;\n};\n\n/**\n * Converts this buffer to a UTF-16 string (standard JavaScript string).\n *\n * @return a UTF-16 string.\n */\nutil.ByteStringBuffer.prototype.toString = function() {\n  return util.decodeUtf8(this.bytes());\n};\n\n/** End Buffer w/BinaryString backing */\n\n/** Buffer w/UInt8Array backing */\n\n/**\n * FIXME: Experimental. Do not use yet.\n *\n * Constructor for an ArrayBuffer-backed byte buffer.\n *\n * The buffer may be constructed from a string, an ArrayBuffer, DataView, or a\n * TypedArray.\n *\n * If a string is given, its encoding should be provided as an option,\n * otherwise it will default to 'binary'. A 'binary' string is encoded such\n * that each character is one byte in length and size.\n *\n * If an ArrayBuffer, DataView, or TypedArray is given, it will be used\n * *directly* without any copying. Note that, if a write to the buffer requires\n * more space, the buffer will allocate a new backing ArrayBuffer to\n * accommodate. The starting read and write offsets for the buffer may be\n * given as options.\n *\n * @param [b] the initial bytes for this buffer.\n * @param options the options to use:\n *          [readOffset] the starting read offset to use (default: 0).\n *          [writeOffset] the starting write offset to use (default: the\n *            length of the first parameter).\n *          [growSize] the minimum amount, in bytes, to grow the buffer by to\n *            accommodate writes (default: 1024).\n *          [encoding] the encoding ('binary', 'utf8', 'utf16', 'hex') for the\n *            first parameter, if it is a string (default: 'binary').\n */\nfunction DataBuffer(b, options) {\n  // default options\n  options = options || {};\n\n  // pointers for read from/write to buffer\n  this.read = options.readOffset || 0;\n  this.growSize = options.growSize || 1024;\n\n  var isArrayBuffer = util.isArrayBuffer(b);\n  var isArrayBufferView = util.isArrayBufferView(b);\n  if(isArrayBuffer || isArrayBufferView) {\n    // use ArrayBuffer directly\n    if(isArrayBuffer) {\n      this.data = new DataView(b);\n    } else {\n      // TODO: adjust read/write offset based on the type of view\n      // or specify that this must be done in the options ... that the\n      // offsets are byte-based\n      this.data = new DataView(b.buffer, b.byteOffset, b.byteLength);\n    }\n    this.write = ('writeOffset' in options ?\n      options.writeOffset : this.data.byteLength);\n    return;\n  }\n\n  // initialize to empty array buffer and add any given bytes using putBytes\n  this.data = new DataView(new ArrayBuffer(0));\n  this.write = 0;\n\n  if(b !== null && b !== undefined) {\n    this.putBytes(b);\n  }\n\n  if('writeOffset' in options) {\n    this.write = options.writeOffset;\n  }\n}\nutil.DataBuffer = DataBuffer;\n\n/**\n * Gets the number of bytes in this buffer.\n *\n * @return the number of bytes in this buffer.\n */\nutil.DataBuffer.prototype.length = function() {\n  return this.write - this.read;\n};\n\n/**\n * Gets whether or not this buffer is empty.\n *\n * @return true if this buffer is empty, false if not.\n */\nutil.DataBuffer.prototype.isEmpty = function() {\n  return this.length() <= 0;\n};\n\n/**\n * Ensures this buffer has enough empty space to accommodate the given number\n * of bytes. An optional parameter may be given that indicates a minimum\n * amount to grow the buffer if necessary. If the parameter is not given,\n * the buffer will be grown by some previously-specified default amount\n * or heuristic.\n *\n * @param amount the number of bytes to accommodate.\n * @param [growSize] the minimum amount, in bytes, to grow the buffer by if\n *          necessary.\n */\nutil.DataBuffer.prototype.accommodate = function(amount, growSize) {\n  if(this.length() >= amount) {\n    return this;\n  }\n  growSize = Math.max(growSize || this.growSize, amount);\n\n  // grow buffer\n  var src = new Uint8Array(\n    this.data.buffer, this.data.byteOffset, this.data.byteLength);\n  var dst = new Uint8Array(this.length() + growSize);\n  dst.set(src);\n  this.data = new DataView(dst.buffer);\n\n  return this;\n};\n\n/**\n * Puts a byte in this buffer.\n *\n * @param b the byte to put.\n *\n * @return this buffer.\n */\nutil.DataBuffer.prototype.putByte = function(b) {\n  this.accommodate(1);\n  this.data.setUint8(this.write++, b);\n  return this;\n};\n\n/**\n * Puts a byte in this buffer N times.\n *\n * @param b the byte to put.\n * @param n the number of bytes of value b to put.\n *\n * @return this buffer.\n */\nutil.DataBuffer.prototype.fillWithByte = function(b, n) {\n  this.accommodate(n);\n  for(var i = 0; i < n; ++i) {\n    this.data.setUint8(b);\n  }\n  return this;\n};\n\n/**\n * Puts bytes in this buffer. The bytes may be given as a string, an\n * ArrayBuffer, a DataView, or a TypedArray.\n *\n * @param bytes the bytes to put.\n * @param [encoding] the encoding for the first parameter ('binary', 'utf8',\n *          'utf16', 'hex'), if it is a string (default: 'binary').\n *\n * @return this buffer.\n */\nutil.DataBuffer.prototype.putBytes = function(bytes, encoding) {\n  if(util.isArrayBufferView(bytes)) {\n    var src = new Uint8Array(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n    var len = src.byteLength - src.byteOffset;\n    this.accommodate(len);\n    var dst = new Uint8Array(this.data.buffer, this.write);\n    dst.set(src);\n    this.write += len;\n    return this;\n  }\n\n  if(util.isArrayBuffer(bytes)) {\n    var src = new Uint8Array(bytes);\n    this.accommodate(src.byteLength);\n    var dst = new Uint8Array(this.data.buffer);\n    dst.set(src, this.write);\n    this.write += src.byteLength;\n    return this;\n  }\n\n  // bytes is a util.DataBuffer or equivalent\n  if(bytes instanceof util.DataBuffer ||\n    (typeof bytes === 'object' &&\n    typeof bytes.read === 'number' && typeof bytes.write === 'number' &&\n    util.isArrayBufferView(bytes.data))) {\n    var src = new Uint8Array(bytes.data.byteLength, bytes.read, bytes.length());\n    this.accommodate(src.byteLength);\n    var dst = new Uint8Array(bytes.data.byteLength, this.write);\n    dst.set(src);\n    this.write += src.byteLength;\n    return this;\n  }\n\n  if(bytes instanceof util.ByteStringBuffer) {\n    // copy binary string and process as the same as a string parameter below\n    bytes = bytes.data;\n    encoding = 'binary';\n  }\n\n  // string conversion\n  encoding = encoding || 'binary';\n  if(typeof bytes === 'string') {\n    var view;\n\n    // decode from string\n    if(encoding === 'hex') {\n      this.accommodate(Math.ceil(bytes.length / 2));\n      view = new Uint8Array(this.data.buffer, this.write);\n      this.write += util.binary.hex.decode(bytes, view, this.write);\n      return this;\n    }\n    if(encoding === 'base64') {\n      this.accommodate(Math.ceil(bytes.length / 4) * 3);\n      view = new Uint8Array(this.data.buffer, this.write);\n      this.write += util.binary.base64.decode(bytes, view, this.write);\n      return this;\n    }\n\n    // encode text as UTF-8 bytes\n    if(encoding === 'utf8') {\n      // encode as UTF-8 then decode string as raw binary\n      bytes = util.encodeUtf8(bytes);\n      encoding = 'binary';\n    }\n\n    // decode string as raw binary\n    if(encoding === 'binary' || encoding === 'raw') {\n      // one byte per character\n      this.accommodate(bytes.length);\n      view = new Uint8Array(this.data.buffer, this.write);\n      this.write += util.binary.raw.decode(view);\n      return this;\n    }\n\n    // encode text as UTF-16 bytes\n    if(encoding === 'utf16') {\n      // two bytes per character\n      this.accommodate(bytes.length * 2);\n      view = new Uint16Array(this.data.buffer, this.write);\n      this.write += util.text.utf16.encode(view);\n      return this;\n    }\n\n    throw new Error('Invalid encoding: ' + encoding);\n  }\n\n  throw Error('Invalid parameter: ' + bytes);\n};\n\n/**\n * Puts the given buffer into this buffer.\n *\n * @param buffer the buffer to put into this one.\n *\n * @return this buffer.\n */\nutil.DataBuffer.prototype.putBuffer = function(buffer) {\n  this.putBytes(buffer);\n  buffer.clear();\n  return this;\n};\n\n/**\n * Puts a string into this buffer.\n *\n * @param str the string to put.\n * @param [encoding] the encoding for the string (default: 'utf16').\n *\n * @return this buffer.\n */\nutil.DataBuffer.prototype.putString = function(str) {\n  return this.putBytes(str, 'utf16');\n};\n\n/**\n * Puts a 16-bit integer in this buffer in big-endian order.\n *\n * @param i the 16-bit integer.\n *\n * @return this buffer.\n */\nutil.DataBuffer.prototype.putInt16 = function(i) {\n  this.accommodate(2);\n  this.data.setInt16(this.write, i);\n  this.write += 2;\n  return this;\n};\n\n/**\n * Puts a 24-bit integer in this buffer in big-endian order.\n *\n * @param i the 24-bit integer.\n *\n * @return this buffer.\n */\nutil.DataBuffer.prototype.putInt24 = function(i) {\n  this.accommodate(3);\n  this.data.setInt16(this.write, i >> 8 & 0xFFFF);\n  this.data.setInt8(this.write, i >> 16 & 0xFF);\n  this.write += 3;\n  return this;\n};\n\n/**\n * Puts a 32-bit integer in this buffer in big-endian order.\n *\n * @param i the 32-bit integer.\n *\n * @return this buffer.\n */\nutil.DataBuffer.prototype.putInt32 = function(i) {\n  this.accommodate(4);\n  this.data.setInt32(this.write, i);\n  this.write += 4;\n  return this;\n};\n\n/**\n * Puts a 16-bit integer in this buffer in little-endian order.\n *\n * @param i the 16-bit integer.\n *\n * @return this buffer.\n */\nutil.DataBuffer.prototype.putInt16Le = function(i) {\n  this.accommodate(2);\n  this.data.setInt16(this.write, i, true);\n  this.write += 2;\n  return this;\n};\n\n/**\n * Puts a 24-bit integer in this buffer in little-endian order.\n *\n * @param i the 24-bit integer.\n *\n * @return this buffer.\n */\nutil.DataBuffer.prototype.putInt24Le = function(i) {\n  this.accommodate(3);\n  this.data.setInt8(this.write, i >> 16 & 0xFF);\n  this.data.setInt16(this.write, i >> 8 & 0xFFFF, true);\n  this.write += 3;\n  return this;\n};\n\n/**\n * Puts a 32-bit integer in this buffer in little-endian order.\n *\n * @param i the 32-bit integer.\n *\n * @return this buffer.\n */\nutil.DataBuffer.prototype.putInt32Le = function(i) {\n  this.accommodate(4);\n  this.data.setInt32(this.write, i, true);\n  this.write += 4;\n  return this;\n};\n\n/**\n * Puts an n-bit integer in this buffer in big-endian order.\n *\n * @param i the n-bit integer.\n * @param n the number of bits in the integer (8, 16, 24, or 32).\n *\n * @return this buffer.\n */\nutil.DataBuffer.prototype.putInt = function(i, n) {\n  _checkBitsParam(n);\n  this.accommodate(n / 8);\n  do {\n    n -= 8;\n    this.data.setInt8(this.write++, (i >> n) & 0xFF);\n  } while(n > 0);\n  return this;\n};\n\n/**\n * Puts a signed n-bit integer in this buffer in big-endian order. Two's\n * complement representation is used.\n *\n * @param i the n-bit integer.\n * @param n the number of bits in the integer.\n *\n * @return this buffer.\n */\nutil.DataBuffer.prototype.putSignedInt = function(i, n) {\n  _checkBitsParam(n);\n  this.accommodate(n / 8);\n  if(i < 0) {\n    i += 2 << (n - 1);\n  }\n  return this.putInt(i, n);\n};\n\n/**\n * Gets a byte from this buffer and advances the read pointer by 1.\n *\n * @return the byte.\n */\nutil.DataBuffer.prototype.getByte = function() {\n  return this.data.getInt8(this.read++);\n};\n\n/**\n * Gets a uint16 from this buffer in big-endian order and advances the read\n * pointer by 2.\n *\n * @return the uint16.\n */\nutil.DataBuffer.prototype.getInt16 = function() {\n  var rval = this.data.getInt16(this.read);\n  this.read += 2;\n  return rval;\n};\n\n/**\n * Gets a uint24 from this buffer in big-endian order and advances the read\n * pointer by 3.\n *\n * @return the uint24.\n */\nutil.DataBuffer.prototype.getInt24 = function() {\n  var rval = (\n    this.data.getInt16(this.read) << 8 ^\n    this.data.getInt8(this.read + 2));\n  this.read += 3;\n  return rval;\n};\n\n/**\n * Gets a uint32 from this buffer in big-endian order and advances the read\n * pointer by 4.\n *\n * @return the word.\n */\nutil.DataBuffer.prototype.getInt32 = function() {\n  var rval = this.data.getInt32(this.read);\n  this.read += 4;\n  return rval;\n};\n\n/**\n * Gets a uint16 from this buffer in little-endian order and advances the read\n * pointer by 2.\n *\n * @return the uint16.\n */\nutil.DataBuffer.prototype.getInt16Le = function() {\n  var rval = this.data.getInt16(this.read, true);\n  this.read += 2;\n  return rval;\n};\n\n/**\n * Gets a uint24 from this buffer in little-endian order and advances the read\n * pointer by 3.\n *\n * @return the uint24.\n */\nutil.DataBuffer.prototype.getInt24Le = function() {\n  var rval = (\n    this.data.getInt8(this.read) ^\n    this.data.getInt16(this.read + 1, true) << 8);\n  this.read += 3;\n  return rval;\n};\n\n/**\n * Gets a uint32 from this buffer in little-endian order and advances the read\n * pointer by 4.\n *\n * @return the word.\n */\nutil.DataBuffer.prototype.getInt32Le = function() {\n  var rval = this.data.getInt32(this.read, true);\n  this.read += 4;\n  return rval;\n};\n\n/**\n * Gets an n-bit integer from this buffer in big-endian order and advances the\n * read pointer by n/8.\n *\n * @param n the number of bits in the integer (8, 16, 24, or 32).\n *\n * @return the integer.\n */\nutil.DataBuffer.prototype.getInt = function(n) {\n  _checkBitsParam(n);\n  var rval = 0;\n  do {\n    // TODO: Use (rval * 0x100) if adding support for 33 to 53 bits.\n    rval = (rval << 8) + this.data.getInt8(this.read++);\n    n -= 8;\n  } while(n > 0);\n  return rval;\n};\n\n/**\n * Gets a signed n-bit integer from this buffer in big-endian order, using\n * two's complement, and advances the read pointer by n/8.\n *\n * @param n the number of bits in the integer (8, 16, 24, or 32).\n *\n * @return the integer.\n */\nutil.DataBuffer.prototype.getSignedInt = function(n) {\n  // getInt checks n\n  var x = this.getInt(n);\n  var max = 2 << (n - 2);\n  if(x >= max) {\n    x -= max << 1;\n  }\n  return x;\n};\n\n/**\n * Reads bytes out as a binary encoded string and clears them from the\n * buffer.\n *\n * @param count the number of bytes to read, undefined or null for all.\n *\n * @return a binary encoded string of bytes.\n */\nutil.DataBuffer.prototype.getBytes = function(count) {\n  // TODO: deprecate this method, it is poorly named and\n  // this.toString('binary') replaces it\n  // add a toTypedArray()/toArrayBuffer() function\n  var rval;\n  if(count) {\n    // read count bytes\n    count = Math.min(this.length(), count);\n    rval = this.data.slice(this.read, this.read + count);\n    this.read += count;\n  } else if(count === 0) {\n    rval = '';\n  } else {\n    // read all bytes, optimize to only copy when needed\n    rval = (this.read === 0) ? this.data : this.data.slice(this.read);\n    this.clear();\n  }\n  return rval;\n};\n\n/**\n * Gets a binary encoded string of the bytes from this buffer without\n * modifying the read pointer.\n *\n * @param count the number of bytes to get, omit to get all.\n *\n * @return a string full of binary encoded characters.\n */\nutil.DataBuffer.prototype.bytes = function(count) {\n  // TODO: deprecate this method, it is poorly named, add \"getString()\"\n  return (typeof(count) === 'undefined' ?\n    this.data.slice(this.read) :\n    this.data.slice(this.read, this.read + count));\n};\n\n/**\n * Gets a byte at the given index without modifying the read pointer.\n *\n * @param i the byte index.\n *\n * @return the byte.\n */\nutil.DataBuffer.prototype.at = function(i) {\n  return this.data.getUint8(this.read + i);\n};\n\n/**\n * Puts a byte at the given index without modifying the read pointer.\n *\n * @param i the byte index.\n * @param b the byte to put.\n *\n * @return this buffer.\n */\nutil.DataBuffer.prototype.setAt = function(i, b) {\n  this.data.setUint8(i, b);\n  return this;\n};\n\n/**\n * Gets the last byte without modifying the read pointer.\n *\n * @return the last byte.\n */\nutil.DataBuffer.prototype.last = function() {\n  return this.data.getUint8(this.write - 1);\n};\n\n/**\n * Creates a copy of this buffer.\n *\n * @return the copy.\n */\nutil.DataBuffer.prototype.copy = function() {\n  return new util.DataBuffer(this);\n};\n\n/**\n * Compacts this buffer.\n *\n * @return this buffer.\n */\nutil.DataBuffer.prototype.compact = function() {\n  if(this.read > 0) {\n    var src = new Uint8Array(this.data.buffer, this.read);\n    var dst = new Uint8Array(src.byteLength);\n    dst.set(src);\n    this.data = new DataView(dst);\n    this.write -= this.read;\n    this.read = 0;\n  }\n  return this;\n};\n\n/**\n * Clears this buffer.\n *\n * @return this buffer.\n */\nutil.DataBuffer.prototype.clear = function() {\n  this.data = new DataView(new ArrayBuffer(0));\n  this.read = this.write = 0;\n  return this;\n};\n\n/**\n * Shortens this buffer by triming bytes off of the end of this buffer.\n *\n * @param count the number of bytes to trim off.\n *\n * @return this buffer.\n */\nutil.DataBuffer.prototype.truncate = function(count) {\n  this.write = Math.max(0, this.length() - count);\n  this.read = Math.min(this.read, this.write);\n  return this;\n};\n\n/**\n * Converts this buffer to a hexadecimal string.\n *\n * @return a hexadecimal string.\n */\nutil.DataBuffer.prototype.toHex = function() {\n  var rval = '';\n  for(var i = this.read; i < this.data.byteLength; ++i) {\n    var b = this.data.getUint8(i);\n    if(b < 16) {\n      rval += '0';\n    }\n    rval += b.toString(16);\n  }\n  return rval;\n};\n\n/**\n * Converts this buffer to a string, using the given encoding. If no\n * encoding is given, 'utf8' (UTF-8) is used.\n *\n * @param [encoding] the encoding to use: 'binary', 'utf8', 'utf16', 'hex',\n *          'base64' (default: 'utf8').\n *\n * @return a string representation of the bytes in this buffer.\n */\nutil.DataBuffer.prototype.toString = function(encoding) {\n  var view = new Uint8Array(this.data, this.read, this.length());\n  encoding = encoding || 'utf8';\n\n  // encode to string\n  if(encoding === 'binary' || encoding === 'raw') {\n    return util.binary.raw.encode(view);\n  }\n  if(encoding === 'hex') {\n    return util.binary.hex.encode(view);\n  }\n  if(encoding === 'base64') {\n    return util.binary.base64.encode(view);\n  }\n\n  // decode to text\n  if(encoding === 'utf8') {\n    return util.text.utf8.decode(view);\n  }\n  if(encoding === 'utf16') {\n    return util.text.utf16.decode(view);\n  }\n\n  throw new Error('Invalid encoding: ' + encoding);\n};\n\n/** End Buffer w/UInt8Array backing */\n\n/**\n * Creates a buffer that stores bytes. A value may be given to populate the\n * buffer with data. This value can either be string of encoded bytes or a\n * regular string of characters. When passing a string of binary encoded\n * bytes, the encoding `raw` should be given. This is also the default. When\n * passing a string of characters, the encoding `utf8` should be given.\n *\n * @param [input] a string with encoded bytes to store in the buffer.\n * @param [encoding] (default: 'raw', other: 'utf8').\n */\nutil.createBuffer = function(input, encoding) {\n  // TODO: deprecate, use new ByteBuffer() instead\n  encoding = encoding || 'raw';\n  if(input !== undefined && encoding === 'utf8') {\n    input = util.encodeUtf8(input);\n  }\n  return new util.ByteBuffer(input);\n};\n\n/**\n * Fills a string with a particular value. If you want the string to be a byte\n * string, pass in String.fromCharCode(theByte).\n *\n * @param c the character to fill the string with, use String.fromCharCode\n *          to fill the string with a byte value.\n * @param n the number of characters of value c to fill with.\n *\n * @return the filled string.\n */\nutil.fillString = function(c, n) {\n  var s = '';\n  while(n > 0) {\n    if(n & 1) {\n      s += c;\n    }\n    n >>>= 1;\n    if(n > 0) {\n      c += c;\n    }\n  }\n  return s;\n};\n\n/**\n * Performs a per byte XOR between two byte strings and returns the result as a\n * string of bytes.\n *\n * @param s1 first string of bytes.\n * @param s2 second string of bytes.\n * @param n the number of bytes to XOR.\n *\n * @return the XOR'd result.\n */\nutil.xorBytes = function(s1, s2, n) {\n  var s3 = '';\n  var b = '';\n  var t = '';\n  var i = 0;\n  var c = 0;\n  for(; n > 0; --n, ++i) {\n    b = s1.charCodeAt(i) ^ s2.charCodeAt(i);\n    if(c >= 10) {\n      s3 += t;\n      t = '';\n      c = 0;\n    }\n    t += String.fromCharCode(b);\n    ++c;\n  }\n  s3 += t;\n  return s3;\n};\n\n/**\n * Converts a hex string into a 'binary' encoded string of bytes.\n *\n * @param hex the hexadecimal string to convert.\n *\n * @return the binary-encoded string of bytes.\n */\nutil.hexToBytes = function(hex) {\n  // TODO: deprecate: \"Deprecated. Use util.binary.hex.decode instead.\"\n  var rval = '';\n  var i = 0;\n  if(hex.length & 1 == 1) {\n    // odd number of characters, convert first character alone\n    i = 1;\n    rval += String.fromCharCode(parseInt(hex[0], 16));\n  }\n  // convert 2 characters (1 byte) at a time\n  for(; i < hex.length; i += 2) {\n    rval += String.fromCharCode(parseInt(hex.substr(i, 2), 16));\n  }\n  return rval;\n};\n\n/**\n * Converts a 'binary' encoded string of bytes to hex.\n *\n * @param bytes the byte string to convert.\n *\n * @return the string of hexadecimal characters.\n */\nutil.bytesToHex = function(bytes) {\n  // TODO: deprecate: \"Deprecated. Use util.binary.hex.encode instead.\"\n  return util.createBuffer(bytes).toHex();\n};\n\n/**\n * Converts an 32-bit integer to 4-big-endian byte string.\n *\n * @param i the integer.\n *\n * @return the byte string.\n */\nutil.int32ToBytes = function(i) {\n  return (\n    String.fromCharCode(i >> 24 & 0xFF) +\n    String.fromCharCode(i >> 16 & 0xFF) +\n    String.fromCharCode(i >> 8 & 0xFF) +\n    String.fromCharCode(i & 0xFF));\n};\n\n// base64 characters, reverse mapping\nvar _base64 =\n  'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\nvar _base64Idx = [\n/*43 -43 = 0*/\n/*'+',  1,  2,  3,'/' */\n   62, -1, -1, -1, 63,\n\n/*'0','1','2','3','4','5','6','7','8','9' */\n   52, 53, 54, 55, 56, 57, 58, 59, 60, 61,\n\n/*15, 16, 17,'=', 19, 20, 21 */\n  -1, -1, -1, 64, -1, -1, -1,\n\n/*65 - 43 = 22*/\n/*'A','B','C','D','E','F','G','H','I','J','K','L','M', */\n   0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12,\n\n/*'N','O','P','Q','R','S','T','U','V','W','X','Y','Z' */\n   13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,\n\n/*91 - 43 = 48 */\n/*48, 49, 50, 51, 52, 53 */\n  -1, -1, -1, -1, -1, -1,\n\n/*97 - 43 = 54*/\n/*'a','b','c','d','e','f','g','h','i','j','k','l','m' */\n   26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38,\n\n/*'n','o','p','q','r','s','t','u','v','w','x','y','z' */\n   39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51\n];\n\n// base58 characters (Bitcoin alphabet)\nvar _base58 = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\n\n/**\n * Base64 encodes a 'binary' encoded string of bytes.\n *\n * @param input the binary encoded string of bytes to base64-encode.\n * @param maxline the maximum number of encoded characters per line to use,\n *          defaults to none.\n *\n * @return the base64-encoded output.\n */\nutil.encode64 = function(input, maxline) {\n  // TODO: deprecate: \"Deprecated. Use util.binary.base64.encode instead.\"\n  var line = '';\n  var output = '';\n  var chr1, chr2, chr3;\n  var i = 0;\n  while(i < input.length) {\n    chr1 = input.charCodeAt(i++);\n    chr2 = input.charCodeAt(i++);\n    chr3 = input.charCodeAt(i++);\n\n    // encode 4 character group\n    line += _base64.charAt(chr1 >> 2);\n    line += _base64.charAt(((chr1 & 3) << 4) | (chr2 >> 4));\n    if(isNaN(chr2)) {\n      line += '==';\n    } else {\n      line += _base64.charAt(((chr2 & 15) << 2) | (chr3 >> 6));\n      line += isNaN(chr3) ? '=' : _base64.charAt(chr3 & 63);\n    }\n\n    if(maxline && line.length > maxline) {\n      output += line.substr(0, maxline) + '\\r\\n';\n      line = line.substr(maxline);\n    }\n  }\n  output += line;\n  return output;\n};\n\n/**\n * Base64 decodes a string into a 'binary' encoded string of bytes.\n *\n * @param input the base64-encoded input.\n *\n * @return the binary encoded string.\n */\nutil.decode64 = function(input) {\n  // TODO: deprecate: \"Deprecated. Use util.binary.base64.decode instead.\"\n\n  // remove all non-base64 characters\n  input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, '');\n\n  var output = '';\n  var enc1, enc2, enc3, enc4;\n  var i = 0;\n\n  while(i < input.length) {\n    enc1 = _base64Idx[input.charCodeAt(i++) - 43];\n    enc2 = _base64Idx[input.charCodeAt(i++) - 43];\n    enc3 = _base64Idx[input.charCodeAt(i++) - 43];\n    enc4 = _base64Idx[input.charCodeAt(i++) - 43];\n\n    output += String.fromCharCode((enc1 << 2) | (enc2 >> 4));\n    if(enc3 !== 64) {\n      // decoded at least 2 bytes\n      output += String.fromCharCode(((enc2 & 15) << 4) | (enc3 >> 2));\n      if(enc4 !== 64) {\n        // decoded 3 bytes\n        output += String.fromCharCode(((enc3 & 3) << 6) | enc4);\n      }\n    }\n  }\n\n  return output;\n};\n\n/**\n * Encodes the given string of characters (a standard JavaScript\n * string) as a binary encoded string where the bytes represent\n * a UTF-8 encoded string of characters. Non-ASCII characters will be\n * encoded as multiple bytes according to UTF-8.\n *\n * @param str a standard string of characters to encode.\n *\n * @return the binary encoded string.\n */\nutil.encodeUtf8 = function(str) {\n  return unescape(encodeURIComponent(str));\n};\n\n/**\n * Decodes a binary encoded string that contains bytes that\n * represent a UTF-8 encoded string of characters -- into a\n * string of characters (a standard JavaScript string).\n *\n * @param str the binary encoded string to decode.\n *\n * @return the resulting standard string of characters.\n */\nutil.decodeUtf8 = function(str) {\n  return decodeURIComponent(escape(str));\n};\n\n// binary encoding/decoding tools\n// FIXME: Experimental. Do not use yet.\nutil.binary = {\n  raw: {},\n  hex: {},\n  base64: {},\n  base58: {},\n  baseN : {\n    encode: baseN.encode,\n    decode: baseN.decode\n  }\n};\n\n/**\n * Encodes a Uint8Array as a binary-encoded string. This encoding uses\n * a value between 0 and 255 for each character.\n *\n * @param bytes the Uint8Array to encode.\n *\n * @return the binary-encoded string.\n */\nutil.binary.raw.encode = function(bytes) {\n  return String.fromCharCode.apply(null, bytes);\n};\n\n/**\n * Decodes a binary-encoded string to a Uint8Array. This encoding uses\n * a value between 0 and 255 for each character.\n *\n * @param str the binary-encoded string to decode.\n * @param [output] an optional Uint8Array to write the output to; if it\n *          is too small, an exception will be thrown.\n * @param [offset] the start offset for writing to the output (default: 0).\n *\n * @return the Uint8Array or the number of bytes written if output was given.\n */\nutil.binary.raw.decode = function(str, output, offset) {\n  var out = output;\n  if(!out) {\n    out = new Uint8Array(str.length);\n  }\n  offset = offset || 0;\n  var j = offset;\n  for(var i = 0; i < str.length; ++i) {\n    out[j++] = str.charCodeAt(i);\n  }\n  return output ? (j - offset) : out;\n};\n\n/**\n * Encodes a 'binary' string, ArrayBuffer, DataView, TypedArray, or\n * ByteBuffer as a string of hexadecimal characters.\n *\n * @param bytes the bytes to convert.\n *\n * @return the string of hexadecimal characters.\n */\nutil.binary.hex.encode = util.bytesToHex;\n\n/**\n * Decodes a hex-encoded string to a Uint8Array.\n *\n * @param hex the hexadecimal string to convert.\n * @param [output] an optional Uint8Array to write the output to; if it\n *          is too small, an exception will be thrown.\n * @param [offset] the start offset for writing to the output (default: 0).\n *\n * @return the Uint8Array or the number of bytes written if output was given.\n */\nutil.binary.hex.decode = function(hex, output, offset) {\n  var out = output;\n  if(!out) {\n    out = new Uint8Array(Math.ceil(hex.length / 2));\n  }\n  offset = offset || 0;\n  var i = 0, j = offset;\n  if(hex.length & 1) {\n    // odd number of characters, convert first character alone\n    i = 1;\n    out[j++] = parseInt(hex[0], 16);\n  }\n  // convert 2 characters (1 byte) at a time\n  for(; i < hex.length; i += 2) {\n    out[j++] = parseInt(hex.substr(i, 2), 16);\n  }\n  return output ? (j - offset) : out;\n};\n\n/**\n * Base64-encodes a Uint8Array.\n *\n * @param input the Uint8Array to encode.\n * @param maxline the maximum number of encoded characters per line to use,\n *          defaults to none.\n *\n * @return the base64-encoded output string.\n */\nutil.binary.base64.encode = function(input, maxline) {\n  var line = '';\n  var output = '';\n  var chr1, chr2, chr3;\n  var i = 0;\n  while(i < input.byteLength) {\n    chr1 = input[i++];\n    chr2 = input[i++];\n    chr3 = input[i++];\n\n    // encode 4 character group\n    line += _base64.charAt(chr1 >> 2);\n    line += _base64.charAt(((chr1 & 3) << 4) | (chr2 >> 4));\n    if(isNaN(chr2)) {\n      line += '==';\n    } else {\n      line += _base64.charAt(((chr2 & 15) << 2) | (chr3 >> 6));\n      line += isNaN(chr3) ? '=' : _base64.charAt(chr3 & 63);\n    }\n\n    if(maxline && line.length > maxline) {\n      output += line.substr(0, maxline) + '\\r\\n';\n      line = line.substr(maxline);\n    }\n  }\n  output += line;\n  return output;\n};\n\n/**\n * Decodes a base64-encoded string to a Uint8Array.\n *\n * @param input the base64-encoded input string.\n * @param [output] an optional Uint8Array to write the output to; if it\n *          is too small, an exception will be thrown.\n * @param [offset] the start offset for writing to the output (default: 0).\n *\n * @return the Uint8Array or the number of bytes written if output was given.\n */\nutil.binary.base64.decode = function(input, output, offset) {\n  var out = output;\n  if(!out) {\n    out = new Uint8Array(Math.ceil(input.length / 4) * 3);\n  }\n\n  // remove all non-base64 characters\n  input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, '');\n\n  offset = offset || 0;\n  var enc1, enc2, enc3, enc4;\n  var i = 0, j = offset;\n\n  while(i < input.length) {\n    enc1 = _base64Idx[input.charCodeAt(i++) - 43];\n    enc2 = _base64Idx[input.charCodeAt(i++) - 43];\n    enc3 = _base64Idx[input.charCodeAt(i++) - 43];\n    enc4 = _base64Idx[input.charCodeAt(i++) - 43];\n\n    out[j++] = (enc1 << 2) | (enc2 >> 4);\n    if(enc3 !== 64) {\n      // decoded at least 2 bytes\n      out[j++] = ((enc2 & 15) << 4) | (enc3 >> 2);\n      if(enc4 !== 64) {\n        // decoded 3 bytes\n        out[j++] = ((enc3 & 3) << 6) | enc4;\n      }\n    }\n  }\n\n  // make sure result is the exact decoded length\n  return output ? (j - offset) : out.subarray(0, j);\n};\n\n// add support for base58 encoding/decoding with Bitcoin alphabet\nutil.binary.base58.encode = function(input, maxline) {\n  return util.binary.baseN.encode(input, _base58, maxline);\n};\nutil.binary.base58.decode = function(input, maxline) {\n  return util.binary.baseN.decode(input, _base58, maxline);\n};\n\n// text encoding/decoding tools\n// FIXME: Experimental. Do not use yet.\nutil.text = {\n  utf8: {},\n  utf16: {}\n};\n\n/**\n * Encodes the given string as UTF-8 in a Uint8Array.\n *\n * @param str the string to encode.\n * @param [output] an optional Uint8Array to write the output to; if it\n *          is too small, an exception will be thrown.\n * @param [offset] the start offset for writing to the output (default: 0).\n *\n * @return the Uint8Array or the number of bytes written if output was given.\n */\nutil.text.utf8.encode = function(str, output, offset) {\n  str = util.encodeUtf8(str);\n  var out = output;\n  if(!out) {\n    out = new Uint8Array(str.length);\n  }\n  offset = offset || 0;\n  var j = offset;\n  for(var i = 0; i < str.length; ++i) {\n    out[j++] = str.charCodeAt(i);\n  }\n  return output ? (j - offset) : out;\n};\n\n/**\n * Decodes the UTF-8 contents from a Uint8Array.\n *\n * @param bytes the Uint8Array to decode.\n *\n * @return the resulting string.\n */\nutil.text.utf8.decode = function(bytes) {\n  return util.decodeUtf8(String.fromCharCode.apply(null, bytes));\n};\n\n/**\n * Encodes the given string as UTF-16 in a Uint8Array.\n *\n * @param str the string to encode.\n * @param [output] an optional Uint8Array to write the output to; if it\n *          is too small, an exception will be thrown.\n * @param [offset] the start offset for writing to the output (default: 0).\n *\n * @return the Uint8Array or the number of bytes written if output was given.\n */\nutil.text.utf16.encode = function(str, output, offset) {\n  var out = output;\n  if(!out) {\n    out = new Uint8Array(str.length * 2);\n  }\n  var view = new Uint16Array(out.buffer);\n  offset = offset || 0;\n  var j = offset;\n  var k = offset;\n  for(var i = 0; i < str.length; ++i) {\n    view[k++] = str.charCodeAt(i);\n    j += 2;\n  }\n  return output ? (j - offset) : out;\n};\n\n/**\n * Decodes the UTF-16 contents from a Uint8Array.\n *\n * @param bytes the Uint8Array to decode.\n *\n * @return the resulting string.\n */\nutil.text.utf16.decode = function(bytes) {\n  return String.fromCharCode.apply(null, new Uint16Array(bytes.buffer));\n};\n\n/**\n * Deflates the given data using a flash interface.\n *\n * @param api the flash interface.\n * @param bytes the data.\n * @param raw true to return only raw deflate data, false to include zlib\n *          header and trailer.\n *\n * @return the deflated data as a string.\n */\nutil.deflate = function(api, bytes, raw) {\n  bytes = util.decode64(api.deflate(util.encode64(bytes)).rval);\n\n  // strip zlib header and trailer if necessary\n  if(raw) {\n    // zlib header is 2 bytes (CMF,FLG) where FLG indicates that\n    // there is a 4-byte DICT (alder-32) block before the data if\n    // its 5th bit is set\n    var start = 2;\n    var flg = bytes.charCodeAt(1);\n    if(flg & 0x20) {\n      start = 6;\n    }\n    // zlib trailer is 4 bytes of adler-32\n    bytes = bytes.substring(start, bytes.length - 4);\n  }\n\n  return bytes;\n};\n\n/**\n * Inflates the given data using a flash interface.\n *\n * @param api the flash interface.\n * @param bytes the data.\n * @param raw true if the incoming data has no zlib header or trailer and is\n *          raw DEFLATE data.\n *\n * @return the inflated data as a string, null on error.\n */\nutil.inflate = function(api, bytes, raw) {\n  // TODO: add zlib header and trailer if necessary/possible\n  var rval = api.inflate(util.encode64(bytes)).rval;\n  return (rval === null) ? null : util.decode64(rval);\n};\n\n/**\n * Sets a storage object.\n *\n * @param api the storage interface.\n * @param id the storage ID to use.\n * @param obj the storage object, null to remove.\n */\nvar _setStorageObject = function(api, id, obj) {\n  if(!api) {\n    throw new Error('WebStorage not available.');\n  }\n\n  var rval;\n  if(obj === null) {\n    rval = api.removeItem(id);\n  } else {\n    // json-encode and base64-encode object\n    obj = util.encode64(JSON.stringify(obj));\n    rval = api.setItem(id, obj);\n  }\n\n  // handle potential flash error\n  if(typeof(rval) !== 'undefined' && rval.rval !== true) {\n    var error = new Error(rval.error.message);\n    error.id = rval.error.id;\n    error.name = rval.error.name;\n    throw error;\n  }\n};\n\n/**\n * Gets a storage object.\n *\n * @param api the storage interface.\n * @param id the storage ID to use.\n *\n * @return the storage object entry or null if none exists.\n */\nvar _getStorageObject = function(api, id) {\n  if(!api) {\n    throw new Error('WebStorage not available.');\n  }\n\n  // get the existing entry\n  var rval = api.getItem(id);\n\n  /* Note: We check api.init because we can't do (api == localStorage)\n    on IE because of \"Class doesn't support Automation\" exception. Only\n    the flash api has an init method so this works too, but we need a\n    better solution in the future. */\n\n  // flash returns item wrapped in an object, handle special case\n  if(api.init) {\n    if(rval.rval === null) {\n      if(rval.error) {\n        var error = new Error(rval.error.message);\n        error.id = rval.error.id;\n        error.name = rval.error.name;\n        throw error;\n      }\n      // no error, but also no item\n      rval = null;\n    } else {\n      rval = rval.rval;\n    }\n  }\n\n  // handle decoding\n  if(rval !== null) {\n    // base64-decode and json-decode data\n    rval = JSON.parse(util.decode64(rval));\n  }\n\n  return rval;\n};\n\n/**\n * Stores an item in local storage.\n *\n * @param api the storage interface.\n * @param id the storage ID to use.\n * @param key the key for the item.\n * @param data the data for the item (any javascript object/primitive).\n */\nvar _setItem = function(api, id, key, data) {\n  // get storage object\n  var obj = _getStorageObject(api, id);\n  if(obj === null) {\n    // create a new storage object\n    obj = {};\n  }\n  // update key\n  obj[key] = data;\n\n  // set storage object\n  _setStorageObject(api, id, obj);\n};\n\n/**\n * Gets an item from local storage.\n *\n * @param api the storage interface.\n * @param id the storage ID to use.\n * @param key the key for the item.\n *\n * @return the item.\n */\nvar _getItem = function(api, id, key) {\n  // get storage object\n  var rval = _getStorageObject(api, id);\n  if(rval !== null) {\n    // return data at key\n    rval = (key in rval) ? rval[key] : null;\n  }\n\n  return rval;\n};\n\n/**\n * Removes an item from local storage.\n *\n * @param api the storage interface.\n * @param id the storage ID to use.\n * @param key the key for the item.\n */\nvar _removeItem = function(api, id, key) {\n  // get storage object\n  var obj = _getStorageObject(api, id);\n  if(obj !== null && key in obj) {\n    // remove key\n    delete obj[key];\n\n    // see if entry has no keys remaining\n    var empty = true;\n    for(var prop in obj) {\n      empty = false;\n      break;\n    }\n    if(empty) {\n      // remove entry entirely if no keys are left\n      obj = null;\n    }\n\n    // set storage object\n    _setStorageObject(api, id, obj);\n  }\n};\n\n/**\n * Clears the local disk storage identified by the given ID.\n *\n * @param api the storage interface.\n * @param id the storage ID to use.\n */\nvar _clearItems = function(api, id) {\n  _setStorageObject(api, id, null);\n};\n\n/**\n * Calls a storage function.\n *\n * @param func the function to call.\n * @param args the arguments for the function.\n * @param location the location argument.\n *\n * @return the return value from the function.\n */\nvar _callStorageFunction = function(func, args, location) {\n  var rval = null;\n\n  // default storage types\n  if(typeof(location) === 'undefined') {\n    location = ['web', 'flash'];\n  }\n\n  // apply storage types in order of preference\n  var type;\n  var done = false;\n  var exception = null;\n  for(var idx in location) {\n    type = location[idx];\n    try {\n      if(type === 'flash' || type === 'both') {\n        if(args[0] === null) {\n          throw new Error('Flash local storage not available.');\n        }\n        rval = func.apply(this, args);\n        done = (type === 'flash');\n      }\n      if(type === 'web' || type === 'both') {\n        args[0] = localStorage;\n        rval = func.apply(this, args);\n        done = true;\n      }\n    } catch(ex) {\n      exception = ex;\n    }\n    if(done) {\n      break;\n    }\n  }\n\n  if(!done) {\n    throw exception;\n  }\n\n  return rval;\n};\n\n/**\n * Stores an item on local disk.\n *\n * The available types of local storage include 'flash', 'web', and 'both'.\n *\n * The type 'flash' refers to flash local storage (SharedObject). In order\n * to use flash local storage, the 'api' parameter must be valid. The type\n * 'web' refers to WebStorage, if supported by the browser. The type 'both'\n * refers to storing using both 'flash' and 'web', not just one or the\n * other.\n *\n * The location array should list the storage types to use in order of\n * preference:\n *\n * ['flash']: flash only storage\n * ['web']: web only storage\n * ['both']: try to store in both\n * ['flash','web']: store in flash first, but if not available, 'web'\n * ['web','flash']: store in web first, but if not available, 'flash'\n *\n * The location array defaults to: ['web', 'flash']\n *\n * @param api the flash interface, null to use only WebStorage.\n * @param id the storage ID to use.\n * @param key the key for the item.\n * @param data the data for the item (any javascript object/primitive).\n * @param location an array with the preferred types of storage to use.\n */\nutil.setItem = function(api, id, key, data, location) {\n  _callStorageFunction(_setItem, arguments, location);\n};\n\n/**\n * Gets an item on local disk.\n *\n * Set setItem() for details on storage types.\n *\n * @param api the flash interface, null to use only WebStorage.\n * @param id the storage ID to use.\n * @param key the key for the item.\n * @param location an array with the preferred types of storage to use.\n *\n * @return the item.\n */\nutil.getItem = function(api, id, key, location) {\n  return _callStorageFunction(_getItem, arguments, location);\n};\n\n/**\n * Removes an item on local disk.\n *\n * Set setItem() for details on storage types.\n *\n * @param api the flash interface.\n * @param id the storage ID to use.\n * @param key the key for the item.\n * @param location an array with the preferred types of storage to use.\n */\nutil.removeItem = function(api, id, key, location) {\n  _callStorageFunction(_removeItem, arguments, location);\n};\n\n/**\n * Clears the local disk storage identified by the given ID.\n *\n * Set setItem() for details on storage types.\n *\n * @param api the flash interface if flash is available.\n * @param id the storage ID to use.\n * @param location an array with the preferred types of storage to use.\n */\nutil.clearItems = function(api, id, location) {\n  _callStorageFunction(_clearItems, arguments, location);\n};\n\n/**\n * Parses the scheme, host, and port from an http(s) url.\n *\n * @param str the url string.\n *\n * @return the parsed url object or null if the url is invalid.\n */\nutil.parseUrl = function(str) {\n  // FIXME: this regex looks a bit broken\n  var regex = /^(https?):\\/\\/([^:&^\\/]*):?(\\d*)(.*)$/g;\n  regex.lastIndex = 0;\n  var m = regex.exec(str);\n  var url = (m === null) ? null : {\n    full: str,\n    scheme: m[1],\n    host: m[2],\n    port: m[3],\n    path: m[4]\n  };\n  if(url) {\n    url.fullHost = url.host;\n    if(url.port) {\n      if(url.port !== 80 && url.scheme === 'http') {\n        url.fullHost += ':' + url.port;\n      } else if(url.port !== 443 && url.scheme === 'https') {\n        url.fullHost += ':' + url.port;\n      }\n    } else if(url.scheme === 'http') {\n      url.port = 80;\n    } else if(url.scheme === 'https') {\n      url.port = 443;\n    }\n    url.full = url.scheme + '://' + url.fullHost;\n  }\n  return url;\n};\n\n/* Storage for query variables */\nvar _queryVariables = null;\n\n/**\n * Returns the window location query variables. Query is parsed on the first\n * call and the same object is returned on subsequent calls. The mapping\n * is from keys to an array of values. Parameters without values will have\n * an object key set but no value added to the value array. Values are\n * unescaped.\n *\n * ...?k1=v1&k2=v2:\n * {\n *   \"k1\": [\"v1\"],\n *   \"k2\": [\"v2\"]\n * }\n *\n * ...?k1=v1&k1=v2:\n * {\n *   \"k1\": [\"v1\", \"v2\"]\n * }\n *\n * ...?k1=v1&k2:\n * {\n *   \"k1\": [\"v1\"],\n *   \"k2\": []\n * }\n *\n * ...?k1=v1&k1:\n * {\n *   \"k1\": [\"v1\"]\n * }\n *\n * ...?k1&k1:\n * {\n *   \"k1\": []\n * }\n *\n * @param query the query string to parse (optional, default to cached\n *          results from parsing window location search query).\n *\n * @return object mapping keys to variables.\n */\nutil.getQueryVariables = function(query) {\n  var parse = function(q) {\n    var rval = {};\n    var kvpairs = q.split('&');\n    for(var i = 0; i < kvpairs.length; i++) {\n      var pos = kvpairs[i].indexOf('=');\n      var key;\n      var val;\n      if(pos > 0) {\n        key = kvpairs[i].substring(0, pos);\n        val = kvpairs[i].substring(pos + 1);\n      } else {\n        key = kvpairs[i];\n        val = null;\n      }\n      if(!(key in rval)) {\n        rval[key] = [];\n      }\n      // disallow overriding object prototype keys\n      if(!(key in Object.prototype) && val !== null) {\n        rval[key].push(unescape(val));\n      }\n    }\n    return rval;\n  };\n\n   var rval;\n   if(typeof(query) === 'undefined') {\n     // set cached variables if needed\n     if(_queryVariables === null) {\n       if(typeof(window) !== 'undefined' && window.location && window.location.search) {\n          // parse window search query\n          _queryVariables = parse(window.location.search.substring(1));\n       } else {\n          // no query variables available\n          _queryVariables = {};\n       }\n     }\n     rval = _queryVariables;\n   } else {\n     // parse given query\n     rval = parse(query);\n   }\n   return rval;\n};\n\n/**\n * Parses a fragment into a path and query. This method will take a URI\n * fragment and break it up as if it were the main URI. For example:\n *    /bar/baz?a=1&b=2\n * results in:\n *    {\n *       path: [\"bar\", \"baz\"],\n *       query: {\"k1\": [\"v1\"], \"k2\": [\"v2\"]}\n *    }\n *\n * @return object with a path array and query object.\n */\nutil.parseFragment = function(fragment) {\n  // default to whole fragment\n  var fp = fragment;\n  var fq = '';\n  // split into path and query if possible at the first '?'\n  var pos = fragment.indexOf('?');\n  if(pos > 0) {\n    fp = fragment.substring(0, pos);\n    fq = fragment.substring(pos + 1);\n  }\n  // split path based on '/' and ignore first element if empty\n  var path = fp.split('/');\n  if(path.length > 0 && path[0] === '') {\n    path.shift();\n  }\n  // convert query into object\n  var query = (fq === '') ? {} : util.getQueryVariables(fq);\n\n  return {\n    pathString: fp,\n    queryString: fq,\n    path: path,\n    query: query\n  };\n};\n\n/**\n * Makes a request out of a URI-like request string. This is intended to\n * be used where a fragment id (after a URI '#') is parsed as a URI with\n * path and query parts. The string should have a path beginning and\n * delimited by '/' and optional query parameters following a '?'. The\n * query should be a standard URL set of key value pairs delimited by\n * '&'. For backwards compatibility the initial '/' on the path is not\n * required. The request object has the following API, (fully described\n * in the method code):\n *    {\n *       path: <the path string part>.\n *       query: <the query string part>,\n *       getPath(i): get part or all of the split path array,\n *       getQuery(k, i): get part or all of a query key array,\n *       getQueryLast(k, _default): get last element of a query key array.\n *    }\n *\n * @return object with request parameters.\n */\nutil.makeRequest = function(reqString) {\n  var frag = util.parseFragment(reqString);\n  var req = {\n    // full path string\n    path: frag.pathString,\n    // full query string\n    query: frag.queryString,\n    /**\n     * Get path or element in path.\n     *\n     * @param i optional path index.\n     *\n     * @return path or part of path if i provided.\n     */\n    getPath: function(i) {\n      return (typeof(i) === 'undefined') ? frag.path : frag.path[i];\n    },\n    /**\n     * Get query, values for a key, or value for a key index.\n     *\n     * @param k optional query key.\n     * @param i optional query key index.\n     *\n     * @return query, values for a key, or value for a key index.\n     */\n    getQuery: function(k, i) {\n      var rval;\n      if(typeof(k) === 'undefined') {\n        rval = frag.query;\n      } else {\n        rval = frag.query[k];\n        if(rval && typeof(i) !== 'undefined') {\n           rval = rval[i];\n        }\n      }\n      return rval;\n    },\n    getQueryLast: function(k, _default) {\n      var rval;\n      var vals = req.getQuery(k);\n      if(vals) {\n        rval = vals[vals.length - 1];\n      } else {\n        rval = _default;\n      }\n      return rval;\n    }\n  };\n  return req;\n};\n\n/**\n * Makes a URI out of a path, an object with query parameters, and a\n * fragment. Uses jQuery.param() internally for query string creation.\n * If the path is an array, it will be joined with '/'.\n *\n * @param path string path or array of strings.\n * @param query object with query parameters. (optional)\n * @param fragment fragment string. (optional)\n *\n * @return string object with request parameters.\n */\nutil.makeLink = function(path, query, fragment) {\n  // join path parts if needed\n  path = jQuery.isArray(path) ? path.join('/') : path;\n\n  var qstr = jQuery.param(query || {});\n  fragment = fragment || '';\n  return path +\n    ((qstr.length > 0) ? ('?' + qstr) : '') +\n    ((fragment.length > 0) ? ('#' + fragment) : '');\n};\n\n/**\n * Check if an object is empty.\n *\n * Taken from:\n * http://stackoverflow.com/questions/679915/how-do-i-test-for-an-empty-javascript-object-from-json/679937#679937\n *\n * @param object the object to check.\n */\nutil.isEmpty = function(obj) {\n  for(var prop in obj) {\n    if(obj.hasOwnProperty(prop)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Format with simple printf-style interpolation.\n *\n * %%: literal '%'\n * %s,%o: convert next argument into a string.\n *\n * @param format the string to format.\n * @param ... arguments to interpolate into the format string.\n */\nutil.format = function(format) {\n  var re = /%./g;\n  // current match\n  var match;\n  // current part\n  var part;\n  // current arg index\n  var argi = 0;\n  // collected parts to recombine later\n  var parts = [];\n  // last index found\n  var last = 0;\n  // loop while matches remain\n  while((match = re.exec(format))) {\n    part = format.substring(last, re.lastIndex - 2);\n    // don't add empty strings (ie, parts between %s%s)\n    if(part.length > 0) {\n      parts.push(part);\n    }\n    last = re.lastIndex;\n    // switch on % code\n    var code = match[0][1];\n    switch(code) {\n    case 's':\n    case 'o':\n      // check if enough arguments were given\n      if(argi < arguments.length) {\n        parts.push(arguments[argi++ + 1]);\n      } else {\n        parts.push('<?>');\n      }\n      break;\n    // FIXME: do proper formating for numbers, etc\n    //case 'f':\n    //case 'd':\n    case '%':\n      parts.push('%');\n      break;\n    default:\n      parts.push('<%' + code + '?>');\n    }\n  }\n  // add trailing part of format string\n  parts.push(format.substring(last));\n  return parts.join('');\n};\n\n/**\n * Formats a number.\n *\n * http://snipplr.com/view/5945/javascript-numberformat--ported-from-php/\n */\nutil.formatNumber = function(number, decimals, dec_point, thousands_sep) {\n  // http://kevin.vanzonneveld.net\n  // +   original by: Jonas Raoni Soares Silva (http://www.jsfromhell.com)\n  // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n  // +     bugfix by: Michael White (http://crestidg.com)\n  // +     bugfix by: Benjamin Lupton\n  // +     bugfix by: Allan Jensen (http://www.winternet.no)\n  // +    revised by: Jonas Raoni Soares Silva (http://www.jsfromhell.com)\n  // *     example 1: number_format(1234.5678, 2, '.', '');\n  // *     returns 1: 1234.57\n\n  var n = number, c = isNaN(decimals = Math.abs(decimals)) ? 2 : decimals;\n  var d = dec_point === undefined ? ',' : dec_point;\n  var t = thousands_sep === undefined ?\n   '.' : thousands_sep, s = n < 0 ? '-' : '';\n  var i = parseInt((n = Math.abs(+n || 0).toFixed(c)), 10) + '';\n  var j = (i.length > 3) ? i.length % 3 : 0;\n  return s + (j ? i.substr(0, j) + t : '') +\n    i.substr(j).replace(/(\\d{3})(?=\\d)/g, '$1' + t) +\n    (c ? d + Math.abs(n - i).toFixed(c).slice(2) : '');\n};\n\n/**\n * Formats a byte size.\n *\n * http://snipplr.com/view/5949/format-humanize-file-byte-size-presentation-in-javascript/\n */\nutil.formatSize = function(size) {\n  if(size >= 1073741824) {\n    size = util.formatNumber(size / 1073741824, 2, '.', '') + ' GiB';\n  } else if(size >= 1048576) {\n    size = util.formatNumber(size / 1048576, 2, '.', '') + ' MiB';\n  } else if(size >= 1024) {\n    size = util.formatNumber(size / 1024, 0) + ' KiB';\n  } else {\n    size = util.formatNumber(size, 0) + ' bytes';\n  }\n  return size;\n};\n\n/**\n * Converts an IPv4 or IPv6 string representation into bytes (in network order).\n *\n * @param ip the IPv4 or IPv6 address to convert.\n *\n * @return the 4-byte IPv6 or 16-byte IPv6 address or null if the address can't\n *         be parsed.\n */\nutil.bytesFromIP = function(ip) {\n  if(ip.indexOf('.') !== -1) {\n    return util.bytesFromIPv4(ip);\n  }\n  if(ip.indexOf(':') !== -1) {\n    return util.bytesFromIPv6(ip);\n  }\n  return null;\n};\n\n/**\n * Converts an IPv4 string representation into bytes (in network order).\n *\n * @param ip the IPv4 address to convert.\n *\n * @return the 4-byte address or null if the address can't be parsed.\n */\nutil.bytesFromIPv4 = function(ip) {\n  ip = ip.split('.');\n  if(ip.length !== 4) {\n    return null;\n  }\n  var b = util.createBuffer();\n  for(var i = 0; i < ip.length; ++i) {\n    var num = parseInt(ip[i], 10);\n    if(isNaN(num)) {\n      return null;\n    }\n    b.putByte(num);\n  }\n  return b.getBytes();\n};\n\n/**\n * Converts an IPv6 string representation into bytes (in network order).\n *\n * @param ip the IPv6 address to convert.\n *\n * @return the 16-byte address or null if the address can't be parsed.\n */\nutil.bytesFromIPv6 = function(ip) {\n  var blanks = 0;\n  ip = ip.split(':').filter(function(e) {\n    if(e.length === 0) ++blanks;\n    return true;\n  });\n  var zeros = (8 - ip.length + blanks) * 2;\n  var b = util.createBuffer();\n  for(var i = 0; i < 8; ++i) {\n    if(!ip[i] || ip[i].length === 0) {\n      b.fillWithByte(0, zeros);\n      zeros = 0;\n      continue;\n    }\n    var bytes = util.hexToBytes(ip[i]);\n    if(bytes.length < 2) {\n      b.putByte(0);\n    }\n    b.putBytes(bytes);\n  }\n  return b.getBytes();\n};\n\n/**\n * Converts 4-bytes into an IPv4 string representation or 16-bytes into\n * an IPv6 string representation. The bytes must be in network order.\n *\n * @param bytes the bytes to convert.\n *\n * @return the IPv4 or IPv6 string representation if 4 or 16 bytes,\n *         respectively, are given, otherwise null.\n */\nutil.bytesToIP = function(bytes) {\n  if(bytes.length === 4) {\n    return util.bytesToIPv4(bytes);\n  }\n  if(bytes.length === 16) {\n    return util.bytesToIPv6(bytes);\n  }\n  return null;\n};\n\n/**\n * Converts 4-bytes into an IPv4 string representation. The bytes must be\n * in network order.\n *\n * @param bytes the bytes to convert.\n *\n * @return the IPv4 string representation or null for an invalid # of bytes.\n */\nutil.bytesToIPv4 = function(bytes) {\n  if(bytes.length !== 4) {\n    return null;\n  }\n  var ip = [];\n  for(var i = 0; i < bytes.length; ++i) {\n    ip.push(bytes.charCodeAt(i));\n  }\n  return ip.join('.');\n};\n\n/**\n * Converts 16-bytes into an IPv16 string representation. The bytes must be\n * in network order.\n *\n * @param bytes the bytes to convert.\n *\n * @return the IPv16 string representation or null for an invalid # of bytes.\n */\nutil.bytesToIPv6 = function(bytes) {\n  if(bytes.length !== 16) {\n    return null;\n  }\n  var ip = [];\n  var zeroGroups = [];\n  var zeroMaxGroup = 0;\n  for(var i = 0; i < bytes.length; i += 2) {\n    var hex = util.bytesToHex(bytes[i] + bytes[i + 1]);\n    // canonicalize zero representation\n    while(hex[0] === '0' && hex !== '0') {\n      hex = hex.substr(1);\n    }\n    if(hex === '0') {\n      var last = zeroGroups[zeroGroups.length - 1];\n      var idx = ip.length;\n      if(!last || idx !== last.end + 1) {\n        zeroGroups.push({start: idx, end: idx});\n      } else {\n        last.end = idx;\n        if((last.end - last.start) >\n          (zeroGroups[zeroMaxGroup].end - zeroGroups[zeroMaxGroup].start)) {\n          zeroMaxGroup = zeroGroups.length - 1;\n        }\n      }\n    }\n    ip.push(hex);\n  }\n  if(zeroGroups.length > 0) {\n    var group = zeroGroups[zeroMaxGroup];\n    // only shorten group of length > 0\n    if(group.end - group.start > 0) {\n      ip.splice(group.start, group.end - group.start + 1, '');\n      if(group.start === 0) {\n        ip.unshift('');\n      }\n      if(group.end === 7) {\n        ip.push('');\n      }\n    }\n  }\n  return ip.join(':');\n};\n\n/**\n * Estimates the number of processes that can be run concurrently. If\n * creating Web Workers, keep in mind that the main JavaScript process needs\n * its own core.\n *\n * @param options the options to use:\n *          update true to force an update (not use the cached value).\n * @param callback(err, max) called once the operation completes.\n */\nutil.estimateCores = function(options, callback) {\n  if(typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  options = options || {};\n  if('cores' in util && !options.update) {\n    return callback(null, util.cores);\n  }\n  if(typeof navigator !== 'undefined' &&\n    'hardwareConcurrency' in navigator &&\n    navigator.hardwareConcurrency > 0) {\n    util.cores = navigator.hardwareConcurrency;\n    return callback(null, util.cores);\n  }\n  if(typeof Worker === 'undefined') {\n    // workers not available\n    util.cores = 1;\n    return callback(null, util.cores);\n  }\n  if(typeof Blob === 'undefined') {\n    // can't estimate, default to 2\n    util.cores = 2;\n    return callback(null, util.cores);\n  }\n\n  // create worker concurrency estimation code as blob\n  var blobUrl = URL.createObjectURL(new Blob(['(',\n    function() {\n      self.addEventListener('message', function(e) {\n        // run worker for 4 ms\n        var st = Date.now();\n        var et = st + 4;\n        while(Date.now() < et);\n        self.postMessage({st: st, et: et});\n      });\n    }.toString(),\n  ')()'], {type: 'application/javascript'}));\n\n  // take 5 samples using 16 workers\n  sample([], 5, 16);\n\n  function sample(max, samples, numWorkers) {\n    if(samples === 0) {\n      // get overlap average\n      var avg = Math.floor(max.reduce(function(avg, x) {\n        return avg + x;\n      }, 0) / max.length);\n      util.cores = Math.max(1, avg);\n      URL.revokeObjectURL(blobUrl);\n      return callback(null, util.cores);\n    }\n    map(numWorkers, function(err, results) {\n      max.push(reduce(numWorkers, results));\n      sample(max, samples - 1, numWorkers);\n    });\n  }\n\n  function map(numWorkers, callback) {\n    var workers = [];\n    var results = [];\n    for(var i = 0; i < numWorkers; ++i) {\n      var worker = new Worker(blobUrl);\n      worker.addEventListener('message', function(e) {\n        results.push(e.data);\n        if(results.length === numWorkers) {\n          for(var i = 0; i < numWorkers; ++i) {\n            workers[i].terminate();\n          }\n          callback(null, results);\n        }\n      });\n      workers.push(worker);\n    }\n    for(var i = 0; i < numWorkers; ++i) {\n      workers[i].postMessage(i);\n    }\n  }\n\n  function reduce(numWorkers, results) {\n    // find overlapping time windows\n    var overlaps = [];\n    for(var n = 0; n < numWorkers; ++n) {\n      var r1 = results[n];\n      var overlap = overlaps[n] = [];\n      for(var i = 0; i < numWorkers; ++i) {\n        if(n === i) {\n          continue;\n        }\n        var r2 = results[i];\n        if((r1.st > r2.st && r1.st < r2.et) ||\n          (r2.st > r1.st && r2.st < r1.et)) {\n          overlap.push(i);\n        }\n      }\n    }\n    // get maximum overlaps ... don't include overlapping worker itself\n    // as the main JS process was also being scheduled during the work and\n    // would have to be subtracted from the estimate anyway\n    return overlaps.reduce(function(max, overlap) {\n      return Math.max(max, overlap.length);\n    }, 0);\n  }\n};\n"],"sourceRoot":""}