{"version":3,"sources":["webpack:///./node_modules/node-forge/lib/kem.js","webpack:///./node_modules/node-forge/lib/pbkdf2.js","webpack:///./node_modules/node-forge/lib/pbe.js","webpack:///./node_modules/node-forge/lib/mgf1.js","webpack:///./node_modules/node-forge/lib/mgf.js","webpack:///./node_modules/node-forge/lib/md.all.js","webpack:///./node_modules/node-forge/lib/log.js","webpack:///./node_modules/node-forge/lib/pkcs7.js","webpack:///./node_modules/node-forge/lib/pem.js","webpack:///./node_modules/node-forge/lib/md5.js","webpack:///./node_modules/node-forge/lib/pkcs1.js","webpack:///./node_modules/node-forge/lib/pkcs12.js","webpack:///./node_modules/node-forge/lib/md.js","webpack:///./node_modules/node-forge/lib/pkcs7asn1.js","webpack:///./node_modules/node-forge/lib/oids.js"],"names":["forge","module","exports","kem","BigInteger","jsbn","_createKDF","kdf","md","counterStart","digestLength","generate","x","length","key","util","ByteBuffer","k","Math","ceil","c","i","putInt32","start","update","getBytes","hash","digest","putBytes","truncate","rsa","create","options","prng","random","publicKey","keyLength","r","byteLength","n","bitLength","bytesToHex","getBytesSync","mod","compareTo","ONE","hexToBytes","toString","zeros","fillString","String","fromCharCode","encapsulation","encrypt","privateKey","decrypt","kdf1","this","kdf2","crypto","pkcs5","isNodejs","usePureJavaScript","pbkdf2","p","s","dkLen","callback","pbkdf2Sync","Buffer","from","err","algorithms","Error","hLen","len","prf","hmac","xor","u_c","u_c1","dk","int32ToBytes","j","xorBytes","substr","outer","inner","setImmediate","asn1","pki","pbe","oids","encryptedPrivateKeyValidator","name","tagClass","Class","UNIVERSAL","type","Type","SEQUENCE","constructed","value","OID","capture","captureAsn1","OCTETSTRING","PBES2AlgorithmsValidator","INTEGER","optional","pkcs12PbeParamsValidator","bytes","prfOidToMessageDigest","prfOid","prfAlgorithm","derToOid","error","oid","supported","prfAlgorithmToMessageDigest","factory","sha512","toLowerCase","algorithm","createPbkdf2Params","salt","countBytes","params","push","oidToDer","NULL","encryptPrivateKeyInfo","obj","password","saltSize","count","encryptionAlgorithm","encryptedData","integerToDer","indexOf","ivLen","encOid","cipherFn","aes","createEncryptionCipher","des","toUpperCase","iv","cipher","toDer","finish","output","saltBytes","generatePkcs12Key","rval","decryptPrivateKeyInfo","errors","validate","encryptionOid","getCipher","encryptionParams","encrypted","createBuffer","fromDer","encryptedPrivateKeyToPem","epki","maxline","msg","body","pem","encode","encryptedPrivateKeyFromPem","decode","headerType","procType","encryptRsaPrivateKey","rsaKey","legacy","wrapRsaPrivateKey","privateKeyToAsn1","opensslDeriveBytes","version","dekInfo","parameters","decryptRsaPrivateKey","createDecryptionCipher","rc2","privateKeyFromAsn1","id","iter","l","sha1","u","v","blockLength","result","passBuf","undefined","putInt16","charCodeAt","D","fillWithByte","Slen","S","putByte","at","Plen","P","I","putBuffer","buf","round","B","Inew","chunk","setAt","getCipherForPBES2","getCipherForPKCS12PBE","supportedOids","kdfOid","kdfSalt","kdfIterationCount","getInt","encIv","dIvLen","iterations","startDecrypting","md5","digests","join","mgf","mgf1","seed","maskLen","t","log","levels","sLevelInfo","sLoggers","sConsoleLogger","LEVEL_LOCKED","NO_LEVEL_CHECK","INTERPOLATE","level","index","logMessage","message","messageLevelIndex","logger","flags","f","loggerLevelIndex","prepareStandard","standard","category","prepareFull","args","concat","full","format","apply","prepareStandardFull","standardFull","Array","prototype","slice","call","arguments","timestamp","Date","makeLogger","logFunction","setLevel","aValidLevel","lock","addLogger","console","warn","info","debug","levelHandlers","warning","verbose","handler","window","location","query","URL","href","searchParams","has","get","consoleLogger","p7","pkcs7","_recipientFromAsn1","recipientInfoValidator","issuer","RDNAttributesAsArray","serialNumber","serial","toHex","encryptedContent","encAlgorithm","parameter","encParameter","content","encKey","_recipientToAsn1","distinguishedNameToAsn1","attributes","_recipientsFromAsn1","infos","ret","_recipientsToAsn1","recipients","_signerToAsn1","digestAlgorithm","authenticatedAttributesAsn1","signatureAlgorithm","signature","unauthenticatedAttributes","attrsAsn1","CONTEXT_SPECIFIC","attr","values","_attributeToAsn1","_signersToAsn1","signers","contentType","messageDigest","signingTime","jan_1_1950","jan_1_2050","date","parse","isNaN","utcTimeToDate","generalizedTimeToDate","UTCTIME","dateToUtcTime","GENERALIZEDTIME","dateToGeneralizedTime","SET","_encryptedContentToAsn1","ec","data","_fromAsn1","validator","isArray","rawCapture","_decryptContent","ciph","messageFromPem","messageFromAsn1","messageToPem","pemObj","toAsn1","contentInfoValidator","envelopedData","createEnvelopedData","createEncryptedData","signedData","createSignedData","fromAsn1","certificates","crls","digestAlgorithmIdentifiers","contentInfo","signerInfos","signedDataValidator","certs","certificateFromAsn1","sign","certificateToAsn1","addSigner","signer","certificate","cert","certificateFromPem","privateKeyFromPem","sha256","sha384","authenticatedAttributes","rsaEncryption","encodeUtf8","detached","detachedContent","mds","addDigestAlgorithmIds","addSignerInfos","verify","addCertificate","addCertificateRevokationList","crl","getByte","getBerValueLength","ai","encryptedDataValidator","envelopedDataValidator","recipientInfos","findRecipient","sAttr","rAttr","match","recipient","privKey","desCBC","addRecipient","keyLen","ciphFn","copy","foldHeader","header","insertSpace","$1","replace","candidate","insert","ltrim","str","contentDomain","headers","encode64","rMessage","rHeader","rCRLF","exec","decode64","lines","split","li","line","nl","next","test","vi","_initialized","_init","_state","_input","_w","messageLength","fullMessageLength","messageLengthSize","messageLength64","int32s","h0","h1","h2","h3","encoding","_update","read","compact","finalBlock","remaining","overflow","_padding","bits","carry","putInt32Le","s2","_g","_r","_k","floor","abs","sin","w","a","b","d","getInt32Le","pkcs1","rsa_mgf1","maskLength","substring","encode_rsa_oaep","label","mgf1Md","maxLength","lHash","PS","PS_length","DB","seedLength","dbMask","maskedDB","seedMask","maskedSeed","decode_rsa_oaep","em","expectedLength","y","charAt","db","lHashPrime","in_ps","code","is_0","error_mask","p12","pkcs12","pfxValidator","safeBagValidator","attributeValidator","certBagValidator","_getBagsByAttribute","safeContents","attrName","attrValue","bagType","safeBags","bag","_decodePkcs7Data","composed","_decodeAuthenticatedSafe","pfx","authSafe","strict","_decryptSafeContents","_decodeSafeContents","encryptedContentAsn1","res","safeBag","decoder","bagId","_decodeBagAttributes","bagAttributes","bagAsn1","bagValue","pkcs8ShroudedKeyBag","keyBag","e","certBag","certId","x509Certificate","certAsn1","decodedAttrs","pkcs12FromAsn1","getBags","filter","localKeyId","localKeyIdHex","friendlyName","getBagsByFriendlyName","getBagsByLocalKeyId","mac","macKeyBytes","macAlgorithm","macSalt","macIterations","parseInt","macKey","generateKey","macValue","getMac","macDigest","toPkcs12Asn1","useMac","generateLocalKeyId","bagAttrs","pairedCert","attrs","BMPSTRING","contents","chain","certSafeBags","certBagAttrs","certSafeBag","certSafeContents","certCI","pkAsn1","keySafeContents","keyCI","macData","safe","p7v","pkcs7asn1","encryptedContentInfoValidator","signerValidator","_IN","_I_"],"mappings":"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","file":"js/chunk-vendors~39e60d0c.0ae87ba8.js","sourcesContent":["/**\n * Javascript implementation of RSA-KEM.\n *\n * @author Lautaro Cozzani Rodriguez\n * @author Dave Longley\n *\n * Copyright (c) 2014 Lautaro Cozzani <lautaro.cozzani@scytl.com>\n * Copyright (c) 2014 Digital Bazaar, Inc.\n */\nvar forge = require('./forge');\nrequire('./util');\nrequire('./random');\nrequire('./jsbn');\n\nmodule.exports = forge.kem = forge.kem || {};\n\nvar BigInteger = forge.jsbn.BigInteger;\n\n/**\n * The API for the RSA Key Encapsulation Mechanism (RSA-KEM) from ISO 18033-2.\n */\nforge.kem.rsa = {};\n\n/**\n * Creates an RSA KEM API object for generating a secret asymmetric key.\n *\n * The symmetric key may be generated via a call to 'encrypt', which will\n * produce a ciphertext to be transmitted to the recipient and a key to be\n * kept secret. The ciphertext is a parameter to be passed to 'decrypt' which\n * will produce the same secret key for the recipient to use to decrypt a\n * message that was encrypted with the secret key.\n *\n * @param kdf the KDF API to use (eg: new forge.kem.kdf1()).\n * @param options the options to use.\n *          [prng] a custom crypto-secure pseudo-random number generator to use,\n *            that must define \"getBytesSync\".\n */\nforge.kem.rsa.create = function(kdf, options) {\n  options = options || {};\n  var prng = options.prng || forge.random;\n\n  var kem = {};\n\n  /**\n   * Generates a secret key and its encapsulation.\n   *\n   * @param publicKey the RSA public key to encrypt with.\n   * @param keyLength the length, in bytes, of the secret key to generate.\n   *\n   * @return an object with:\n   *   encapsulation: the ciphertext for generating the secret key, as a\n   *     binary-encoded string of bytes.\n   *   key: the secret key to use for encrypting a message.\n   */\n  kem.encrypt = function(publicKey, keyLength) {\n    // generate a random r where 1 < r < n\n    var byteLength = Math.ceil(publicKey.n.bitLength() / 8);\n    var r;\n    do {\n      r = new BigInteger(\n        forge.util.bytesToHex(prng.getBytesSync(byteLength)),\n        16).mod(publicKey.n);\n    } while(r.compareTo(BigInteger.ONE) <= 0);\n\n    // prepend r with zeros\n    r = forge.util.hexToBytes(r.toString(16));\n    var zeros = byteLength - r.length;\n    if(zeros > 0) {\n      r = forge.util.fillString(String.fromCharCode(0), zeros) + r;\n    }\n\n    // encrypt the random\n    var encapsulation = publicKey.encrypt(r, 'NONE');\n\n    // generate the secret key\n    var key = kdf.generate(r, keyLength);\n\n    return {encapsulation: encapsulation, key: key};\n  };\n\n  /**\n   * Decrypts an encapsulated secret key.\n   *\n   * @param privateKey the RSA private key to decrypt with.\n   * @param encapsulation the ciphertext for generating the secret key, as\n   *          a binary-encoded string of bytes.\n   * @param keyLength the length, in bytes, of the secret key to generate.\n   *\n   * @return the secret key as a binary-encoded string of bytes.\n   */\n  kem.decrypt = function(privateKey, encapsulation, keyLength) {\n    // decrypt the encapsulation and generate the secret key\n    var r = privateKey.decrypt(encapsulation, 'NONE');\n    return kdf.generate(r, keyLength);\n  };\n\n  return kem;\n};\n\n// TODO: add forge.kem.kdf.create('KDF1', {md: ..., ...}) API?\n\n/**\n * Creates a key derivation API object that implements KDF1 per ISO 18033-2.\n *\n * @param md the hash API to use.\n * @param [digestLength] an optional digest length that must be positive and\n *          less than or equal to md.digestLength.\n *\n * @return a KDF1 API object.\n */\nforge.kem.kdf1 = function(md, digestLength) {\n  _createKDF(this, md, 0, digestLength || md.digestLength);\n};\n\n/**\n * Creates a key derivation API object that implements KDF2 per ISO 18033-2.\n *\n * @param md the hash API to use.\n * @param [digestLength] an optional digest length that must be positive and\n *          less than or equal to md.digestLength.\n *\n * @return a KDF2 API object.\n */\nforge.kem.kdf2 = function(md, digestLength) {\n  _createKDF(this, md, 1, digestLength || md.digestLength);\n};\n\n/**\n * Creates a KDF1 or KDF2 API object.\n *\n * @param md the hash API to use.\n * @param counterStart the starting index for the counter.\n * @param digestLength the digest length to use.\n *\n * @return the KDF API object.\n */\nfunction _createKDF(kdf, md, counterStart, digestLength) {\n  /**\n   * Generate a key of the specified length.\n   *\n   * @param x the binary-encoded byte string to generate a key from.\n   * @param length the number of bytes to generate (the size of the key).\n   *\n   * @return the key as a binary-encoded string.\n   */\n  kdf.generate = function(x, length) {\n    var key = new forge.util.ByteBuffer();\n\n    // run counter from counterStart to ceil(length / Hash.len)\n    var k = Math.ceil(length / digestLength) + counterStart;\n\n    var c = new forge.util.ByteBuffer();\n    for(var i = counterStart; i < k; ++i) {\n      // I2OSP(i, 4): convert counter to an octet string of 4 octets\n      c.putInt32(i);\n\n      // digest 'x' and the counter and add the result to the key\n      md.start();\n      md.update(x + c.getBytes());\n      var hash = md.digest();\n      key.putBytes(hash.getBytes(digestLength));\n    }\n\n    // truncate to the correct key length\n    key.truncate(key.length() - length);\n    return key.getBytes();\n  };\n}\n","/**\n * Password-Based Key-Derivation Function #2 implementation.\n *\n * See RFC 2898 for details.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2010-2013 Digital Bazaar, Inc.\n */\nvar forge = require('./forge');\nrequire('./hmac');\nrequire('./md');\nrequire('./util');\n\nvar pkcs5 = forge.pkcs5 = forge.pkcs5 || {};\n\nvar crypto;\nif(forge.util.isNodejs && !forge.options.usePureJavaScript) {\n  crypto = require('crypto');\n}\n\n/**\n * Derives a key from a password.\n *\n * @param p the password as a binary-encoded string of bytes.\n * @param s the salt as a binary-encoded string of bytes.\n * @param c the iteration count, a positive integer.\n * @param dkLen the intended length, in bytes, of the derived key,\n *          (max: 2^32 - 1) * hash length of the PRF.\n * @param [md] the message digest (or algorithm identifier as a string) to use\n *          in the PRF, defaults to SHA-1.\n * @param [callback(err, key)] presence triggers asynchronous version, called\n *          once the operation completes.\n *\n * @return the derived key, as a binary-encoded string of bytes, for the\n *           synchronous version (if no callback is specified).\n */\nmodule.exports = forge.pbkdf2 = pkcs5.pbkdf2 = function(\n  p, s, c, dkLen, md, callback) {\n  if(typeof md === 'function') {\n    callback = md;\n    md = null;\n  }\n\n  // use native implementation if possible and not disabled, note that\n  // some node versions only support SHA-1, others allow digest to be changed\n  if(forge.util.isNodejs && !forge.options.usePureJavaScript &&\n    crypto.pbkdf2 && (md === null || typeof md !== 'object') &&\n    (crypto.pbkdf2Sync.length > 4 || (!md || md === 'sha1'))) {\n    if(typeof md !== 'string') {\n      // default prf to SHA-1\n      md = 'sha1';\n    }\n    p = Buffer.from(p, 'binary');\n    s = Buffer.from(s, 'binary');\n    if(!callback) {\n      if(crypto.pbkdf2Sync.length === 4) {\n        return crypto.pbkdf2Sync(p, s, c, dkLen).toString('binary');\n      }\n      return crypto.pbkdf2Sync(p, s, c, dkLen, md).toString('binary');\n    }\n    if(crypto.pbkdf2Sync.length === 4) {\n      return crypto.pbkdf2(p, s, c, dkLen, function(err, key) {\n        if(err) {\n          return callback(err);\n        }\n        callback(null, key.toString('binary'));\n      });\n    }\n    return crypto.pbkdf2(p, s, c, dkLen, md, function(err, key) {\n      if(err) {\n        return callback(err);\n      }\n      callback(null, key.toString('binary'));\n    });\n  }\n\n  if(typeof md === 'undefined' || md === null) {\n    // default prf to SHA-1\n    md = 'sha1';\n  }\n  if(typeof md === 'string') {\n    if(!(md in forge.md.algorithms)) {\n      throw new Error('Unknown hash algorithm: ' + md);\n    }\n    md = forge.md[md].create();\n  }\n\n  var hLen = md.digestLength;\n\n  /* 1. If dkLen > (2^32 - 1) * hLen, output \"derived key too long\" and\n    stop. */\n  if(dkLen > (0xFFFFFFFF * hLen)) {\n    var err = new Error('Derived key is too long.');\n    if(callback) {\n      return callback(err);\n    }\n    throw err;\n  }\n\n  /* 2. Let len be the number of hLen-octet blocks in the derived key,\n    rounding up, and let r be the number of octets in the last\n    block:\n\n    len = CEIL(dkLen / hLen),\n    r = dkLen - (len - 1) * hLen. */\n  var len = Math.ceil(dkLen / hLen);\n  var r = dkLen - (len - 1) * hLen;\n\n  /* 3. For each block of the derived key apply the function F defined\n    below to the password P, the salt S, the iteration count c, and\n    the block index to compute the block:\n\n    T_1 = F(P, S, c, 1),\n    T_2 = F(P, S, c, 2),\n    ...\n    T_len = F(P, S, c, len),\n\n    where the function F is defined as the exclusive-or sum of the\n    first c iterates of the underlying pseudorandom function PRF\n    applied to the password P and the concatenation of the salt S\n    and the block index i:\n\n    F(P, S, c, i) = u_1 XOR u_2 XOR ... XOR u_c\n\n    where\n\n    u_1 = PRF(P, S || INT(i)),\n    u_2 = PRF(P, u_1),\n    ...\n    u_c = PRF(P, u_{c-1}).\n\n    Here, INT(i) is a four-octet encoding of the integer i, most\n    significant octet first. */\n  var prf = forge.hmac.create();\n  prf.start(md, p);\n  var dk = '';\n  var xor, u_c, u_c1;\n\n  // sync version\n  if(!callback) {\n    for(var i = 1; i <= len; ++i) {\n      // PRF(P, S || INT(i)) (first iteration)\n      prf.start(null, null);\n      prf.update(s);\n      prf.update(forge.util.int32ToBytes(i));\n      xor = u_c1 = prf.digest().getBytes();\n\n      // PRF(P, u_{c-1}) (other iterations)\n      for(var j = 2; j <= c; ++j) {\n        prf.start(null, null);\n        prf.update(u_c1);\n        u_c = prf.digest().getBytes();\n        // F(p, s, c, i)\n        xor = forge.util.xorBytes(xor, u_c, hLen);\n        u_c1 = u_c;\n      }\n\n      /* 4. Concatenate the blocks and extract the first dkLen octets to\n        produce a derived key DK:\n\n        DK = T_1 || T_2 ||  ...  || T_len<0..r-1> */\n      dk += (i < len) ? xor : xor.substr(0, r);\n    }\n    /* 5. Output the derived key DK. */\n    return dk;\n  }\n\n  // async version\n  var i = 1, j;\n  function outer() {\n    if(i > len) {\n      // done\n      return callback(null, dk);\n    }\n\n    // PRF(P, S || INT(i)) (first iteration)\n    prf.start(null, null);\n    prf.update(s);\n    prf.update(forge.util.int32ToBytes(i));\n    xor = u_c1 = prf.digest().getBytes();\n\n    // PRF(P, u_{c-1}) (other iterations)\n    j = 2;\n    inner();\n  }\n\n  function inner() {\n    if(j <= c) {\n      prf.start(null, null);\n      prf.update(u_c1);\n      u_c = prf.digest().getBytes();\n      // F(p, s, c, i)\n      xor = forge.util.xorBytes(xor, u_c, hLen);\n      u_c1 = u_c;\n      ++j;\n      return forge.util.setImmediate(inner);\n    }\n\n    /* 4. Concatenate the blocks and extract the first dkLen octets to\n      produce a derived key DK:\n\n      DK = T_1 || T_2 ||  ...  || T_len<0..r-1> */\n    dk += (i < len) ? xor : xor.substr(0, r);\n\n    ++i;\n    outer();\n  }\n\n  outer();\n};\n","/**\n * Password-based encryption functions.\n *\n * @author Dave Longley\n * @author Stefan Siegl <stesie@brokenpipe.de>\n *\n * Copyright (c) 2010-2013 Digital Bazaar, Inc.\n * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>\n *\n * An EncryptedPrivateKeyInfo:\n *\n * EncryptedPrivateKeyInfo ::= SEQUENCE {\n *   encryptionAlgorithm  EncryptionAlgorithmIdentifier,\n *   encryptedData        EncryptedData }\n *\n * EncryptionAlgorithmIdentifier ::= AlgorithmIdentifier\n *\n * EncryptedData ::= OCTET STRING\n */\nvar forge = require('./forge');\nrequire('./aes');\nrequire('./asn1');\nrequire('./des');\nrequire('./md');\nrequire('./oids');\nrequire('./pbkdf2');\nrequire('./pem');\nrequire('./random');\nrequire('./rc2');\nrequire('./rsa');\nrequire('./util');\n\nif(typeof BigInteger === 'undefined') {\n  var BigInteger = forge.jsbn.BigInteger;\n}\n\n// shortcut for asn.1 API\nvar asn1 = forge.asn1;\n\n/* Password-based encryption implementation. */\nvar pki = forge.pki = forge.pki || {};\nmodule.exports = pki.pbe = forge.pbe = forge.pbe || {};\nvar oids = pki.oids;\n\n// validator for an EncryptedPrivateKeyInfo structure\n// Note: Currently only works w/algorithm params\nvar encryptedPrivateKeyValidator = {\n  name: 'EncryptedPrivateKeyInfo',\n  tagClass: asn1.Class.UNIVERSAL,\n  type: asn1.Type.SEQUENCE,\n  constructed: true,\n  value: [{\n    name: 'EncryptedPrivateKeyInfo.encryptionAlgorithm',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SEQUENCE,\n    constructed: true,\n    value: [{\n      name: 'AlgorithmIdentifier.algorithm',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.OID,\n      constructed: false,\n      capture: 'encryptionOid'\n    }, {\n      name: 'AlgorithmIdentifier.parameters',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.SEQUENCE,\n      constructed: true,\n      captureAsn1: 'encryptionParams'\n    }]\n  }, {\n    // encryptedData\n    name: 'EncryptedPrivateKeyInfo.encryptedData',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.OCTETSTRING,\n    constructed: false,\n    capture: 'encryptedData'\n  }]\n};\n\n// validator for a PBES2Algorithms structure\n// Note: Currently only works w/PBKDF2 + AES encryption schemes\nvar PBES2AlgorithmsValidator = {\n  name: 'PBES2Algorithms',\n  tagClass: asn1.Class.UNIVERSAL,\n  type: asn1.Type.SEQUENCE,\n  constructed: true,\n  value: [{\n    name: 'PBES2Algorithms.keyDerivationFunc',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SEQUENCE,\n    constructed: true,\n    value: [{\n      name: 'PBES2Algorithms.keyDerivationFunc.oid',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.OID,\n      constructed: false,\n      capture: 'kdfOid'\n    }, {\n      name: 'PBES2Algorithms.params',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.SEQUENCE,\n      constructed: true,\n      value: [{\n        name: 'PBES2Algorithms.params.salt',\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.OCTETSTRING,\n        constructed: false,\n        capture: 'kdfSalt'\n      }, {\n        name: 'PBES2Algorithms.params.iterationCount',\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.INTEGER,\n        constructed: false,\n        capture: 'kdfIterationCount'\n      }, {\n        name: 'PBES2Algorithms.params.keyLength',\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.INTEGER,\n        constructed: false,\n        optional: true,\n        capture: 'keyLength'\n      }, {\n        // prf\n        name: 'PBES2Algorithms.params.prf',\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.SEQUENCE,\n        constructed: true,\n        optional: true,\n        value: [{\n          name: 'PBES2Algorithms.params.prf.algorithm',\n          tagClass: asn1.Class.UNIVERSAL,\n          type: asn1.Type.OID,\n          constructed: false,\n          capture: 'prfOid'\n        }]\n      }]\n    }]\n  }, {\n    name: 'PBES2Algorithms.encryptionScheme',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SEQUENCE,\n    constructed: true,\n    value: [{\n      name: 'PBES2Algorithms.encryptionScheme.oid',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.OID,\n      constructed: false,\n      capture: 'encOid'\n    }, {\n      name: 'PBES2Algorithms.encryptionScheme.iv',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.OCTETSTRING,\n      constructed: false,\n      capture: 'encIv'\n    }]\n  }]\n};\n\nvar pkcs12PbeParamsValidator = {\n  name: 'pkcs-12PbeParams',\n  tagClass: asn1.Class.UNIVERSAL,\n  type: asn1.Type.SEQUENCE,\n  constructed: true,\n  value: [{\n    name: 'pkcs-12PbeParams.salt',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.OCTETSTRING,\n    constructed: false,\n    capture: 'salt'\n  }, {\n    name: 'pkcs-12PbeParams.iterations',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.INTEGER,\n    constructed: false,\n    capture: 'iterations'\n  }]\n};\n\n/**\n * Encrypts a ASN.1 PrivateKeyInfo object, producing an EncryptedPrivateKeyInfo.\n *\n * PBES2Algorithms ALGORITHM-IDENTIFIER ::=\n *   { {PBES2-params IDENTIFIED BY id-PBES2}, ...}\n *\n * id-PBES2 OBJECT IDENTIFIER ::= {pkcs-5 13}\n *\n * PBES2-params ::= SEQUENCE {\n *   keyDerivationFunc AlgorithmIdentifier {{PBES2-KDFs}},\n *   encryptionScheme AlgorithmIdentifier {{PBES2-Encs}}\n * }\n *\n * PBES2-KDFs ALGORITHM-IDENTIFIER ::=\n *   { {PBKDF2-params IDENTIFIED BY id-PBKDF2}, ... }\n *\n * PBES2-Encs ALGORITHM-IDENTIFIER ::= { ... }\n *\n * PBKDF2-params ::= SEQUENCE {\n *   salt CHOICE {\n *     specified OCTET STRING,\n *     otherSource AlgorithmIdentifier {{PBKDF2-SaltSources}}\n *   },\n *   iterationCount INTEGER (1..MAX),\n *   keyLength INTEGER (1..MAX) OPTIONAL,\n *   prf AlgorithmIdentifier {{PBKDF2-PRFs}} DEFAULT algid-hmacWithSHA1\n * }\n *\n * @param obj the ASN.1 PrivateKeyInfo object.\n * @param password the password to encrypt with.\n * @param options:\n *          algorithm the encryption algorithm to use\n *            ('aes128', 'aes192', 'aes256', '3des'), defaults to 'aes128'.\n *          count the iteration count to use.\n *          saltSize the salt size to use.\n *          prfAlgorithm the PRF message digest algorithm to use\n *            ('sha1', 'sha224', 'sha256', 'sha384', 'sha512')\n *\n * @return the ASN.1 EncryptedPrivateKeyInfo.\n */\npki.encryptPrivateKeyInfo = function(obj, password, options) {\n  // set default options\n  options = options || {};\n  options.saltSize = options.saltSize || 8;\n  options.count = options.count || 2048;\n  options.algorithm = options.algorithm || 'aes128';\n  options.prfAlgorithm = options.prfAlgorithm || 'sha1';\n\n  // generate PBE params\n  var salt = forge.random.getBytesSync(options.saltSize);\n  var count = options.count;\n  var countBytes = asn1.integerToDer(count);\n  var dkLen;\n  var encryptionAlgorithm;\n  var encryptedData;\n  if(options.algorithm.indexOf('aes') === 0 || options.algorithm === 'des') {\n    // do PBES2\n    var ivLen, encOid, cipherFn;\n    switch(options.algorithm) {\n    case 'aes128':\n      dkLen = 16;\n      ivLen = 16;\n      encOid = oids['aes128-CBC'];\n      cipherFn = forge.aes.createEncryptionCipher;\n      break;\n    case 'aes192':\n      dkLen = 24;\n      ivLen = 16;\n      encOid = oids['aes192-CBC'];\n      cipherFn = forge.aes.createEncryptionCipher;\n      break;\n    case 'aes256':\n      dkLen = 32;\n      ivLen = 16;\n      encOid = oids['aes256-CBC'];\n      cipherFn = forge.aes.createEncryptionCipher;\n      break;\n    case 'des':\n      dkLen = 8;\n      ivLen = 8;\n      encOid = oids['desCBC'];\n      cipherFn = forge.des.createEncryptionCipher;\n      break;\n    default:\n      var error = new Error('Cannot encrypt private key. Unknown encryption algorithm.');\n      error.algorithm = options.algorithm;\n      throw error;\n    }\n\n    // get PRF message digest\n    var prfAlgorithm = 'hmacWith' + options.prfAlgorithm.toUpperCase();\n    var md = prfAlgorithmToMessageDigest(prfAlgorithm);\n\n    // encrypt private key using pbe SHA-1 and AES/DES\n    var dk = forge.pkcs5.pbkdf2(password, salt, count, dkLen, md);\n    var iv = forge.random.getBytesSync(ivLen);\n    var cipher = cipherFn(dk);\n    cipher.start(iv);\n    cipher.update(asn1.toDer(obj));\n    cipher.finish();\n    encryptedData = cipher.output.getBytes();\n\n    // get PBKDF2-params\n    var params = createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm);\n\n    encryptionAlgorithm = asn1.create(\n      asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\n        asn1.oidToDer(oids['pkcs5PBES2']).getBytes()),\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n        // keyDerivationFunc\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\n            asn1.oidToDer(oids['pkcs5PBKDF2']).getBytes()),\n          // PBKDF2-params\n          params\n        ]),\n        // encryptionScheme\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\n            asn1.oidToDer(encOid).getBytes()),\n          // iv\n          asn1.create(\n            asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, iv)\n        ])\n      ])\n    ]);\n  } else if(options.algorithm === '3des') {\n    // Do PKCS12 PBE\n    dkLen = 24;\n\n    var saltBytes = new forge.util.ByteBuffer(salt);\n    var dk = pki.pbe.generatePkcs12Key(password, saltBytes, 1, count, dkLen);\n    var iv = pki.pbe.generatePkcs12Key(password, saltBytes, 2, count, dkLen);\n    var cipher = forge.des.createEncryptionCipher(dk);\n    cipher.start(iv);\n    cipher.update(asn1.toDer(obj));\n    cipher.finish();\n    encryptedData = cipher.output.getBytes();\n\n    encryptionAlgorithm = asn1.create(\n      asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\n        asn1.oidToDer(oids['pbeWithSHAAnd3-KeyTripleDES-CBC']).getBytes()),\n      // pkcs-12PbeParams\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n        // salt\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, salt),\n        // iteration count\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\n          countBytes.getBytes())\n      ])\n    ]);\n  } else {\n    var error = new Error('Cannot encrypt private key. Unknown encryption algorithm.');\n    error.algorithm = options.algorithm;\n    throw error;\n  }\n\n  // EncryptedPrivateKeyInfo\n  var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n    // encryptionAlgorithm\n    encryptionAlgorithm,\n    // encryptedData\n    asn1.create(\n      asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, encryptedData)\n  ]);\n  return rval;\n};\n\n/**\n * Decrypts a ASN.1 PrivateKeyInfo object.\n *\n * @param obj the ASN.1 EncryptedPrivateKeyInfo object.\n * @param password the password to decrypt with.\n *\n * @return the ASN.1 PrivateKeyInfo on success, null on failure.\n */\npki.decryptPrivateKeyInfo = function(obj, password) {\n  var rval = null;\n\n  // get PBE params\n  var capture = {};\n  var errors = [];\n  if(!asn1.validate(obj, encryptedPrivateKeyValidator, capture, errors)) {\n    var error = new Error('Cannot read encrypted private key. ' +\n      'ASN.1 object is not a supported EncryptedPrivateKeyInfo.');\n    error.errors = errors;\n    throw error;\n  }\n\n  // get cipher\n  var oid = asn1.derToOid(capture.encryptionOid);\n  var cipher = pki.pbe.getCipher(oid, capture.encryptionParams, password);\n\n  // get encrypted data\n  var encrypted = forge.util.createBuffer(capture.encryptedData);\n\n  cipher.update(encrypted);\n  if(cipher.finish()) {\n    rval = asn1.fromDer(cipher.output);\n  }\n\n  return rval;\n};\n\n/**\n * Converts a EncryptedPrivateKeyInfo to PEM format.\n *\n * @param epki the EncryptedPrivateKeyInfo.\n * @param maxline the maximum characters per line, defaults to 64.\n *\n * @return the PEM-formatted encrypted private key.\n */\npki.encryptedPrivateKeyToPem = function(epki, maxline) {\n  // convert to DER, then PEM-encode\n  var msg = {\n    type: 'ENCRYPTED PRIVATE KEY',\n    body: asn1.toDer(epki).getBytes()\n  };\n  return forge.pem.encode(msg, {maxline: maxline});\n};\n\n/**\n * Converts a PEM-encoded EncryptedPrivateKeyInfo to ASN.1 format. Decryption\n * is not performed.\n *\n * @param pem the EncryptedPrivateKeyInfo in PEM-format.\n *\n * @return the ASN.1 EncryptedPrivateKeyInfo.\n */\npki.encryptedPrivateKeyFromPem = function(pem) {\n  var msg = forge.pem.decode(pem)[0];\n\n  if(msg.type !== 'ENCRYPTED PRIVATE KEY') {\n    var error = new Error('Could not convert encrypted private key from PEM; ' +\n      'PEM header type is \"ENCRYPTED PRIVATE KEY\".');\n    error.headerType = msg.type;\n    throw error;\n  }\n  if(msg.procType && msg.procType.type === 'ENCRYPTED') {\n    throw new Error('Could not convert encrypted private key from PEM; ' +\n      'PEM is encrypted.');\n  }\n\n  // convert DER to ASN.1 object\n  return asn1.fromDer(msg.body);\n};\n\n/**\n * Encrypts an RSA private key. By default, the key will be wrapped in\n * a PrivateKeyInfo and encrypted to produce a PKCS#8 EncryptedPrivateKeyInfo.\n * This is the standard, preferred way to encrypt a private key.\n *\n * To produce a non-standard PEM-encrypted private key that uses encapsulated\n * headers to indicate the encryption algorithm (old-style non-PKCS#8 OpenSSL\n * private key encryption), set the 'legacy' option to true. Note: Using this\n * option will cause the iteration count to be forced to 1.\n *\n * Note: The 'des' algorithm is supported, but it is not considered to be\n * secure because it only uses a single 56-bit key. If possible, it is highly\n * recommended that a different algorithm be used.\n *\n * @param rsaKey the RSA key to encrypt.\n * @param password the password to use.\n * @param options:\n *          algorithm: the encryption algorithm to use\n *            ('aes128', 'aes192', 'aes256', '3des', 'des').\n *          count: the iteration count to use.\n *          saltSize: the salt size to use.\n *          legacy: output an old non-PKCS#8 PEM-encrypted+encapsulated\n *            headers (DEK-Info) private key.\n *\n * @return the PEM-encoded ASN.1 EncryptedPrivateKeyInfo.\n */\npki.encryptRsaPrivateKey = function(rsaKey, password, options) {\n  // standard PKCS#8\n  options = options || {};\n  if(!options.legacy) {\n    // encrypt PrivateKeyInfo\n    var rval = pki.wrapRsaPrivateKey(pki.privateKeyToAsn1(rsaKey));\n    rval = pki.encryptPrivateKeyInfo(rval, password, options);\n    return pki.encryptedPrivateKeyToPem(rval);\n  }\n\n  // legacy non-PKCS#8\n  var algorithm;\n  var iv;\n  var dkLen;\n  var cipherFn;\n  switch(options.algorithm) {\n  case 'aes128':\n    algorithm = 'AES-128-CBC';\n    dkLen = 16;\n    iv = forge.random.getBytesSync(16);\n    cipherFn = forge.aes.createEncryptionCipher;\n    break;\n  case 'aes192':\n    algorithm = 'AES-192-CBC';\n    dkLen = 24;\n    iv = forge.random.getBytesSync(16);\n    cipherFn = forge.aes.createEncryptionCipher;\n    break;\n  case 'aes256':\n    algorithm = 'AES-256-CBC';\n    dkLen = 32;\n    iv = forge.random.getBytesSync(16);\n    cipherFn = forge.aes.createEncryptionCipher;\n    break;\n  case '3des':\n    algorithm = 'DES-EDE3-CBC';\n    dkLen = 24;\n    iv = forge.random.getBytesSync(8);\n    cipherFn = forge.des.createEncryptionCipher;\n    break;\n  case 'des':\n    algorithm = 'DES-CBC';\n    dkLen = 8;\n    iv = forge.random.getBytesSync(8);\n    cipherFn = forge.des.createEncryptionCipher;\n    break;\n  default:\n    var error = new Error('Could not encrypt RSA private key; unsupported ' +\n      'encryption algorithm \"' + options.algorithm + '\".');\n    error.algorithm = options.algorithm;\n    throw error;\n  }\n\n  // encrypt private key using OpenSSL legacy key derivation\n  var dk = forge.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen);\n  var cipher = cipherFn(dk);\n  cipher.start(iv);\n  cipher.update(asn1.toDer(pki.privateKeyToAsn1(rsaKey)));\n  cipher.finish();\n\n  var msg = {\n    type: 'RSA PRIVATE KEY',\n    procType: {\n      version: '4',\n      type: 'ENCRYPTED'\n    },\n    dekInfo: {\n      algorithm: algorithm,\n      parameters: forge.util.bytesToHex(iv).toUpperCase()\n    },\n    body: cipher.output.getBytes()\n  };\n  return forge.pem.encode(msg);\n};\n\n/**\n * Decrypts an RSA private key.\n *\n * @param pem the PEM-formatted EncryptedPrivateKeyInfo to decrypt.\n * @param password the password to use.\n *\n * @return the RSA key on success, null on failure.\n */\npki.decryptRsaPrivateKey = function(pem, password) {\n  var rval = null;\n\n  var msg = forge.pem.decode(pem)[0];\n\n  if(msg.type !== 'ENCRYPTED PRIVATE KEY' &&\n    msg.type !== 'PRIVATE KEY' &&\n    msg.type !== 'RSA PRIVATE KEY') {\n    var error = new Error('Could not convert private key from PEM; PEM header type ' +\n      'is not \"ENCRYPTED PRIVATE KEY\", \"PRIVATE KEY\", or \"RSA PRIVATE KEY\".');\n    error.headerType = error;\n    throw error;\n  }\n\n  if(msg.procType && msg.procType.type === 'ENCRYPTED') {\n    var dkLen;\n    var cipherFn;\n    switch(msg.dekInfo.algorithm) {\n    case 'DES-CBC':\n      dkLen = 8;\n      cipherFn = forge.des.createDecryptionCipher;\n      break;\n    case 'DES-EDE3-CBC':\n      dkLen = 24;\n      cipherFn = forge.des.createDecryptionCipher;\n      break;\n    case 'AES-128-CBC':\n      dkLen = 16;\n      cipherFn = forge.aes.createDecryptionCipher;\n      break;\n    case 'AES-192-CBC':\n      dkLen = 24;\n      cipherFn = forge.aes.createDecryptionCipher;\n      break;\n    case 'AES-256-CBC':\n      dkLen = 32;\n      cipherFn = forge.aes.createDecryptionCipher;\n      break;\n    case 'RC2-40-CBC':\n      dkLen = 5;\n      cipherFn = function(key) {\n        return forge.rc2.createDecryptionCipher(key, 40);\n      };\n      break;\n    case 'RC2-64-CBC':\n      dkLen = 8;\n      cipherFn = function(key) {\n        return forge.rc2.createDecryptionCipher(key, 64);\n      };\n      break;\n    case 'RC2-128-CBC':\n      dkLen = 16;\n      cipherFn = function(key) {\n        return forge.rc2.createDecryptionCipher(key, 128);\n      };\n      break;\n    default:\n      var error = new Error('Could not decrypt private key; unsupported ' +\n        'encryption algorithm \"' + msg.dekInfo.algorithm + '\".');\n      error.algorithm = msg.dekInfo.algorithm;\n      throw error;\n    }\n\n    // use OpenSSL legacy key derivation\n    var iv = forge.util.hexToBytes(msg.dekInfo.parameters);\n    var dk = forge.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen);\n    var cipher = cipherFn(dk);\n    cipher.start(iv);\n    cipher.update(forge.util.createBuffer(msg.body));\n    if(cipher.finish()) {\n      rval = cipher.output.getBytes();\n    } else {\n      return rval;\n    }\n  } else {\n    rval = msg.body;\n  }\n\n  if(msg.type === 'ENCRYPTED PRIVATE KEY') {\n    rval = pki.decryptPrivateKeyInfo(asn1.fromDer(rval), password);\n  } else {\n    // decryption already performed above\n    rval = asn1.fromDer(rval);\n  }\n\n  if(rval !== null) {\n    rval = pki.privateKeyFromAsn1(rval);\n  }\n\n  return rval;\n};\n\n/**\n * Derives a PKCS#12 key.\n *\n * @param password the password to derive the key material from, null or\n *          undefined for none.\n * @param salt the salt, as a ByteBuffer, to use.\n * @param id the PKCS#12 ID byte (1 = key material, 2 = IV, 3 = MAC).\n * @param iter the iteration count.\n * @param n the number of bytes to derive from the password.\n * @param md the message digest to use, defaults to SHA-1.\n *\n * @return a ByteBuffer with the bytes derived from the password.\n */\npki.pbe.generatePkcs12Key = function(password, salt, id, iter, n, md) {\n  var j, l;\n\n  if(typeof md === 'undefined' || md === null) {\n    if(!('sha1' in forge.md)) {\n      throw new Error('\"sha1\" hash algorithm unavailable.');\n    }\n    md = forge.md.sha1.create();\n  }\n\n  var u = md.digestLength;\n  var v = md.blockLength;\n  var result = new forge.util.ByteBuffer();\n\n  /* Convert password to Unicode byte buffer + trailing 0-byte. */\n  var passBuf = new forge.util.ByteBuffer();\n  if(password !== null && password !== undefined) {\n    for(l = 0; l < password.length; l++) {\n      passBuf.putInt16(password.charCodeAt(l));\n    }\n    passBuf.putInt16(0);\n  }\n\n  /* Length of salt and password in BYTES. */\n  var p = passBuf.length();\n  var s = salt.length();\n\n  /* 1. Construct a string, D (the \"diversifier\"), by concatenating\n        v copies of ID. */\n  var D = new forge.util.ByteBuffer();\n  D.fillWithByte(id, v);\n\n  /* 2. Concatenate copies of the salt together to create a string S of length\n        v * ceil(s / v) bytes (the final copy of the salt may be trunacted\n        to create S).\n        Note that if the salt is the empty string, then so is S. */\n  var Slen = v * Math.ceil(s / v);\n  var S = new forge.util.ByteBuffer();\n  for(l = 0; l < Slen; l++) {\n    S.putByte(salt.at(l % s));\n  }\n\n  /* 3. Concatenate copies of the password together to create a string P of\n        length v * ceil(p / v) bytes (the final copy of the password may be\n        truncated to create P).\n        Note that if the password is the empty string, then so is P. */\n  var Plen = v * Math.ceil(p / v);\n  var P = new forge.util.ByteBuffer();\n  for(l = 0; l < Plen; l++) {\n    P.putByte(passBuf.at(l % p));\n  }\n\n  /* 4. Set I=S||P to be the concatenation of S and P. */\n  var I = S;\n  I.putBuffer(P);\n\n  /* 5. Set c=ceil(n / u). */\n  var c = Math.ceil(n / u);\n\n  /* 6. For i=1, 2, ..., c, do the following: */\n  for(var i = 1; i <= c; i++) {\n    /* a) Set Ai=H^r(D||I). (l.e. the rth hash of D||I, H(H(H(...H(D||I)))) */\n    var buf = new forge.util.ByteBuffer();\n    buf.putBytes(D.bytes());\n    buf.putBytes(I.bytes());\n    for(var round = 0; round < iter; round++) {\n      md.start();\n      md.update(buf.getBytes());\n      buf = md.digest();\n    }\n\n    /* b) Concatenate copies of Ai to create a string B of length v bytes (the\n          final copy of Ai may be truncated to create B). */\n    var B = new forge.util.ByteBuffer();\n    for(l = 0; l < v; l++) {\n      B.putByte(buf.at(l % u));\n    }\n\n    /* c) Treating I as a concatenation I0, I1, ..., Ik-1 of v-byte blocks,\n          where k=ceil(s / v) + ceil(p / v), modify I by setting\n          Ij=(Ij+B+1) mod 2v for each j.  */\n    var k = Math.ceil(s / v) + Math.ceil(p / v);\n    var Inew = new forge.util.ByteBuffer();\n    for(j = 0; j < k; j++) {\n      var chunk = new forge.util.ByteBuffer(I.getBytes(v));\n      var x = 0x1ff;\n      for(l = B.length() - 1; l >= 0; l--) {\n        x = x >> 8;\n        x += B.at(l) + chunk.at(l);\n        chunk.setAt(l, x & 0xff);\n      }\n      Inew.putBuffer(chunk);\n    }\n    I = Inew;\n\n    /* Add Ai to A. */\n    result.putBuffer(buf);\n  }\n\n  result.truncate(result.length() - n);\n  return result;\n};\n\n/**\n * Get new Forge cipher object instance.\n *\n * @param oid the OID (in string notation).\n * @param params the ASN.1 params object.\n * @param password the password to decrypt with.\n *\n * @return new cipher object instance.\n */\npki.pbe.getCipher = function(oid, params, password) {\n  switch(oid) {\n  case pki.oids['pkcs5PBES2']:\n    return pki.pbe.getCipherForPBES2(oid, params, password);\n\n  case pki.oids['pbeWithSHAAnd3-KeyTripleDES-CBC']:\n  case pki.oids['pbewithSHAAnd40BitRC2-CBC']:\n    return pki.pbe.getCipherForPKCS12PBE(oid, params, password);\n\n  default:\n    var error = new Error('Cannot read encrypted PBE data block. Unsupported OID.');\n    error.oid = oid;\n    error.supportedOids = [\n      'pkcs5PBES2',\n      'pbeWithSHAAnd3-KeyTripleDES-CBC',\n      'pbewithSHAAnd40BitRC2-CBC'\n    ];\n    throw error;\n  }\n};\n\n/**\n * Get new Forge cipher object instance according to PBES2 params block.\n *\n * The returned cipher instance is already started using the IV\n * from PBES2 parameter block.\n *\n * @param oid the PKCS#5 PBKDF2 OID (in string notation).\n * @param params the ASN.1 PBES2-params object.\n * @param password the password to decrypt with.\n *\n * @return new cipher object instance.\n */\npki.pbe.getCipherForPBES2 = function(oid, params, password) {\n  // get PBE params\n  var capture = {};\n  var errors = [];\n  if(!asn1.validate(params, PBES2AlgorithmsValidator, capture, errors)) {\n    var error = new Error('Cannot read password-based-encryption algorithm ' +\n      'parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.');\n    error.errors = errors;\n    throw error;\n  }\n\n  // check oids\n  oid = asn1.derToOid(capture.kdfOid);\n  if(oid !== pki.oids['pkcs5PBKDF2']) {\n    var error = new Error('Cannot read encrypted private key. ' +\n      'Unsupported key derivation function OID.');\n    error.oid = oid;\n    error.supportedOids = ['pkcs5PBKDF2'];\n    throw error;\n  }\n  oid = asn1.derToOid(capture.encOid);\n  if(oid !== pki.oids['aes128-CBC'] &&\n    oid !== pki.oids['aes192-CBC'] &&\n    oid !== pki.oids['aes256-CBC'] &&\n    oid !== pki.oids['des-EDE3-CBC'] &&\n    oid !== pki.oids['desCBC']) {\n    var error = new Error('Cannot read encrypted private key. ' +\n      'Unsupported encryption scheme OID.');\n    error.oid = oid;\n    error.supportedOids = [\n      'aes128-CBC', 'aes192-CBC', 'aes256-CBC', 'des-EDE3-CBC', 'desCBC'];\n    throw error;\n  }\n\n  // set PBE params\n  var salt = capture.kdfSalt;\n  var count = forge.util.createBuffer(capture.kdfIterationCount);\n  count = count.getInt(count.length() << 3);\n  var dkLen;\n  var cipherFn;\n  switch(pki.oids[oid]) {\n  case 'aes128-CBC':\n    dkLen = 16;\n    cipherFn = forge.aes.createDecryptionCipher;\n    break;\n  case 'aes192-CBC':\n    dkLen = 24;\n    cipherFn = forge.aes.createDecryptionCipher;\n    break;\n  case 'aes256-CBC':\n    dkLen = 32;\n    cipherFn = forge.aes.createDecryptionCipher;\n    break;\n  case 'des-EDE3-CBC':\n    dkLen = 24;\n    cipherFn = forge.des.createDecryptionCipher;\n    break;\n  case 'desCBC':\n    dkLen = 8;\n    cipherFn = forge.des.createDecryptionCipher;\n    break;\n  }\n\n  // get PRF message digest\n  var md = prfOidToMessageDigest(capture.prfOid);\n\n  // decrypt private key using pbe with chosen PRF and AES/DES\n  var dk = forge.pkcs5.pbkdf2(password, salt, count, dkLen, md);\n  var iv = capture.encIv;\n  var cipher = cipherFn(dk);\n  cipher.start(iv);\n\n  return cipher;\n};\n\n/**\n * Get new Forge cipher object instance for PKCS#12 PBE.\n *\n * The returned cipher instance is already started using the key & IV\n * derived from the provided password and PKCS#12 PBE salt.\n *\n * @param oid The PKCS#12 PBE OID (in string notation).\n * @param params The ASN.1 PKCS#12 PBE-params object.\n * @param password The password to decrypt with.\n *\n * @return the new cipher object instance.\n */\npki.pbe.getCipherForPKCS12PBE = function(oid, params, password) {\n  // get PBE params\n  var capture = {};\n  var errors = [];\n  if(!asn1.validate(params, pkcs12PbeParamsValidator, capture, errors)) {\n    var error = new Error('Cannot read password-based-encryption algorithm ' +\n      'parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.');\n    error.errors = errors;\n    throw error;\n  }\n\n  var salt = forge.util.createBuffer(capture.salt);\n  var count = forge.util.createBuffer(capture.iterations);\n  count = count.getInt(count.length() << 3);\n\n  var dkLen, dIvLen, cipherFn;\n  switch(oid) {\n    case pki.oids['pbeWithSHAAnd3-KeyTripleDES-CBC']:\n      dkLen = 24;\n      dIvLen = 8;\n      cipherFn = forge.des.startDecrypting;\n      break;\n\n    case pki.oids['pbewithSHAAnd40BitRC2-CBC']:\n      dkLen = 5;\n      dIvLen = 8;\n      cipherFn = function(key, iv) {\n        var cipher = forge.rc2.createDecryptionCipher(key, 40);\n        cipher.start(iv, null);\n        return cipher;\n      };\n      break;\n\n    default:\n      var error = new Error('Cannot read PKCS #12 PBE data block. Unsupported OID.');\n      error.oid = oid;\n      throw error;\n  }\n\n  // get PRF message digest\n  var md = prfOidToMessageDigest(capture.prfOid);\n  var key = pki.pbe.generatePkcs12Key(password, salt, 1, count, dkLen, md);\n  md.start();\n  var iv = pki.pbe.generatePkcs12Key(password, salt, 2, count, dIvLen, md);\n\n  return cipherFn(key, iv);\n};\n\n/**\n * OpenSSL's legacy key derivation function.\n *\n * See: http://www.openssl.org/docs/crypto/EVP_BytesToKey.html\n *\n * @param password the password to derive the key from.\n * @param salt the salt to use, null for none.\n * @param dkLen the number of bytes needed for the derived key.\n * @param [options] the options to use:\n *          [md] an optional message digest object to use.\n */\npki.pbe.opensslDeriveBytes = function(password, salt, dkLen, md) {\n  if(typeof md === 'undefined' || md === null) {\n    if(!('md5' in forge.md)) {\n      throw new Error('\"md5\" hash algorithm unavailable.');\n    }\n    md = forge.md.md5.create();\n  }\n  if(salt === null) {\n    salt = '';\n  }\n  var digests = [hash(md, password + salt)];\n  for(var length = 16, i = 1; length < dkLen; ++i, length += 16) {\n    digests.push(hash(md, digests[i - 1] + password + salt));\n  }\n  return digests.join('').substr(0, dkLen);\n};\n\nfunction hash(md, bytes) {\n  return md.start().update(bytes).digest().getBytes();\n}\n\nfunction prfOidToMessageDigest(prfOid) {\n  // get PRF algorithm, default to SHA-1\n  var prfAlgorithm;\n  if(!prfOid) {\n    prfAlgorithm = 'hmacWithSHA1';\n  } else {\n    prfAlgorithm = pki.oids[asn1.derToOid(prfOid)];\n    if(!prfAlgorithm) {\n      var error = new Error('Unsupported PRF OID.');\n      error.oid = prfOid;\n      error.supported = [\n        'hmacWithSHA1', 'hmacWithSHA224', 'hmacWithSHA256', 'hmacWithSHA384',\n        'hmacWithSHA512'];\n      throw error;\n    }\n  }\n  return prfAlgorithmToMessageDigest(prfAlgorithm);\n}\n\nfunction prfAlgorithmToMessageDigest(prfAlgorithm) {\n  var factory = forge.md;\n  switch(prfAlgorithm) {\n  case 'hmacWithSHA224':\n    factory = forge.md.sha512;\n  case 'hmacWithSHA1':\n  case 'hmacWithSHA256':\n  case 'hmacWithSHA384':\n  case 'hmacWithSHA512':\n    prfAlgorithm = prfAlgorithm.substr(8).toLowerCase();\n    break;\n  default:\n    var error = new Error('Unsupported PRF algorithm.');\n    error.algorithm = prfAlgorithm;\n    error.supported = [\n      'hmacWithSHA1', 'hmacWithSHA224', 'hmacWithSHA256', 'hmacWithSHA384',\n      'hmacWithSHA512'];\n    throw error;\n  }\n  if(!factory || !(prfAlgorithm in factory)) {\n    throw new Error('Unknown hash algorithm: ' + prfAlgorithm);\n  }\n  return factory[prfAlgorithm].create();\n}\n\nfunction createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm) {\n  var params = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n    // salt\n    asn1.create(\n      asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, salt),\n    // iteration count\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\n      countBytes.getBytes())\n  ]);\n  // when PRF algorithm is not SHA-1 default, add key length and PRF algorithm\n  if(prfAlgorithm !== 'hmacWithSHA1') {\n    params.value.push(\n      // key length\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\n        forge.util.hexToBytes(dkLen.toString(16))),\n      // AlgorithmIdentifier\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n        // algorithm\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\n          asn1.oidToDer(pki.oids[prfAlgorithm]).getBytes()),\n        // parameters (null)\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')\n      ]));\n  }\n  return params;\n}\n","/**\n * Javascript implementation of mask generation function MGF1.\n *\n * @author Stefan Siegl\n * @author Dave Longley\n *\n * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>\n * Copyright (c) 2014 Digital Bazaar, Inc.\n */\nvar forge = require('./forge');\nrequire('./util');\n\nforge.mgf = forge.mgf || {};\nvar mgf1 = module.exports = forge.mgf.mgf1 = forge.mgf1 = forge.mgf1 || {};\n\n/**\n * Creates a MGF1 mask generation function object.\n *\n * @param md the message digest API to use (eg: forge.md.sha1.create()).\n *\n * @return a mask generation function object.\n */\nmgf1.create = function(md) {\n  var mgf = {\n    /**\n     * Generate mask of specified length.\n     *\n     * @param {String} seed The seed for mask generation.\n     * @param maskLen Number of bytes to generate.\n     * @return {String} The generated mask.\n     */\n    generate: function(seed, maskLen) {\n      /* 2. Let T be the empty octet string. */\n      var t = new forge.util.ByteBuffer();\n\n      /* 3. For counter from 0 to ceil(maskLen / hLen), do the following: */\n      var len = Math.ceil(maskLen / md.digestLength);\n      for(var i = 0; i < len; i++) {\n        /* a. Convert counter to an octet string C of length 4 octets */\n        var c = new forge.util.ByteBuffer();\n        c.putInt32(i);\n\n        /* b. Concatenate the hash of the seed mgfSeed and C to the octet\n         * string T: */\n        md.start();\n        md.update(seed + c.getBytes());\n        t.putBuffer(md.digest());\n      }\n\n      /* Output the leading maskLen octets of T as the octet string mask. */\n      t.truncate(t.length() - maskLen);\n      return t.getBytes();\n    }\n  };\n\n  return mgf;\n};\n","/**\n * Node.js module for Forge mask generation functions.\n *\n * @author Stefan Siegl\n *\n * Copyright 2012 Stefan Siegl <stesie@brokenpipe.de>\n */\nvar forge = require('./forge');\nrequire('./mgf1');\n\nmodule.exports = forge.mgf = forge.mgf || {};\nforge.mgf.mgf1 = forge.mgf1;\n","/**\n * Node.js module for all known Forge message digests.\n *\n * @author Dave Longley\n *\n * Copyright 2011-2017 Digital Bazaar, Inc.\n */\nmodule.exports = require('./md');\n\nrequire('./md5');\nrequire('./sha1');\nrequire('./sha256');\nrequire('./sha512');\n","/**\n * Cross-browser support for logging in a web application.\n *\n * @author David I. Lehn <dlehn@digitalbazaar.com>\n *\n * Copyright (c) 2008-2013 Digital Bazaar, Inc.\n */\nvar forge = require('./forge');\nrequire('./util');\n\n/* LOG API */\nmodule.exports = forge.log = forge.log || {};\n\n/**\n * Application logging system.\n *\n * Each logger level available as it's own function of the form:\n *   forge.log.level(category, args...)\n * The category is an arbitrary string, and the args are the same as\n * Firebug's console.log API. By default the call will be output as:\n *   'LEVEL [category] <args[0]>, args[1], ...'\n * This enables proper % formatting via the first argument.\n * Each category is enabled by default but can be enabled or disabled with\n * the setCategoryEnabled() function.\n */\n// list of known levels\nforge.log.levels = [\n  'none', 'error', 'warning', 'info', 'debug', 'verbose', 'max'];\n// info on the levels indexed by name:\n//   index: level index\n//   name: uppercased display name\nvar sLevelInfo = {};\n// list of loggers\nvar sLoggers = [];\n/**\n * Standard console logger. If no console support is enabled this will\n * remain null. Check before using.\n */\nvar sConsoleLogger = null;\n\n// logger flags\n/**\n * Lock the level at the current value. Used in cases where user config may\n * set the level such that only critical messages are seen but more verbose\n * messages are needed for debugging or other purposes.\n */\nforge.log.LEVEL_LOCKED = (1 << 1);\n/**\n * Always call log function. By default, the logging system will check the\n * message level against logger.level before calling the log function. This\n * flag allows the function to do its own check.\n */\nforge.log.NO_LEVEL_CHECK = (1 << 2);\n/**\n * Perform message interpolation with the passed arguments. \"%\" style\n * fields in log messages will be replaced by arguments as needed. Some\n * loggers, such as Firebug, may do this automatically. The original log\n * message will be available as 'message' and the interpolated version will\n * be available as 'fullMessage'.\n */\nforge.log.INTERPOLATE = (1 << 3);\n\n// setup each log level\nfor(var i = 0; i < forge.log.levels.length; ++i) {\n  var level = forge.log.levels[i];\n  sLevelInfo[level] = {\n    index: i,\n    name: level.toUpperCase()\n  };\n}\n\n/**\n * Message logger. Will dispatch a message to registered loggers as needed.\n *\n * @param message message object\n */\nforge.log.logMessage = function(message) {\n  var messageLevelIndex = sLevelInfo[message.level].index;\n  for(var i = 0; i < sLoggers.length; ++i) {\n    var logger = sLoggers[i];\n    if(logger.flags & forge.log.NO_LEVEL_CHECK) {\n      logger.f(message);\n    } else {\n      // get logger level\n      var loggerLevelIndex = sLevelInfo[logger.level].index;\n      // check level\n      if(messageLevelIndex <= loggerLevelIndex) {\n        // message critical enough, call logger\n        logger.f(logger, message);\n      }\n    }\n  }\n};\n\n/**\n * Sets the 'standard' key on a message object to:\n * \"LEVEL [category] \" + message\n *\n * @param message a message log object\n */\nforge.log.prepareStandard = function(message) {\n  if(!('standard' in message)) {\n    message.standard =\n      sLevelInfo[message.level].name +\n      //' ' + +message.timestamp +\n      ' [' + message.category + '] ' +\n      message.message;\n  }\n};\n\n/**\n * Sets the 'full' key on a message object to the original message\n * interpolated via % formatting with the message arguments.\n *\n * @param message a message log object.\n */\nforge.log.prepareFull = function(message) {\n  if(!('full' in message)) {\n    // copy args and insert message at the front\n    var args = [message.message];\n    args = args.concat([] || message['arguments']);\n    // format the message\n    message.full = forge.util.format.apply(this, args);\n  }\n};\n\n/**\n * Applies both preparseStandard() and prepareFull() to a message object and\n * store result in 'standardFull'.\n *\n * @param message a message log object.\n */\nforge.log.prepareStandardFull = function(message) {\n  if(!('standardFull' in message)) {\n    // FIXME implement 'standardFull' logging\n    forge.log.prepareStandard(message);\n    message.standardFull = message.standard;\n  }\n};\n\n// create log level functions\nif(true) {\n  // levels for which we want functions\n  var levels = ['error', 'warning', 'info', 'debug', 'verbose'];\n  for(var i = 0; i < levels.length; ++i) {\n    // wrap in a function to ensure proper level var is passed\n    (function(level) {\n      // create function for this level\n      forge.log[level] = function(category, message/*, args...*/) {\n        // convert arguments to real array, remove category and message\n        var args = Array.prototype.slice.call(arguments).slice(2);\n        // create message object\n        // Note: interpolation and standard formatting is done lazily\n        var msg = {\n          timestamp: new Date(),\n          level: level,\n          category: category,\n          message: message,\n          'arguments': args\n          /*standard*/\n          /*full*/\n          /*fullMessage*/\n        };\n        // process this message\n        forge.log.logMessage(msg);\n      };\n    })(levels[i]);\n  }\n}\n\n/**\n * Creates a new logger with specified custom logging function.\n *\n * The logging function has a signature of:\n *   function(logger, message)\n * logger: current logger\n * message: object:\n *   level: level id\n *   category: category\n *   message: string message\n *   arguments: Array of extra arguments\n *   fullMessage: interpolated message and arguments if INTERPOLATE flag set\n *\n * @param logFunction a logging function which takes a log message object\n *          as a parameter.\n *\n * @return a logger object.\n */\nforge.log.makeLogger = function(logFunction) {\n  var logger = {\n    flags: 0,\n    f: logFunction\n  };\n  forge.log.setLevel(logger, 'none');\n  return logger;\n};\n\n/**\n * Sets the current log level on a logger.\n *\n * @param logger the target logger.\n * @param level the new maximum log level as a string.\n *\n * @return true if set, false if not.\n */\nforge.log.setLevel = function(logger, level) {\n  var rval = false;\n  if(logger && !(logger.flags & forge.log.LEVEL_LOCKED)) {\n    for(var i = 0; i < forge.log.levels.length; ++i) {\n      var aValidLevel = forge.log.levels[i];\n      if(level == aValidLevel) {\n        // set level\n        logger.level = level;\n        rval = true;\n        break;\n      }\n    }\n  }\n\n  return rval;\n};\n\n/**\n * Locks the log level at its current value.\n *\n * @param logger the target logger.\n * @param lock boolean lock value, default to true.\n */\nforge.log.lock = function(logger, lock) {\n  if(typeof lock === 'undefined' || lock) {\n    logger.flags |= forge.log.LEVEL_LOCKED;\n  } else {\n    logger.flags &= ~forge.log.LEVEL_LOCKED;\n  }\n};\n\n/**\n * Adds a logger.\n *\n * @param logger the logger object.\n */\nforge.log.addLogger = function(logger) {\n  sLoggers.push(logger);\n};\n\n// setup the console logger if possible, else create fake console.log\nif(typeof(console) !== 'undefined' && 'log' in console) {\n  var logger;\n  if(console.error && console.warn && console.info && console.debug) {\n    // looks like Firebug-style logging is available\n    // level handlers map\n    var levelHandlers = {\n      error: console.error,\n      warning: console.warn,\n      info: console.info,\n      debug: console.debug,\n      verbose: console.debug\n    };\n    var f = function(logger, message) {\n      forge.log.prepareStandard(message);\n      var handler = levelHandlers[message.level];\n      // prepend standard message and concat args\n      var args = [message.standard];\n      args = args.concat(message['arguments'].slice());\n      // apply to low-level console function\n      handler.apply(console, args);\n    };\n    logger = forge.log.makeLogger(f);\n  } else {\n    // only appear to have basic console.log\n    var f = function(logger, message) {\n      forge.log.prepareStandardFull(message);\n      console.log(message.standardFull);\n    };\n    logger = forge.log.makeLogger(f);\n  }\n  forge.log.setLevel(logger, 'debug');\n  forge.log.addLogger(logger);\n  sConsoleLogger = logger;\n} else {\n  // define fake console.log to avoid potential script errors on\n  // browsers that do not have console logging\n  console = {\n    log: function() {}\n  };\n}\n\n/*\n * Check for logging control query vars in current URL.\n *\n * console.level=<level-name>\n * Set's the console log level by name.  Useful to override defaults and\n * allow more verbose logging before a user config is loaded.\n *\n * console.lock=<true|false>\n * Lock the console log level at whatever level it is set at.  This is run\n * after console.level is processed.  Useful to force a level of verbosity\n * that could otherwise be limited by a user config.\n */\nif(sConsoleLogger !== null &&\n  typeof window !== 'undefined' && window.location\n) {\n  var query = new URL(window.location.href).searchParams;\n  if(query.has('console.level')) {\n    // set with last value\n    forge.log.setLevel(\n      sConsoleLogger, query.get('console.level').slice(-1)[0]);\n  }\n  if(query.has('console.lock')) {\n    // set with last value\n    var lock = query.get('console.lock').slice(-1)[0];\n    if(lock == 'true') {\n      forge.log.lock(sConsoleLogger);\n    }\n  }\n}\n\n// provide public access to console logger\nforge.log.consoleLogger = sConsoleLogger;\n","/**\n * Javascript implementation of PKCS#7 v1.5.\n *\n * @author Stefan Siegl\n * @author Dave Longley\n *\n * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>\n * Copyright (c) 2012-2015 Digital Bazaar, Inc.\n *\n * Currently this implementation only supports ContentType of EnvelopedData,\n * EncryptedData, or SignedData at the root level. The top level elements may\n * contain only a ContentInfo of ContentType Data, i.e. plain data. Further\n * nesting is not (yet) supported.\n *\n * The Forge validators for PKCS #7's ASN.1 structures are available from\n * a separate file pkcs7asn1.js, since those are referenced from other\n * PKCS standards like PKCS #12.\n */\nvar forge = require('./forge');\nrequire('./aes');\nrequire('./asn1');\nrequire('./des');\nrequire('./oids');\nrequire('./pem');\nrequire('./pkcs7asn1');\nrequire('./random');\nrequire('./util');\nrequire('./x509');\n\n// shortcut for ASN.1 API\nvar asn1 = forge.asn1;\n\n// shortcut for PKCS#7 API\nvar p7 = module.exports = forge.pkcs7 = forge.pkcs7 || {};\n\n/**\n * Converts a PKCS#7 message from PEM format.\n *\n * @param pem the PEM-formatted PKCS#7 message.\n *\n * @return the PKCS#7 message.\n */\np7.messageFromPem = function(pem) {\n  var msg = forge.pem.decode(pem)[0];\n\n  if(msg.type !== 'PKCS7') {\n    var error = new Error('Could not convert PKCS#7 message from PEM; PEM ' +\n      'header type is not \"PKCS#7\".');\n    error.headerType = msg.type;\n    throw error;\n  }\n  if(msg.procType && msg.procType.type === 'ENCRYPTED') {\n    throw new Error('Could not convert PKCS#7 message from PEM; PEM is encrypted.');\n  }\n\n  // convert DER to ASN.1 object\n  var obj = asn1.fromDer(msg.body);\n\n  return p7.messageFromAsn1(obj);\n};\n\n/**\n * Converts a PKCS#7 message to PEM format.\n *\n * @param msg The PKCS#7 message object\n * @param maxline The maximum characters per line, defaults to 64.\n *\n * @return The PEM-formatted PKCS#7 message.\n */\np7.messageToPem = function(msg, maxline) {\n  // convert to ASN.1, then DER, then PEM-encode\n  var pemObj = {\n    type: 'PKCS7',\n    body: asn1.toDer(msg.toAsn1()).getBytes()\n  };\n  return forge.pem.encode(pemObj, {maxline: maxline});\n};\n\n/**\n * Converts a PKCS#7 message from an ASN.1 object.\n *\n * @param obj the ASN.1 representation of a ContentInfo.\n *\n * @return the PKCS#7 message.\n */\np7.messageFromAsn1 = function(obj) {\n  // validate root level ContentInfo and capture data\n  var capture = {};\n  var errors = [];\n  if(!asn1.validate(obj, p7.asn1.contentInfoValidator, capture, errors)) {\n    var error = new Error('Cannot read PKCS#7 message. ' +\n      'ASN.1 object is not an PKCS#7 ContentInfo.');\n    error.errors = errors;\n    throw error;\n  }\n\n  var contentType = asn1.derToOid(capture.contentType);\n  var msg;\n\n  switch(contentType) {\n    case forge.pki.oids.envelopedData:\n      msg = p7.createEnvelopedData();\n      break;\n\n    case forge.pki.oids.encryptedData:\n      msg = p7.createEncryptedData();\n      break;\n\n    case forge.pki.oids.signedData:\n      msg = p7.createSignedData();\n      break;\n\n    default:\n      throw new Error('Cannot read PKCS#7 message. ContentType with OID ' +\n        contentType + ' is not (yet) supported.');\n  }\n\n  msg.fromAsn1(capture.content.value[0]);\n  return msg;\n};\n\np7.createSignedData = function() {\n  var msg = null;\n  msg = {\n    type: forge.pki.oids.signedData,\n    version: 1,\n    certificates: [],\n    crls: [],\n    // TODO: add json-formatted signer stuff here?\n    signers: [],\n    // populated during sign()\n    digestAlgorithmIdentifiers: [],\n    contentInfo: null,\n    signerInfos: [],\n\n    fromAsn1: function(obj) {\n      // validate SignedData content block and capture data.\n      _fromAsn1(msg, obj, p7.asn1.signedDataValidator);\n      msg.certificates = [];\n      msg.crls = [];\n      msg.digestAlgorithmIdentifiers = [];\n      msg.contentInfo = null;\n      msg.signerInfos = [];\n\n      if(msg.rawCapture.certificates) {\n        var certs = msg.rawCapture.certificates.value;\n        for(var i = 0; i < certs.length; ++i) {\n          msg.certificates.push(forge.pki.certificateFromAsn1(certs[i]));\n        }\n      }\n\n      // TODO: parse crls\n    },\n\n    toAsn1: function() {\n      // degenerate case with no content\n      if(!msg.contentInfo) {\n        msg.sign();\n      }\n\n      var certs = [];\n      for(var i = 0; i < msg.certificates.length; ++i) {\n        certs.push(forge.pki.certificateToAsn1(msg.certificates[i]));\n      }\n\n      var crls = [];\n      // TODO: implement CRLs\n\n      // [0] SignedData\n      var signedData = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n          // Version\n          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\n            asn1.integerToDer(msg.version).getBytes()),\n          // DigestAlgorithmIdentifiers\n          asn1.create(\n            asn1.Class.UNIVERSAL, asn1.Type.SET, true,\n            msg.digestAlgorithmIdentifiers),\n          // ContentInfo\n          msg.contentInfo\n        ])\n      ]);\n      if(certs.length > 0) {\n        // [0] IMPLICIT ExtendedCertificatesAndCertificates OPTIONAL\n        signedData.value[0].value.push(\n          asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, certs));\n      }\n      if(crls.length > 0) {\n        // [1] IMPLICIT CertificateRevocationLists OPTIONAL\n        signedData.value[0].value.push(\n          asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, crls));\n      }\n      // SignerInfos\n      signedData.value[0].value.push(\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true,\n          msg.signerInfos));\n\n      // ContentInfo\n      return asn1.create(\n        asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n          // ContentType\n          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\n            asn1.oidToDer(msg.type).getBytes()),\n          // [0] SignedData\n          signedData\n        ]);\n    },\n\n    /**\n     * Add (another) entity to list of signers.\n     *\n     * Note: If authenticatedAttributes are provided, then, per RFC 2315,\n     * they must include at least two attributes: content type and\n     * message digest. The message digest attribute value will be\n     * auto-calculated during signing and will be ignored if provided.\n     *\n     * Here's an example of providing these two attributes:\n     *\n     * forge.pkcs7.createSignedData();\n     * p7.addSigner({\n     *   issuer: cert.issuer.attributes,\n     *   serialNumber: cert.serialNumber,\n     *   key: privateKey,\n     *   digestAlgorithm: forge.pki.oids.sha1,\n     *   authenticatedAttributes: [{\n     *     type: forge.pki.oids.contentType,\n     *     value: forge.pki.oids.data\n     *   }, {\n     *     type: forge.pki.oids.messageDigest\n     *   }]\n     * });\n     *\n     * TODO: Support [subjectKeyIdentifier] as signer's ID.\n     *\n     * @param signer the signer information:\n     *          key the signer's private key.\n     *          [certificate] a certificate containing the public key\n     *            associated with the signer's private key; use this option as\n     *            an alternative to specifying signer.issuer and\n     *            signer.serialNumber.\n     *          [issuer] the issuer attributes (eg: cert.issuer.attributes).\n     *          [serialNumber] the signer's certificate's serial number in\n     *           hexadecimal (eg: cert.serialNumber).\n     *          [digestAlgorithm] the message digest OID, as a string, to use\n     *            (eg: forge.pki.oids.sha1).\n     *          [authenticatedAttributes] an optional array of attributes\n     *            to also sign along with the content.\n     */\n    addSigner: function(signer) {\n      var issuer = signer.issuer;\n      var serialNumber = signer.serialNumber;\n      if(signer.certificate) {\n        var cert = signer.certificate;\n        if(typeof cert === 'string') {\n          cert = forge.pki.certificateFromPem(cert);\n        }\n        issuer = cert.issuer.attributes;\n        serialNumber = cert.serialNumber;\n      }\n      var key = signer.key;\n      if(!key) {\n        throw new Error(\n          'Could not add PKCS#7 signer; no private key specified.');\n      }\n      if(typeof key === 'string') {\n        key = forge.pki.privateKeyFromPem(key);\n      }\n\n      // ensure OID known for digest algorithm\n      var digestAlgorithm = signer.digestAlgorithm || forge.pki.oids.sha1;\n      switch(digestAlgorithm) {\n      case forge.pki.oids.sha1:\n      case forge.pki.oids.sha256:\n      case forge.pki.oids.sha384:\n      case forge.pki.oids.sha512:\n      case forge.pki.oids.md5:\n        break;\n      default:\n        throw new Error(\n          'Could not add PKCS#7 signer; unknown message digest algorithm: ' +\n          digestAlgorithm);\n      }\n\n      // if authenticatedAttributes is present, then the attributes\n      // must contain at least PKCS #9 content-type and message-digest\n      var authenticatedAttributes = signer.authenticatedAttributes || [];\n      if(authenticatedAttributes.length > 0) {\n        var contentType = false;\n        var messageDigest = false;\n        for(var i = 0; i < authenticatedAttributes.length; ++i) {\n          var attr = authenticatedAttributes[i];\n          if(!contentType && attr.type === forge.pki.oids.contentType) {\n            contentType = true;\n            if(messageDigest) {\n              break;\n            }\n            continue;\n          }\n          if(!messageDigest && attr.type === forge.pki.oids.messageDigest) {\n            messageDigest = true;\n            if(contentType) {\n              break;\n            }\n            continue;\n          }\n        }\n\n        if(!contentType || !messageDigest) {\n          throw new Error('Invalid signer.authenticatedAttributes. If ' +\n            'signer.authenticatedAttributes is specified, then it must ' +\n            'contain at least two attributes, PKCS #9 content-type and ' +\n            'PKCS #9 message-digest.');\n        }\n      }\n\n      msg.signers.push({\n        key: key,\n        version: 1,\n        issuer: issuer,\n        serialNumber: serialNumber,\n        digestAlgorithm: digestAlgorithm,\n        signatureAlgorithm: forge.pki.oids.rsaEncryption,\n        signature: null,\n        authenticatedAttributes: authenticatedAttributes,\n        unauthenticatedAttributes: []\n      });\n    },\n\n    /**\n     * Signs the content.\n     * @param options Options to apply when signing:\n     *    [detached] boolean. If signing should be done in detached mode. Defaults to false.\n     */\n    sign: function(options) {\n      options = options || {};\n      // auto-generate content info\n      if(typeof msg.content !== 'object' || msg.contentInfo === null) {\n        // use Data ContentInfo\n        msg.contentInfo = asn1.create(\n          asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n            // ContentType\n            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\n              asn1.oidToDer(forge.pki.oids.data).getBytes())\n          ]);\n\n        // add actual content, if present\n        if('content' in msg) {\n          var content;\n          if(msg.content instanceof forge.util.ByteBuffer) {\n            content = msg.content.bytes();\n          } else if(typeof msg.content === 'string') {\n            content = forge.util.encodeUtf8(msg.content);\n          }\n\n          if (options.detached) {\n            msg.detachedContent = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, content);\n          } else {\n            msg.contentInfo.value.push(\n              // [0] EXPLICIT content\n              asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\n                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false,\n                  content)\n              ]));\n          }\n        }\n      }\n\n      // no signers, return early (degenerate case for certificate container)\n      if(msg.signers.length === 0) {\n        return;\n      }\n\n      // generate digest algorithm identifiers\n      var mds = addDigestAlgorithmIds();\n\n      // generate signerInfos\n      addSignerInfos(mds);\n    },\n\n    verify: function() {\n      throw new Error('PKCS#7 signature verification not yet implemented.');\n    },\n\n    /**\n     * Add a certificate.\n     *\n     * @param cert the certificate to add.\n     */\n    addCertificate: function(cert) {\n      // convert from PEM\n      if(typeof cert === 'string') {\n        cert = forge.pki.certificateFromPem(cert);\n      }\n      msg.certificates.push(cert);\n    },\n\n    /**\n     * Add a certificate revokation list.\n     *\n     * @param crl the certificate revokation list to add.\n     */\n    addCertificateRevokationList: function(crl) {\n      throw new Error('PKCS#7 CRL support not yet implemented.');\n    }\n  };\n  return msg;\n\n  function addDigestAlgorithmIds() {\n    var mds = {};\n\n    for(var i = 0; i < msg.signers.length; ++i) {\n      var signer = msg.signers[i];\n      var oid = signer.digestAlgorithm;\n      if(!(oid in mds)) {\n        // content digest\n        mds[oid] = forge.md[forge.pki.oids[oid]].create();\n      }\n      if(signer.authenticatedAttributes.length === 0) {\n        // no custom attributes to digest; use content message digest\n        signer.md = mds[oid];\n      } else {\n        // custom attributes to be digested; use own message digest\n        // TODO: optimize to just copy message digest state if that\n        // feature is ever supported with message digests\n        signer.md = forge.md[forge.pki.oids[oid]].create();\n      }\n    }\n\n    // add unique digest algorithm identifiers\n    msg.digestAlgorithmIdentifiers = [];\n    for(var oid in mds) {\n      msg.digestAlgorithmIdentifiers.push(\n        // AlgorithmIdentifier\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n          // algorithm\n          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\n            asn1.oidToDer(oid).getBytes()),\n          // parameters (null)\n          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')\n        ]));\n    }\n\n    return mds;\n  }\n\n  function addSignerInfos(mds) {\n    var content;\n\n    if (msg.detachedContent) {\n      // Signature has been made in detached mode.\n      content = msg.detachedContent;\n    } else {\n      // Note: ContentInfo is a SEQUENCE with 2 values, second value is\n      // the content field and is optional for a ContentInfo but required here\n      // since signers are present\n      // get ContentInfo content\n      content = msg.contentInfo.value[1];\n      // skip [0] EXPLICIT content wrapper\n      content = content.value[0];\n    }\n\n    if(!content) {\n      throw new Error(\n        'Could not sign PKCS#7 message; there is no content to sign.');\n    }\n\n    // get ContentInfo content type\n    var contentType = asn1.derToOid(msg.contentInfo.value[0].value);\n\n    // serialize content\n    var bytes = asn1.toDer(content);\n\n    // skip identifier and length per RFC 2315 9.3\n    // skip identifier (1 byte)\n    bytes.getByte();\n    // read and discard length bytes\n    asn1.getBerValueLength(bytes);\n    bytes = bytes.getBytes();\n\n    // digest content DER value bytes\n    for(var oid in mds) {\n      mds[oid].start().update(bytes);\n    }\n\n    // sign content\n    var signingTime = new Date();\n    for(var i = 0; i < msg.signers.length; ++i) {\n      var signer = msg.signers[i];\n\n      if(signer.authenticatedAttributes.length === 0) {\n        // if ContentInfo content type is not \"Data\", then\n        // authenticatedAttributes must be present per RFC 2315\n        if(contentType !== forge.pki.oids.data) {\n          throw new Error(\n            'Invalid signer; authenticatedAttributes must be present ' +\n            'when the ContentInfo content type is not PKCS#7 Data.');\n        }\n      } else {\n        // process authenticated attributes\n        // [0] IMPLICIT\n        signer.authenticatedAttributesAsn1 = asn1.create(\n          asn1.Class.CONTEXT_SPECIFIC, 0, true, []);\n\n        // per RFC 2315, attributes are to be digested using a SET container\n        // not the above [0] IMPLICIT container\n        var attrsAsn1 = asn1.create(\n          asn1.Class.UNIVERSAL, asn1.Type.SET, true, []);\n\n        for(var ai = 0; ai < signer.authenticatedAttributes.length; ++ai) {\n          var attr = signer.authenticatedAttributes[ai];\n          if(attr.type === forge.pki.oids.messageDigest) {\n            // use content message digest as value\n            attr.value = mds[signer.digestAlgorithm].digest();\n          } else if(attr.type === forge.pki.oids.signingTime) {\n            // auto-populate signing time if not already set\n            if(!attr.value) {\n              attr.value = signingTime;\n            }\n          }\n\n          // convert to ASN.1 and push onto Attributes SET (for signing) and\n          // onto authenticatedAttributesAsn1 to complete SignedData ASN.1\n          // TODO: optimize away duplication\n          attrsAsn1.value.push(_attributeToAsn1(attr));\n          signer.authenticatedAttributesAsn1.value.push(_attributeToAsn1(attr));\n        }\n\n        // DER-serialize and digest SET OF attributes only\n        bytes = asn1.toDer(attrsAsn1).getBytes();\n        signer.md.start().update(bytes);\n      }\n\n      // sign digest\n      signer.signature = signer.key.sign(signer.md, 'RSASSA-PKCS1-V1_5');\n    }\n\n    // add signer info\n    msg.signerInfos = _signersToAsn1(msg.signers);\n  }\n};\n\n/**\n * Creates an empty PKCS#7 message of type EncryptedData.\n *\n * @return the message.\n */\np7.createEncryptedData = function() {\n  var msg = null;\n  msg = {\n    type: forge.pki.oids.encryptedData,\n    version: 0,\n    encryptedContent: {\n      algorithm: forge.pki.oids['aes256-CBC']\n    },\n\n    /**\n     * Reads an EncryptedData content block (in ASN.1 format)\n     *\n     * @param obj The ASN.1 representation of the EncryptedData content block\n     */\n    fromAsn1: function(obj) {\n      // Validate EncryptedData content block and capture data.\n      _fromAsn1(msg, obj, p7.asn1.encryptedDataValidator);\n    },\n\n    /**\n     * Decrypt encrypted content\n     *\n     * @param key The (symmetric) key as a byte buffer\n     */\n    decrypt: function(key) {\n      if(key !== undefined) {\n        msg.encryptedContent.key = key;\n      }\n      _decryptContent(msg);\n    }\n  };\n  return msg;\n};\n\n/**\n * Creates an empty PKCS#7 message of type EnvelopedData.\n *\n * @return the message.\n */\np7.createEnvelopedData = function() {\n  var msg = null;\n  msg = {\n    type: forge.pki.oids.envelopedData,\n    version: 0,\n    recipients: [],\n    encryptedContent: {\n      algorithm: forge.pki.oids['aes256-CBC']\n    },\n\n    /**\n     * Reads an EnvelopedData content block (in ASN.1 format)\n     *\n     * @param obj the ASN.1 representation of the EnvelopedData content block.\n     */\n    fromAsn1: function(obj) {\n      // validate EnvelopedData content block and capture data\n      var capture = _fromAsn1(msg, obj, p7.asn1.envelopedDataValidator);\n      msg.recipients = _recipientsFromAsn1(capture.recipientInfos.value);\n    },\n\n    toAsn1: function() {\n      // ContentInfo\n      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n        // ContentType\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\n          asn1.oidToDer(msg.type).getBytes()),\n        // [0] EnvelopedData\n        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\n          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n            // Version\n            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\n              asn1.integerToDer(msg.version).getBytes()),\n            // RecipientInfos\n            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true,\n              _recipientsToAsn1(msg.recipients)),\n            // EncryptedContentInfo\n            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true,\n              _encryptedContentToAsn1(msg.encryptedContent))\n          ])\n        ])\n      ]);\n    },\n\n    /**\n     * Find recipient by X.509 certificate's issuer.\n     *\n     * @param cert the certificate with the issuer to look for.\n     *\n     * @return the recipient object.\n     */\n    findRecipient: function(cert) {\n      var sAttr = cert.issuer.attributes;\n\n      for(var i = 0; i < msg.recipients.length; ++i) {\n        var r = msg.recipients[i];\n        var rAttr = r.issuer;\n\n        if(r.serialNumber !== cert.serialNumber) {\n          continue;\n        }\n\n        if(rAttr.length !== sAttr.length) {\n          continue;\n        }\n\n        var match = true;\n        for(var j = 0; j < sAttr.length; ++j) {\n          if(rAttr[j].type !== sAttr[j].type ||\n            rAttr[j].value !== sAttr[j].value) {\n            match = false;\n            break;\n          }\n        }\n\n        if(match) {\n          return r;\n        }\n      }\n\n      return null;\n    },\n\n    /**\n     * Decrypt enveloped content\n     *\n     * @param recipient The recipient object related to the private key\n     * @param privKey The (RSA) private key object\n     */\n    decrypt: function(recipient, privKey) {\n      if(msg.encryptedContent.key === undefined && recipient !== undefined &&\n        privKey !== undefined) {\n        switch(recipient.encryptedContent.algorithm) {\n          case forge.pki.oids.rsaEncryption:\n          case forge.pki.oids.desCBC:\n            var key = privKey.decrypt(recipient.encryptedContent.content);\n            msg.encryptedContent.key = forge.util.createBuffer(key);\n            break;\n\n          default:\n            throw new Error('Unsupported asymmetric cipher, ' +\n              'OID ' + recipient.encryptedContent.algorithm);\n        }\n      }\n\n      _decryptContent(msg);\n    },\n\n    /**\n     * Add (another) entity to list of recipients.\n     *\n     * @param cert The certificate of the entity to add.\n     */\n    addRecipient: function(cert) {\n      msg.recipients.push({\n        version: 0,\n        issuer: cert.issuer.attributes,\n        serialNumber: cert.serialNumber,\n        encryptedContent: {\n          // We simply assume rsaEncryption here, since forge.pki only\n          // supports RSA so far.  If the PKI module supports other\n          // ciphers one day, we need to modify this one as well.\n          algorithm: forge.pki.oids.rsaEncryption,\n          key: cert.publicKey\n        }\n      });\n    },\n\n    /**\n     * Encrypt enveloped content.\n     *\n     * This function supports two optional arguments, cipher and key, which\n     * can be used to influence symmetric encryption.  Unless cipher is\n     * provided, the cipher specified in encryptedContent.algorithm is used\n     * (defaults to AES-256-CBC).  If no key is provided, encryptedContent.key\n     * is (re-)used.  If that one's not set, a random key will be generated\n     * automatically.\n     *\n     * @param [key] The key to be used for symmetric encryption.\n     * @param [cipher] The OID of the symmetric cipher to use.\n     */\n    encrypt: function(key, cipher) {\n      // Part 1: Symmetric encryption\n      if(msg.encryptedContent.content === undefined) {\n        cipher = cipher || msg.encryptedContent.algorithm;\n        key = key || msg.encryptedContent.key;\n\n        var keyLen, ivLen, ciphFn;\n        switch(cipher) {\n          case forge.pki.oids['aes128-CBC']:\n            keyLen = 16;\n            ivLen = 16;\n            ciphFn = forge.aes.createEncryptionCipher;\n            break;\n\n          case forge.pki.oids['aes192-CBC']:\n            keyLen = 24;\n            ivLen = 16;\n            ciphFn = forge.aes.createEncryptionCipher;\n            break;\n\n          case forge.pki.oids['aes256-CBC']:\n            keyLen = 32;\n            ivLen = 16;\n            ciphFn = forge.aes.createEncryptionCipher;\n            break;\n\n          case forge.pki.oids['des-EDE3-CBC']:\n            keyLen = 24;\n            ivLen = 8;\n            ciphFn = forge.des.createEncryptionCipher;\n            break;\n\n          default:\n            throw new Error('Unsupported symmetric cipher, OID ' + cipher);\n        }\n\n        if(key === undefined) {\n          key = forge.util.createBuffer(forge.random.getBytes(keyLen));\n        } else if(key.length() != keyLen) {\n          throw new Error('Symmetric key has wrong length; ' +\n            'got ' + key.length() + ' bytes, expected ' + keyLen + '.');\n        }\n\n        // Keep a copy of the key & IV in the object, so the caller can\n        // use it for whatever reason.\n        msg.encryptedContent.algorithm = cipher;\n        msg.encryptedContent.key = key;\n        msg.encryptedContent.parameter = forge.util.createBuffer(\n          forge.random.getBytes(ivLen));\n\n        var ciph = ciphFn(key);\n        ciph.start(msg.encryptedContent.parameter.copy());\n        ciph.update(msg.content);\n\n        // The finish function does PKCS#7 padding by default, therefore\n        // no action required by us.\n        if(!ciph.finish()) {\n          throw new Error('Symmetric encryption failed.');\n        }\n\n        msg.encryptedContent.content = ciph.output;\n      }\n\n      // Part 2: asymmetric encryption for each recipient\n      for(var i = 0; i < msg.recipients.length; ++i) {\n        var recipient = msg.recipients[i];\n\n        // Nothing to do, encryption already done.\n        if(recipient.encryptedContent.content !== undefined) {\n          continue;\n        }\n\n        switch(recipient.encryptedContent.algorithm) {\n          case forge.pki.oids.rsaEncryption:\n            recipient.encryptedContent.content =\n              recipient.encryptedContent.key.encrypt(\n                msg.encryptedContent.key.data);\n            break;\n\n          default:\n            throw new Error('Unsupported asymmetric cipher, OID ' +\n              recipient.encryptedContent.algorithm);\n        }\n      }\n    }\n  };\n  return msg;\n};\n\n/**\n * Converts a single recipient from an ASN.1 object.\n *\n * @param obj the ASN.1 RecipientInfo.\n *\n * @return the recipient object.\n */\nfunction _recipientFromAsn1(obj) {\n  // validate EnvelopedData content block and capture data\n  var capture = {};\n  var errors = [];\n  if(!asn1.validate(obj, p7.asn1.recipientInfoValidator, capture, errors)) {\n    var error = new Error('Cannot read PKCS#7 RecipientInfo. ' +\n      'ASN.1 object is not an PKCS#7 RecipientInfo.');\n    error.errors = errors;\n    throw error;\n  }\n\n  return {\n    version: capture.version.charCodeAt(0),\n    issuer: forge.pki.RDNAttributesAsArray(capture.issuer),\n    serialNumber: forge.util.createBuffer(capture.serial).toHex(),\n    encryptedContent: {\n      algorithm: asn1.derToOid(capture.encAlgorithm),\n      parameter: capture.encParameter ? capture.encParameter.value : undefined,\n      content: capture.encKey\n    }\n  };\n}\n\n/**\n * Converts a single recipient object to an ASN.1 object.\n *\n * @param obj the recipient object.\n *\n * @return the ASN.1 RecipientInfo.\n */\nfunction _recipientToAsn1(obj) {\n  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n    // Version\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\n      asn1.integerToDer(obj.version).getBytes()),\n    // IssuerAndSerialNumber\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n      // Name\n      forge.pki.distinguishedNameToAsn1({attributes: obj.issuer}),\n      // Serial\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\n        forge.util.hexToBytes(obj.serialNumber))\n    ]),\n    // KeyEncryptionAlgorithmIdentifier\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n      // Algorithm\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\n        asn1.oidToDer(obj.encryptedContent.algorithm).getBytes()),\n      // Parameter, force NULL, only RSA supported for now.\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')\n    ]),\n    // EncryptedKey\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false,\n      obj.encryptedContent.content)\n  ]);\n}\n\n/**\n * Map a set of RecipientInfo ASN.1 objects to recipient objects.\n *\n * @param infos an array of ASN.1 representations RecipientInfo (i.e. SET OF).\n *\n * @return an array of recipient objects.\n */\nfunction _recipientsFromAsn1(infos) {\n  var ret = [];\n  for(var i = 0; i < infos.length; ++i) {\n    ret.push(_recipientFromAsn1(infos[i]));\n  }\n  return ret;\n}\n\n/**\n * Map an array of recipient objects to ASN.1 RecipientInfo objects.\n *\n * @param recipients an array of recipientInfo objects.\n *\n * @return an array of ASN.1 RecipientInfos.\n */\nfunction _recipientsToAsn1(recipients) {\n  var ret = [];\n  for(var i = 0; i < recipients.length; ++i) {\n    ret.push(_recipientToAsn1(recipients[i]));\n  }\n  return ret;\n}\n\n/**\n * Converts a single signer from an ASN.1 object.\n *\n * @param obj the ASN.1 representation of a SignerInfo.\n *\n * @return the signer object.\n */\nfunction _signerFromAsn1(obj) {\n  // validate EnvelopedData content block and capture data\n  var capture = {};\n  var errors = [];\n  if(!asn1.validate(obj, p7.asn1.signerInfoValidator, capture, errors)) {\n    var error = new Error('Cannot read PKCS#7 SignerInfo. ' +\n      'ASN.1 object is not an PKCS#7 SignerInfo.');\n    error.errors = errors;\n    throw error;\n  }\n\n  var rval = {\n    version: capture.version.charCodeAt(0),\n    issuer: forge.pki.RDNAttributesAsArray(capture.issuer),\n    serialNumber: forge.util.createBuffer(capture.serial).toHex(),\n    digestAlgorithm: asn1.derToOid(capture.digestAlgorithm),\n    signatureAlgorithm: asn1.derToOid(capture.signatureAlgorithm),\n    signature: capture.signature,\n    authenticatedAttributes: [],\n    unauthenticatedAttributes: []\n  };\n\n  // TODO: convert attributes\n  var authenticatedAttributes = capture.authenticatedAttributes || [];\n  var unauthenticatedAttributes = capture.unauthenticatedAttributes || [];\n\n  return rval;\n}\n\n/**\n * Converts a single signerInfo object to an ASN.1 object.\n *\n * @param obj the signerInfo object.\n *\n * @return the ASN.1 representation of a SignerInfo.\n */\nfunction _signerToAsn1(obj) {\n  // SignerInfo\n  var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n    // version\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\n      asn1.integerToDer(obj.version).getBytes()),\n    // issuerAndSerialNumber\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n      // name\n      forge.pki.distinguishedNameToAsn1({attributes: obj.issuer}),\n      // serial\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\n        forge.util.hexToBytes(obj.serialNumber))\n    ]),\n    // digestAlgorithm\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n      // algorithm\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\n        asn1.oidToDer(obj.digestAlgorithm).getBytes()),\n      // parameters (null)\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')\n    ])\n  ]);\n\n  // authenticatedAttributes (OPTIONAL)\n  if(obj.authenticatedAttributesAsn1) {\n    // add ASN.1 previously generated during signing\n    rval.value.push(obj.authenticatedAttributesAsn1);\n  }\n\n  // digestEncryptionAlgorithm\n  rval.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n    // algorithm\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\n      asn1.oidToDer(obj.signatureAlgorithm).getBytes()),\n    // parameters (null)\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')\n  ]));\n\n  // encryptedDigest\n  rval.value.push(asn1.create(\n    asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, obj.signature));\n\n  // unauthenticatedAttributes (OPTIONAL)\n  if(obj.unauthenticatedAttributes.length > 0) {\n    // [1] IMPLICIT\n    var attrsAsn1 = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, []);\n    for(var i = 0; i < obj.unauthenticatedAttributes.length; ++i) {\n      var attr = obj.unauthenticatedAttributes[i];\n      attrsAsn1.values.push(_attributeToAsn1(attr));\n    }\n    rval.value.push(attrsAsn1);\n  }\n\n  return rval;\n}\n\n/**\n * Map a set of SignerInfo ASN.1 objects to an array of signer objects.\n *\n * @param signerInfoAsn1s an array of ASN.1 SignerInfos (i.e. SET OF).\n *\n * @return an array of signers objects.\n */\nfunction _signersFromAsn1(signerInfoAsn1s) {\n  var ret = [];\n  for(var i = 0; i < signerInfoAsn1s.length; ++i) {\n    ret.push(_signerFromAsn1(signerInfoAsn1s[i]));\n  }\n  return ret;\n}\n\n/**\n * Map an array of signer objects to ASN.1 objects.\n *\n * @param signers an array of signer objects.\n *\n * @return an array of ASN.1 SignerInfos.\n */\nfunction _signersToAsn1(signers) {\n  var ret = [];\n  for(var i = 0; i < signers.length; ++i) {\n    ret.push(_signerToAsn1(signers[i]));\n  }\n  return ret;\n}\n\n/**\n * Convert an attribute object to an ASN.1 Attribute.\n *\n * @param attr the attribute object.\n *\n * @return the ASN.1 Attribute.\n */\nfunction _attributeToAsn1(attr) {\n  var value;\n\n  // TODO: generalize to support more attributes\n  if(attr.type === forge.pki.oids.contentType) {\n    value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\n      asn1.oidToDer(attr.value).getBytes());\n  } else if(attr.type === forge.pki.oids.messageDigest) {\n    value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false,\n      attr.value.bytes());\n  } else if(attr.type === forge.pki.oids.signingTime) {\n    /* Note per RFC 2985: Dates between 1 January 1950 and 31 December 2049\n      (inclusive) MUST be encoded as UTCTime. Any dates with year values\n      before 1950 or after 2049 MUST be encoded as GeneralizedTime. [Further,]\n      UTCTime values MUST be expressed in Greenwich Mean Time (Zulu) and MUST\n      include seconds (i.e., times are YYMMDDHHMMSSZ), even where the\n      number of seconds is zero.  Midnight (GMT) must be represented as\n      \"YYMMDD000000Z\". */\n    // TODO: make these module-level constants\n    var jan_1_1950 = new Date('1950-01-01T00:00:00Z');\n    var jan_1_2050 = new Date('2050-01-01T00:00:00Z');\n    var date = attr.value;\n    if(typeof date === 'string') {\n      // try to parse date\n      var timestamp = Date.parse(date);\n      if(!isNaN(timestamp)) {\n        date = new Date(timestamp);\n      } else if(date.length === 13) {\n        // YYMMDDHHMMSSZ (13 chars for UTCTime)\n        date = asn1.utcTimeToDate(date);\n      } else {\n        // assume generalized time\n        date = asn1.generalizedTimeToDate(date);\n      }\n    }\n\n    if(date >= jan_1_1950 && date < jan_1_2050) {\n      value = asn1.create(\n        asn1.Class.UNIVERSAL, asn1.Type.UTCTIME, false,\n        asn1.dateToUtcTime(date));\n    } else {\n      value = asn1.create(\n        asn1.Class.UNIVERSAL, asn1.Type.GENERALIZEDTIME, false,\n        asn1.dateToGeneralizedTime(date));\n    }\n  }\n\n  // TODO: expose as common API call\n  // create a RelativeDistinguishedName set\n  // each value in the set is an AttributeTypeAndValue first\n  // containing the type (an OID) and second the value\n  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n    // AttributeType\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\n      asn1.oidToDer(attr.type).getBytes()),\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [\n      // AttributeValue\n      value\n    ])\n  ]);\n}\n\n/**\n * Map messages encrypted content to ASN.1 objects.\n *\n * @param ec The encryptedContent object of the message.\n *\n * @return ASN.1 representation of the encryptedContent object (SEQUENCE).\n */\nfunction _encryptedContentToAsn1(ec) {\n  return [\n    // ContentType, always Data for the moment\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\n      asn1.oidToDer(forge.pki.oids.data).getBytes()),\n    // ContentEncryptionAlgorithmIdentifier\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n      // Algorithm\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\n        asn1.oidToDer(ec.algorithm).getBytes()),\n      // Parameters (IV)\n      !ec.parameter ?\n        undefined :\n        asn1.create(\n          asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false,\n          ec.parameter.getBytes())\n    ]),\n    // [0] EncryptedContent\n    asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false,\n        ec.content.getBytes())\n    ])\n  ];\n}\n\n/**\n * Reads the \"common part\" of an PKCS#7 content block (in ASN.1 format)\n *\n * This function reads the \"common part\" of the PKCS#7 content blocks\n * EncryptedData and EnvelopedData, i.e. version number and symmetrically\n * encrypted content block.\n *\n * The result of the ASN.1 validate and capture process is returned\n * to allow the caller to extract further data, e.g. the list of recipients\n * in case of a EnvelopedData object.\n *\n * @param msg the PKCS#7 object to read the data to.\n * @param obj the ASN.1 representation of the content block.\n * @param validator the ASN.1 structure validator object to use.\n *\n * @return the value map captured by validator object.\n */\nfunction _fromAsn1(msg, obj, validator) {\n  var capture = {};\n  var errors = [];\n  if(!asn1.validate(obj, validator, capture, errors)) {\n    var error = new Error('Cannot read PKCS#7 message. ' +\n      'ASN.1 object is not a supported PKCS#7 message.');\n    error.errors = error;\n    throw error;\n  }\n\n  // Check contentType, so far we only support (raw) Data.\n  var contentType = asn1.derToOid(capture.contentType);\n  if(contentType !== forge.pki.oids.data) {\n    throw new Error('Unsupported PKCS#7 message. ' +\n      'Only wrapped ContentType Data supported.');\n  }\n\n  if(capture.encryptedContent) {\n    var content = '';\n    if(forge.util.isArray(capture.encryptedContent)) {\n      for(var i = 0; i < capture.encryptedContent.length; ++i) {\n        if(capture.encryptedContent[i].type !== asn1.Type.OCTETSTRING) {\n          throw new Error('Malformed PKCS#7 message, expecting encrypted ' +\n            'content constructed of only OCTET STRING objects.');\n        }\n        content += capture.encryptedContent[i].value;\n      }\n    } else {\n      content = capture.encryptedContent;\n    }\n    msg.encryptedContent = {\n      algorithm: asn1.derToOid(capture.encAlgorithm),\n      parameter: forge.util.createBuffer(capture.encParameter.value),\n      content: forge.util.createBuffer(content)\n    };\n  }\n\n  if(capture.content) {\n    var content = '';\n    if(forge.util.isArray(capture.content)) {\n      for(var i = 0; i < capture.content.length; ++i) {\n        if(capture.content[i].type !== asn1.Type.OCTETSTRING) {\n          throw new Error('Malformed PKCS#7 message, expecting ' +\n            'content constructed of only OCTET STRING objects.');\n        }\n        content += capture.content[i].value;\n      }\n    } else {\n      content = capture.content;\n    }\n    msg.content = forge.util.createBuffer(content);\n  }\n\n  msg.version = capture.version.charCodeAt(0);\n  msg.rawCapture = capture;\n\n  return capture;\n}\n\n/**\n * Decrypt the symmetrically encrypted content block of the PKCS#7 message.\n *\n * Decryption is skipped in case the PKCS#7 message object already has a\n * (decrypted) content attribute.  The algorithm, key and cipher parameters\n * (probably the iv) are taken from the encryptedContent attribute of the\n * message object.\n *\n * @param The PKCS#7 message object.\n */\nfunction _decryptContent(msg) {\n  if(msg.encryptedContent.key === undefined) {\n    throw new Error('Symmetric key not available.');\n  }\n\n  if(msg.content === undefined) {\n    var ciph;\n\n    switch(msg.encryptedContent.algorithm) {\n      case forge.pki.oids['aes128-CBC']:\n      case forge.pki.oids['aes192-CBC']:\n      case forge.pki.oids['aes256-CBC']:\n        ciph = forge.aes.createDecryptionCipher(msg.encryptedContent.key);\n        break;\n\n      case forge.pki.oids['desCBC']:\n      case forge.pki.oids['des-EDE3-CBC']:\n        ciph = forge.des.createDecryptionCipher(msg.encryptedContent.key);\n        break;\n\n      default:\n        throw new Error('Unsupported symmetric cipher, OID ' +\n          msg.encryptedContent.algorithm);\n    }\n    ciph.start(msg.encryptedContent.parameter);\n    ciph.update(msg.encryptedContent.content);\n\n    if(!ciph.finish()) {\n      throw new Error('Symmetric decryption failed.');\n    }\n\n    msg.content = ciph.output;\n  }\n}\n","/**\n * Javascript implementation of basic PEM (Privacy Enhanced Mail) algorithms.\n *\n * See: RFC 1421.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2013-2014 Digital Bazaar, Inc.\n *\n * A Forge PEM object has the following fields:\n *\n * type: identifies the type of message (eg: \"RSA PRIVATE KEY\").\n *\n * procType: identifies the type of processing performed on the message,\n *   it has two subfields: version and type, eg: 4,ENCRYPTED.\n *\n * contentDomain: identifies the type of content in the message, typically\n *   only uses the value: \"RFC822\".\n *\n * dekInfo: identifies the message encryption algorithm and mode and includes\n *   any parameters for the algorithm, it has two subfields: algorithm and\n *   parameters, eg: DES-CBC,F8143EDE5960C597.\n *\n * headers: contains all other PEM encapsulated headers -- where order is\n *   significant (for pairing data like recipient ID + key info).\n *\n * body: the binary-encoded body.\n */\nvar forge = require('./forge');\nrequire('./util');\n\n// shortcut for pem API\nvar pem = module.exports = forge.pem = forge.pem || {};\n\n/**\n * Encodes (serializes) the given PEM object.\n *\n * @param msg the PEM message object to encode.\n * @param options the options to use:\n *          maxline the maximum characters per line for the body, (default: 64).\n *\n * @return the PEM-formatted string.\n */\npem.encode = function(msg, options) {\n  options = options || {};\n  var rval = '-----BEGIN ' + msg.type + '-----\\r\\n';\n\n  // encode special headers\n  var header;\n  if(msg.procType) {\n    header = {\n      name: 'Proc-Type',\n      values: [String(msg.procType.version), msg.procType.type]\n    };\n    rval += foldHeader(header);\n  }\n  if(msg.contentDomain) {\n    header = {name: 'Content-Domain', values: [msg.contentDomain]};\n    rval += foldHeader(header);\n  }\n  if(msg.dekInfo) {\n    header = {name: 'DEK-Info', values: [msg.dekInfo.algorithm]};\n    if(msg.dekInfo.parameters) {\n      header.values.push(msg.dekInfo.parameters);\n    }\n    rval += foldHeader(header);\n  }\n\n  if(msg.headers) {\n    // encode all other headers\n    for(var i = 0; i < msg.headers.length; ++i) {\n      rval += foldHeader(msg.headers[i]);\n    }\n  }\n\n  // terminate header\n  if(msg.procType) {\n    rval += '\\r\\n';\n  }\n\n  // add body\n  rval += forge.util.encode64(msg.body, options.maxline || 64) + '\\r\\n';\n\n  rval += '-----END ' + msg.type + '-----\\r\\n';\n  return rval;\n};\n\n/**\n * Decodes (deserializes) all PEM messages found in the given string.\n *\n * @param str the PEM-formatted string to decode.\n *\n * @return the PEM message objects in an array.\n */\npem.decode = function(str) {\n  var rval = [];\n\n  // split string into PEM messages (be lenient w/EOF on BEGIN line)\n  var rMessage = /\\s*-----BEGIN ([A-Z0-9- ]+)-----\\r?\\n?([\\x21-\\x7e\\s]+?(?:\\r?\\n\\r?\\n))?([:A-Za-z0-9+\\/=\\s]+?)-----END \\1-----/g;\n  var rHeader = /([\\x21-\\x7e]+):\\s*([\\x21-\\x7e\\s^:]+)/;\n  var rCRLF = /\\r?\\n/;\n  var match;\n  while(true) {\n    match = rMessage.exec(str);\n    if(!match) {\n      break;\n    }\n\n    // accept \"NEW CERTIFICATE REQUEST\" as \"CERTIFICATE REQUEST\"\n    // https://datatracker.ietf.org/doc/html/rfc7468#section-7\n    var type = match[1];\n    if(type === 'NEW CERTIFICATE REQUEST') {\n      type = 'CERTIFICATE REQUEST';\n    }\n\n    var msg = {\n      type: type,\n      procType: null,\n      contentDomain: null,\n      dekInfo: null,\n      headers: [],\n      body: forge.util.decode64(match[3])\n    };\n    rval.push(msg);\n\n    // no headers\n    if(!match[2]) {\n      continue;\n    }\n\n    // parse headers\n    var lines = match[2].split(rCRLF);\n    var li = 0;\n    while(match && li < lines.length) {\n      // get line, trim any rhs whitespace\n      var line = lines[li].replace(/\\s+$/, '');\n\n      // RFC2822 unfold any following folded lines\n      for(var nl = li + 1; nl < lines.length; ++nl) {\n        var next = lines[nl];\n        if(!/\\s/.test(next[0])) {\n          break;\n        }\n        line += next;\n        li = nl;\n      }\n\n      // parse header\n      match = line.match(rHeader);\n      if(match) {\n        var header = {name: match[1], values: []};\n        var values = match[2].split(',');\n        for(var vi = 0; vi < values.length; ++vi) {\n          header.values.push(ltrim(values[vi]));\n        }\n\n        // Proc-Type must be the first header\n        if(!msg.procType) {\n          if(header.name !== 'Proc-Type') {\n            throw new Error('Invalid PEM formatted message. The first ' +\n              'encapsulated header must be \"Proc-Type\".');\n          } else if(header.values.length !== 2) {\n            throw new Error('Invalid PEM formatted message. The \"Proc-Type\" ' +\n              'header must have two subfields.');\n          }\n          msg.procType = {version: values[0], type: values[1]};\n        } else if(!msg.contentDomain && header.name === 'Content-Domain') {\n          // special-case Content-Domain\n          msg.contentDomain = values[0] || '';\n        } else if(!msg.dekInfo && header.name === 'DEK-Info') {\n          // special-case DEK-Info\n          if(header.values.length === 0) {\n            throw new Error('Invalid PEM formatted message. The \"DEK-Info\" ' +\n              'header must have at least one subfield.');\n          }\n          msg.dekInfo = {algorithm: values[0], parameters: values[1] || null};\n        } else {\n          msg.headers.push(header);\n        }\n      }\n\n      ++li;\n    }\n\n    if(msg.procType === 'ENCRYPTED' && !msg.dekInfo) {\n      throw new Error('Invalid PEM formatted message. The \"DEK-Info\" ' +\n        'header must be present if \"Proc-Type\" is \"ENCRYPTED\".');\n    }\n  }\n\n  if(rval.length === 0) {\n    throw new Error('Invalid PEM formatted message.');\n  }\n\n  return rval;\n};\n\nfunction foldHeader(header) {\n  var rval = header.name + ': ';\n\n  // ensure values with CRLF are folded\n  var values = [];\n  var insertSpace = function(match, $1) {\n    return ' ' + $1;\n  };\n  for(var i = 0; i < header.values.length; ++i) {\n    values.push(header.values[i].replace(/^(\\S+\\r\\n)/, insertSpace));\n  }\n  rval += values.join(',') + '\\r\\n';\n\n  // do folding\n  var length = 0;\n  var candidate = -1;\n  for(var i = 0; i < rval.length; ++i, ++length) {\n    if(length > 65 && candidate !== -1) {\n      var insert = rval[candidate];\n      if(insert === ',') {\n        ++candidate;\n        rval = rval.substr(0, candidate) + '\\r\\n ' + rval.substr(candidate);\n      } else {\n        rval = rval.substr(0, candidate) +\n          '\\r\\n' + insert + rval.substr(candidate + 1);\n      }\n      length = (i - candidate - 1);\n      candidate = -1;\n      ++i;\n    } else if(rval[i] === ' ' || rval[i] === '\\t' || rval[i] === ',') {\n      candidate = i;\n    }\n  }\n\n  return rval;\n}\n\nfunction ltrim(str) {\n  return str.replace(/^\\s+/, '');\n}\n","/**\n * Message Digest Algorithm 5 with 128-bit digest (MD5) implementation.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2010-2014 Digital Bazaar, Inc.\n */\nvar forge = require('./forge');\nrequire('./md');\nrequire('./util');\n\nvar md5 = module.exports = forge.md5 = forge.md5 || {};\nforge.md.md5 = forge.md.algorithms.md5 = md5;\n\n/**\n * Creates an MD5 message digest object.\n *\n * @return a message digest object.\n */\nmd5.create = function() {\n  // do initialization as necessary\n  if(!_initialized) {\n    _init();\n  }\n\n  // MD5 state contains four 32-bit integers\n  var _state = null;\n\n  // input buffer\n  var _input = forge.util.createBuffer();\n\n  // used for word storage\n  var _w = new Array(16);\n\n  // message digest object\n  var md = {\n    algorithm: 'md5',\n    blockLength: 64,\n    digestLength: 16,\n    // 56-bit length of message so far (does not including padding)\n    messageLength: 0,\n    // true message length\n    fullMessageLength: null,\n    // size of message length in bytes\n    messageLengthSize: 8\n  };\n\n  /**\n   * Starts the digest.\n   *\n   * @return this digest object.\n   */\n  md.start = function() {\n    // up to 56-bit message length for convenience\n    md.messageLength = 0;\n\n    // full message length (set md.messageLength64 for backwards-compatibility)\n    md.fullMessageLength = md.messageLength64 = [];\n    var int32s = md.messageLengthSize / 4;\n    for(var i = 0; i < int32s; ++i) {\n      md.fullMessageLength.push(0);\n    }\n    _input = forge.util.createBuffer();\n    _state = {\n      h0: 0x67452301,\n      h1: 0xEFCDAB89,\n      h2: 0x98BADCFE,\n      h3: 0x10325476\n    };\n    return md;\n  };\n  // start digest automatically for first time\n  md.start();\n\n  /**\n   * Updates the digest with the given message input. The given input can\n   * treated as raw input (no encoding will be applied) or an encoding of\n   * 'utf8' maybe given to encode the input using UTF-8.\n   *\n   * @param msg the message input to update with.\n   * @param encoding the encoding to use (default: 'raw', other: 'utf8').\n   *\n   * @return this digest object.\n   */\n  md.update = function(msg, encoding) {\n    if(encoding === 'utf8') {\n      msg = forge.util.encodeUtf8(msg);\n    }\n\n    // update message length\n    var len = msg.length;\n    md.messageLength += len;\n    len = [(len / 0x100000000) >>> 0, len >>> 0];\n    for(var i = md.fullMessageLength.length - 1; i >= 0; --i) {\n      md.fullMessageLength[i] += len[1];\n      len[1] = len[0] + ((md.fullMessageLength[i] / 0x100000000) >>> 0);\n      md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;\n      len[0] = (len[1] / 0x100000000) >>> 0;\n    }\n\n    // add bytes to input buffer\n    _input.putBytes(msg);\n\n    // process bytes\n    _update(_state, _w, _input);\n\n    // compact input buffer every 2K or if empty\n    if(_input.read > 2048 || _input.length() === 0) {\n      _input.compact();\n    }\n\n    return md;\n  };\n\n  /**\n   * Produces the digest.\n   *\n   * @return a byte buffer containing the digest value.\n   */\n  md.digest = function() {\n    /* Note: Here we copy the remaining bytes in the input buffer and\n    add the appropriate MD5 padding. Then we do the final update\n    on a copy of the state so that if the user wants to get\n    intermediate digests they can do so. */\n\n    /* Determine the number of bytes that must be added to the message\n    to ensure its length is congruent to 448 mod 512. In other words,\n    the data to be digested must be a multiple of 512 bits (or 128 bytes).\n    This data includes the message, some padding, and the length of the\n    message. Since the length of the message will be encoded as 8 bytes (64\n    bits), that means that the last segment of the data must have 56 bytes\n    (448 bits) of message and padding. Therefore, the length of the message\n    plus the padding must be congruent to 448 mod 512 because\n    512 - 128 = 448.\n\n    In order to fill up the message length it must be filled with\n    padding that begins with 1 bit followed by all 0 bits. Padding\n    must *always* be present, so if the message length is already\n    congruent to 448 mod 512, then 512 padding bits must be added. */\n\n    var finalBlock = forge.util.createBuffer();\n    finalBlock.putBytes(_input.bytes());\n\n    // compute remaining size to be digested (include message length size)\n    var remaining = (\n      md.fullMessageLength[md.fullMessageLength.length - 1] +\n      md.messageLengthSize);\n\n    // add padding for overflow blockSize - overflow\n    // _padding starts with 1 byte with first bit is set (byte value 128), then\n    // there may be up to (blockSize - 1) other pad bytes\n    var overflow = remaining & (md.blockLength - 1);\n    finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));\n\n    // serialize message length in bits in little-endian order; since length\n    // is stored in bytes we multiply by 8 and add carry\n    var bits, carry = 0;\n    for(var i = md.fullMessageLength.length - 1; i >= 0; --i) {\n      bits = md.fullMessageLength[i] * 8 + carry;\n      carry = (bits / 0x100000000) >>> 0;\n      finalBlock.putInt32Le(bits >>> 0);\n    }\n\n    var s2 = {\n      h0: _state.h0,\n      h1: _state.h1,\n      h2: _state.h2,\n      h3: _state.h3\n    };\n    _update(s2, _w, finalBlock);\n    var rval = forge.util.createBuffer();\n    rval.putInt32Le(s2.h0);\n    rval.putInt32Le(s2.h1);\n    rval.putInt32Le(s2.h2);\n    rval.putInt32Le(s2.h3);\n    return rval;\n  };\n\n  return md;\n};\n\n// padding, constant tables for calculating md5\nvar _padding = null;\nvar _g = null;\nvar _r = null;\nvar _k = null;\nvar _initialized = false;\n\n/**\n * Initializes the constant tables.\n */\nfunction _init() {\n  // create padding\n  _padding = String.fromCharCode(128);\n  _padding += forge.util.fillString(String.fromCharCode(0x00), 64);\n\n  // g values\n  _g = [\n    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n    1, 6, 11, 0, 5, 10, 15, 4, 9, 14, 3, 8, 13, 2, 7, 12,\n    5, 8, 11, 14, 1, 4, 7, 10, 13, 0, 3, 6, 9, 12, 15, 2,\n    0, 7, 14, 5, 12, 3, 10, 1, 8, 15, 6, 13, 4, 11, 2, 9];\n\n  // rounds table\n  _r = [\n    7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22,\n    5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20,\n    4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23,\n    6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21];\n\n  // get the result of abs(sin(i + 1)) as a 32-bit integer\n  _k = new Array(64);\n  for(var i = 0; i < 64; ++i) {\n    _k[i] = Math.floor(Math.abs(Math.sin(i + 1)) * 0x100000000);\n  }\n\n  // now initialized\n  _initialized = true;\n}\n\n/**\n * Updates an MD5 state with the given byte buffer.\n *\n * @param s the MD5 state to update.\n * @param w the array to use to store words.\n * @param bytes the byte buffer to update with.\n */\nfunction _update(s, w, bytes) {\n  // consume 512 bit (64 byte) chunks\n  var t, a, b, c, d, f, r, i;\n  var len = bytes.length();\n  while(len >= 64) {\n    // initialize hash value for this chunk\n    a = s.h0;\n    b = s.h1;\n    c = s.h2;\n    d = s.h3;\n\n    // round 1\n    for(i = 0; i < 16; ++i) {\n      w[i] = bytes.getInt32Le();\n      f = d ^ (b & (c ^ d));\n      t = (a + f + _k[i] + w[i]);\n      r = _r[i];\n      a = d;\n      d = c;\n      c = b;\n      b += (t << r) | (t >>> (32 - r));\n    }\n    // round 2\n    for(; i < 32; ++i) {\n      f = c ^ (d & (b ^ c));\n      t = (a + f + _k[i] + w[_g[i]]);\n      r = _r[i];\n      a = d;\n      d = c;\n      c = b;\n      b += (t << r) | (t >>> (32 - r));\n    }\n    // round 3\n    for(; i < 48; ++i) {\n      f = b ^ c ^ d;\n      t = (a + f + _k[i] + w[_g[i]]);\n      r = _r[i];\n      a = d;\n      d = c;\n      c = b;\n      b += (t << r) | (t >>> (32 - r));\n    }\n    // round 4\n    for(; i < 64; ++i) {\n      f = c ^ (b | ~d);\n      t = (a + f + _k[i] + w[_g[i]]);\n      r = _r[i];\n      a = d;\n      d = c;\n      c = b;\n      b += (t << r) | (t >>> (32 - r));\n    }\n\n    // update hash state\n    s.h0 = (s.h0 + a) | 0;\n    s.h1 = (s.h1 + b) | 0;\n    s.h2 = (s.h2 + c) | 0;\n    s.h3 = (s.h3 + d) | 0;\n\n    len -= 64;\n  }\n}\n","/**\n * Partial implementation of PKCS#1 v2.2: RSA-OEAP\n *\n * Modified but based on the following MIT and BSD licensed code:\n *\n * https://github.com/kjur/jsjws/blob/master/rsa.js:\n *\n * The 'jsjws'(JSON Web Signature JavaScript Library) License\n *\n * Copyright (c) 2012 Kenji Urushima\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * http://webrsa.cvs.sourceforge.net/viewvc/webrsa/Client/RSAES-OAEP.js?content-type=text%2Fplain:\n *\n * RSAES-OAEP.js\n * $Id: RSAES-OAEP.js,v 1.1.1.1 2003/03/19 15:37:20 ellispritchard Exp $\n * JavaScript Implementation of PKCS #1 v2.1 RSA CRYPTOGRAPHY STANDARD (RSA Laboratories, June 14, 2002)\n * Copyright (C) Ellis Pritchard, Guardian Unlimited 2003.\n * Contact: ellis@nukinetics.com\n * Distributed under the BSD License.\n *\n * Official documentation: http://www.rsa.com/rsalabs/node.asp?id=2125\n *\n * @author Evan Jones (http://evanjones.ca/)\n * @author Dave Longley\n *\n * Copyright (c) 2013-2014 Digital Bazaar, Inc.\n */\nvar forge = require('./forge');\nrequire('./util');\nrequire('./random');\nrequire('./sha1');\n\n// shortcut for PKCS#1 API\nvar pkcs1 = module.exports = forge.pkcs1 = forge.pkcs1 || {};\n\n/**\n * Encode the given RSAES-OAEP message (M) using key, with optional label (L)\n * and seed.\n *\n * This method does not perform RSA encryption, it only encodes the message\n * using RSAES-OAEP.\n *\n * @param key the RSA key to use.\n * @param message the message to encode.\n * @param options the options to use:\n *          label an optional label to use.\n *          seed the seed to use.\n *          md the message digest object to use, undefined for SHA-1.\n *          mgf1 optional mgf1 parameters:\n *            md the message digest object to use for MGF1.\n *\n * @return the encoded message bytes.\n */\npkcs1.encode_rsa_oaep = function(key, message, options) {\n  // parse arguments\n  var label;\n  var seed;\n  var md;\n  var mgf1Md;\n  // legacy args (label, seed, md)\n  if(typeof options === 'string') {\n    label = options;\n    seed = arguments[3] || undefined;\n    md = arguments[4] || undefined;\n  } else if(options) {\n    label = options.label || undefined;\n    seed = options.seed || undefined;\n    md = options.md || undefined;\n    if(options.mgf1 && options.mgf1.md) {\n      mgf1Md = options.mgf1.md;\n    }\n  }\n\n  // default OAEP to SHA-1 message digest\n  if(!md) {\n    md = forge.md.sha1.create();\n  } else {\n    md.start();\n  }\n\n  // default MGF-1 to same as OAEP\n  if(!mgf1Md) {\n    mgf1Md = md;\n  }\n\n  // compute length in bytes and check output\n  var keyLength = Math.ceil(key.n.bitLength() / 8);\n  var maxLength = keyLength - 2 * md.digestLength - 2;\n  if(message.length > maxLength) {\n    var error = new Error('RSAES-OAEP input message length is too long.');\n    error.length = message.length;\n    error.maxLength = maxLength;\n    throw error;\n  }\n\n  if(!label) {\n    label = '';\n  }\n  md.update(label, 'raw');\n  var lHash = md.digest();\n\n  var PS = '';\n  var PS_length = maxLength - message.length;\n  for(var i = 0; i < PS_length; i++) {\n    PS += '\\x00';\n  }\n\n  var DB = lHash.getBytes() + PS + '\\x01' + message;\n\n  if(!seed) {\n    seed = forge.random.getBytes(md.digestLength);\n  } else if(seed.length !== md.digestLength) {\n    var error = new Error('Invalid RSAES-OAEP seed. The seed length must ' +\n      'match the digest length.');\n    error.seedLength = seed.length;\n    error.digestLength = md.digestLength;\n    throw error;\n  }\n\n  var dbMask = rsa_mgf1(seed, keyLength - md.digestLength - 1, mgf1Md);\n  var maskedDB = forge.util.xorBytes(DB, dbMask, DB.length);\n\n  var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md);\n  var maskedSeed = forge.util.xorBytes(seed, seedMask, seed.length);\n\n  // return encoded message\n  return '\\x00' + maskedSeed + maskedDB;\n};\n\n/**\n * Decode the given RSAES-OAEP encoded message (EM) using key, with optional\n * label (L).\n *\n * This method does not perform RSA decryption, it only decodes the message\n * using RSAES-OAEP.\n *\n * @param key the RSA key to use.\n * @param em the encoded message to decode.\n * @param options the options to use:\n *          label an optional label to use.\n *          md the message digest object to use for OAEP, undefined for SHA-1.\n *          mgf1 optional mgf1 parameters:\n *            md the message digest object to use for MGF1.\n *\n * @return the decoded message bytes.\n */\npkcs1.decode_rsa_oaep = function(key, em, options) {\n  // parse args\n  var label;\n  var md;\n  var mgf1Md;\n  // legacy args\n  if(typeof options === 'string') {\n    label = options;\n    md = arguments[3] || undefined;\n  } else if(options) {\n    label = options.label || undefined;\n    md = options.md || undefined;\n    if(options.mgf1 && options.mgf1.md) {\n      mgf1Md = options.mgf1.md;\n    }\n  }\n\n  // compute length in bytes\n  var keyLength = Math.ceil(key.n.bitLength() / 8);\n\n  if(em.length !== keyLength) {\n    var error = new Error('RSAES-OAEP encoded message length is invalid.');\n    error.length = em.length;\n    error.expectedLength = keyLength;\n    throw error;\n  }\n\n  // default OAEP to SHA-1 message digest\n  if(md === undefined) {\n    md = forge.md.sha1.create();\n  } else {\n    md.start();\n  }\n\n  // default MGF-1 to same as OAEP\n  if(!mgf1Md) {\n    mgf1Md = md;\n  }\n\n  if(keyLength < 2 * md.digestLength + 2) {\n    throw new Error('RSAES-OAEP key is too short for the hash function.');\n  }\n\n  if(!label) {\n    label = '';\n  }\n  md.update(label, 'raw');\n  var lHash = md.digest().getBytes();\n\n  // split the message into its parts\n  var y = em.charAt(0);\n  var maskedSeed = em.substring(1, md.digestLength + 1);\n  var maskedDB = em.substring(1 + md.digestLength);\n\n  var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md);\n  var seed = forge.util.xorBytes(maskedSeed, seedMask, maskedSeed.length);\n\n  var dbMask = rsa_mgf1(seed, keyLength - md.digestLength - 1, mgf1Md);\n  var db = forge.util.xorBytes(maskedDB, dbMask, maskedDB.length);\n\n  var lHashPrime = db.substring(0, md.digestLength);\n\n  // constant time check that all values match what is expected\n  var error = (y !== '\\x00');\n\n  // constant time check lHash vs lHashPrime\n  for(var i = 0; i < md.digestLength; ++i) {\n    error |= (lHash.charAt(i) !== lHashPrime.charAt(i));\n  }\n\n  // \"constant time\" find the 0x1 byte separating the padding (zeros) from the\n  // message\n  // TODO: It must be possible to do this in a better/smarter way?\n  var in_ps = 1;\n  var index = md.digestLength;\n  for(var j = md.digestLength; j < db.length; j++) {\n    var code = db.charCodeAt(j);\n\n    var is_0 = (code & 0x1) ^ 0x1;\n\n    // non-zero if not 0 or 1 in the ps section\n    var error_mask = in_ps ? 0xfffe : 0x0000;\n    error |= (code & error_mask);\n\n    // latch in_ps to zero after we find 0x1\n    in_ps = in_ps & is_0;\n    index += in_ps;\n  }\n\n  if(error || db.charCodeAt(index) !== 0x1) {\n    throw new Error('Invalid RSAES-OAEP padding.');\n  }\n\n  return db.substring(index + 1);\n};\n\nfunction rsa_mgf1(seed, maskLength, hash) {\n  // default to SHA-1 message digest\n  if(!hash) {\n    hash = forge.md.sha1.create();\n  }\n  var t = '';\n  var count = Math.ceil(maskLength / hash.digestLength);\n  for(var i = 0; i < count; ++i) {\n    var c = String.fromCharCode(\n      (i >> 24) & 0xFF, (i >> 16) & 0xFF, (i >> 8) & 0xFF, i & 0xFF);\n    hash.start();\n    hash.update(seed + c);\n    t += hash.digest().getBytes();\n  }\n  return t.substring(0, maskLength);\n}\n","/**\n * Javascript implementation of PKCS#12.\n *\n * @author Dave Longley\n * @author Stefan Siegl <stesie@brokenpipe.de>\n *\n * Copyright (c) 2010-2014 Digital Bazaar, Inc.\n * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>\n *\n * The ASN.1 representation of PKCS#12 is as follows\n * (see ftp://ftp.rsasecurity.com/pub/pkcs/pkcs-12/pkcs-12-tc1.pdf for details)\n *\n * PFX ::= SEQUENCE {\n *   version  INTEGER {v3(3)}(v3,...),\n *   authSafe ContentInfo,\n *   macData  MacData OPTIONAL\n * }\n *\n * MacData ::= SEQUENCE {\n *   mac DigestInfo,\n *   macSalt OCTET STRING,\n *   iterations INTEGER DEFAULT 1\n * }\n * Note: The iterations default is for historical reasons and its use is\n * deprecated. A higher value, like 1024, is recommended.\n *\n * DigestInfo is defined in PKCS#7 as follows:\n *\n * DigestInfo ::= SEQUENCE {\n *   digestAlgorithm DigestAlgorithmIdentifier,\n *   digest Digest\n * }\n *\n * DigestAlgorithmIdentifier ::= AlgorithmIdentifier\n *\n * The AlgorithmIdentifier contains an Object Identifier (OID) and parameters\n * for the algorithm, if any. In the case of SHA1 there is none.\n *\n * AlgorithmIdentifer ::= SEQUENCE {\n *    algorithm OBJECT IDENTIFIER,\n *    parameters ANY DEFINED BY algorithm OPTIONAL\n * }\n *\n * Digest ::= OCTET STRING\n *\n *\n * ContentInfo ::= SEQUENCE {\n *   contentType ContentType,\n *   content     [0] EXPLICIT ANY DEFINED BY contentType OPTIONAL\n * }\n *\n * ContentType ::= OBJECT IDENTIFIER\n *\n * AuthenticatedSafe ::= SEQUENCE OF ContentInfo\n * -- Data if unencrypted\n * -- EncryptedData if password-encrypted\n * -- EnvelopedData if public key-encrypted\n *\n *\n * SafeContents ::= SEQUENCE OF SafeBag\n *\n * SafeBag ::= SEQUENCE {\n *   bagId     BAG-TYPE.&id ({PKCS12BagSet})\n *   bagValue  [0] EXPLICIT BAG-TYPE.&Type({PKCS12BagSet}{@bagId}),\n *   bagAttributes SET OF PKCS12Attribute OPTIONAL\n * }\n *\n * PKCS12Attribute ::= SEQUENCE {\n *   attrId ATTRIBUTE.&id ({PKCS12AttrSet}),\n *   attrValues SET OF ATTRIBUTE.&Type ({PKCS12AttrSet}{@attrId})\n * } -- This type is compatible with the X.500 type 'Attribute'\n *\n * PKCS12AttrSet ATTRIBUTE ::= {\n *   friendlyName | -- from PKCS #9\n *   localKeyId, -- from PKCS #9\n *   ... -- Other attributes are allowed\n * }\n *\n * CertBag ::= SEQUENCE {\n *   certId    BAG-TYPE.&id   ({CertTypes}),\n *   certValue [0] EXPLICIT BAG-TYPE.&Type ({CertTypes}{@certId})\n * }\n *\n * x509Certificate BAG-TYPE ::= {OCTET STRING IDENTIFIED BY {certTypes 1}}\n *   -- DER-encoded X.509 certificate stored in OCTET STRING\n *\n * sdsiCertificate BAG-TYPE ::= {IA5String IDENTIFIED BY {certTypes 2}}\n * -- Base64-encoded SDSI certificate stored in IA5String\n *\n * CertTypes BAG-TYPE ::= {\n *   x509Certificate |\n *   sdsiCertificate,\n *   ... -- For future extensions\n * }\n */\nvar forge = require('./forge');\nrequire('./asn1');\nrequire('./hmac');\nrequire('./oids');\nrequire('./pkcs7asn1');\nrequire('./pbe');\nrequire('./random');\nrequire('./rsa');\nrequire('./sha1');\nrequire('./util');\nrequire('./x509');\n\n// shortcut for asn.1 & PKI API\nvar asn1 = forge.asn1;\nvar pki = forge.pki;\n\n// shortcut for PKCS#12 API\nvar p12 = module.exports = forge.pkcs12 = forge.pkcs12 || {};\n\nvar contentInfoValidator = {\n  name: 'ContentInfo',\n  tagClass: asn1.Class.UNIVERSAL,\n  type: asn1.Type.SEQUENCE,  // a ContentInfo\n  constructed: true,\n  value: [{\n    name: 'ContentInfo.contentType',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.OID,\n    constructed: false,\n    capture: 'contentType'\n  }, {\n    name: 'ContentInfo.content',\n    tagClass: asn1.Class.CONTEXT_SPECIFIC,\n    constructed: true,\n    captureAsn1: 'content'\n  }]\n};\n\nvar pfxValidator = {\n  name: 'PFX',\n  tagClass: asn1.Class.UNIVERSAL,\n  type: asn1.Type.SEQUENCE,\n  constructed: true,\n  value: [{\n    name: 'PFX.version',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.INTEGER,\n    constructed: false,\n    capture: 'version'\n  },\n  contentInfoValidator, {\n    name: 'PFX.macData',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SEQUENCE,\n    constructed: true,\n    optional: true,\n    captureAsn1: 'mac',\n    value: [{\n      name: 'PFX.macData.mac',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.SEQUENCE,  // DigestInfo\n      constructed: true,\n      value: [{\n        name: 'PFX.macData.mac.digestAlgorithm',\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.SEQUENCE,  // DigestAlgorithmIdentifier\n        constructed: true,\n        value: [{\n          name: 'PFX.macData.mac.digestAlgorithm.algorithm',\n          tagClass: asn1.Class.UNIVERSAL,\n          type: asn1.Type.OID,\n          constructed: false,\n          capture: 'macAlgorithm'\n        }, {\n          name: 'PFX.macData.mac.digestAlgorithm.parameters',\n          tagClass: asn1.Class.UNIVERSAL,\n          captureAsn1: 'macAlgorithmParameters'\n        }]\n      }, {\n        name: 'PFX.macData.mac.digest',\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.OCTETSTRING,\n        constructed: false,\n        capture: 'macDigest'\n      }]\n    }, {\n      name: 'PFX.macData.macSalt',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.OCTETSTRING,\n      constructed: false,\n      capture: 'macSalt'\n    }, {\n      name: 'PFX.macData.iterations',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.INTEGER,\n      constructed: false,\n      optional: true,\n      capture: 'macIterations'\n    }]\n  }]\n};\n\nvar safeBagValidator = {\n  name: 'SafeBag',\n  tagClass: asn1.Class.UNIVERSAL,\n  type: asn1.Type.SEQUENCE,\n  constructed: true,\n  value: [{\n    name: 'SafeBag.bagId',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.OID,\n    constructed: false,\n    capture: 'bagId'\n  }, {\n    name: 'SafeBag.bagValue',\n    tagClass: asn1.Class.CONTEXT_SPECIFIC,\n    constructed: true,\n    captureAsn1: 'bagValue'\n  }, {\n    name: 'SafeBag.bagAttributes',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SET,\n    constructed: true,\n    optional: true,\n    capture: 'bagAttributes'\n  }]\n};\n\nvar attributeValidator = {\n  name: 'Attribute',\n  tagClass: asn1.Class.UNIVERSAL,\n  type: asn1.Type.SEQUENCE,\n  constructed: true,\n  value: [{\n    name: 'Attribute.attrId',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.OID,\n    constructed: false,\n    capture: 'oid'\n  }, {\n    name: 'Attribute.attrValues',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SET,\n    constructed: true,\n    capture: 'values'\n  }]\n};\n\nvar certBagValidator = {\n  name: 'CertBag',\n  tagClass: asn1.Class.UNIVERSAL,\n  type: asn1.Type.SEQUENCE,\n  constructed: true,\n  value: [{\n    name: 'CertBag.certId',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.OID,\n    constructed: false,\n    capture: 'certId'\n  }, {\n    name: 'CertBag.certValue',\n    tagClass: asn1.Class.CONTEXT_SPECIFIC,\n    constructed: true,\n    /* So far we only support X.509 certificates (which are wrapped in\n       an OCTET STRING, hence hard code that here). */\n    value: [{\n      name: 'CertBag.certValue[0]',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Class.OCTETSTRING,\n      constructed: false,\n      capture: 'cert'\n    }]\n  }]\n};\n\n/**\n * Search SafeContents structure for bags with matching attributes.\n *\n * The search can optionally be narrowed by a certain bag type.\n *\n * @param safeContents the SafeContents structure to search in.\n * @param attrName the name of the attribute to compare against.\n * @param attrValue the attribute value to search for.\n * @param [bagType] bag type to narrow search by.\n *\n * @return an array of matching bags.\n */\nfunction _getBagsByAttribute(safeContents, attrName, attrValue, bagType) {\n  var result = [];\n\n  for(var i = 0; i < safeContents.length; i++) {\n    for(var j = 0; j < safeContents[i].safeBags.length; j++) {\n      var bag = safeContents[i].safeBags[j];\n      if(bagType !== undefined && bag.type !== bagType) {\n        continue;\n      }\n      // only filter by bag type, no attribute specified\n      if(attrName === null) {\n        result.push(bag);\n        continue;\n      }\n      if(bag.attributes[attrName] !== undefined &&\n        bag.attributes[attrName].indexOf(attrValue) >= 0) {\n        result.push(bag);\n      }\n    }\n  }\n\n  return result;\n}\n\n/**\n * Converts a PKCS#12 PFX in ASN.1 notation into a PFX object.\n *\n * @param obj The PKCS#12 PFX in ASN.1 notation.\n * @param strict true to use strict DER decoding, false not to (default: true).\n * @param {String} password Password to decrypt with (optional).\n *\n * @return PKCS#12 PFX object.\n */\np12.pkcs12FromAsn1 = function(obj, strict, password) {\n  // handle args\n  if(typeof strict === 'string') {\n    password = strict;\n    strict = true;\n  } else if(strict === undefined) {\n    strict = true;\n  }\n\n  // validate PFX and capture data\n  var capture = {};\n  var errors = [];\n  if(!asn1.validate(obj, pfxValidator, capture, errors)) {\n    var error = new Error('Cannot read PKCS#12 PFX. ' +\n      'ASN.1 object is not an PKCS#12 PFX.');\n    error.errors = error;\n    throw error;\n  }\n\n  var pfx = {\n    version: capture.version.charCodeAt(0),\n    safeContents: [],\n\n    /**\n     * Gets bags with matching attributes.\n     *\n     * @param filter the attributes to filter by:\n     *          [localKeyId] the localKeyId to search for.\n     *          [localKeyIdHex] the localKeyId in hex to search for.\n     *          [friendlyName] the friendly name to search for.\n     *          [bagType] bag type to narrow each attribute search by.\n     *\n     * @return a map of attribute type to an array of matching bags or, if no\n     *           attribute was given but a bag type, the map key will be the\n     *           bag type.\n     */\n    getBags: function(filter) {\n      var rval = {};\n\n      var localKeyId;\n      if('localKeyId' in filter) {\n        localKeyId = filter.localKeyId;\n      } else if('localKeyIdHex' in filter) {\n        localKeyId = forge.util.hexToBytes(filter.localKeyIdHex);\n      }\n\n      // filter on bagType only\n      if(localKeyId === undefined && !('friendlyName' in filter) &&\n        'bagType' in filter) {\n        rval[filter.bagType] = _getBagsByAttribute(\n          pfx.safeContents, null, null, filter.bagType);\n      }\n\n      if(localKeyId !== undefined) {\n        rval.localKeyId = _getBagsByAttribute(\n          pfx.safeContents, 'localKeyId',\n          localKeyId, filter.bagType);\n      }\n      if('friendlyName' in filter) {\n        rval.friendlyName = _getBagsByAttribute(\n          pfx.safeContents, 'friendlyName',\n          filter.friendlyName, filter.bagType);\n      }\n\n      return rval;\n    },\n\n    /**\n     * DEPRECATED: use getBags() instead.\n     *\n     * Get bags with matching friendlyName attribute.\n     *\n     * @param friendlyName the friendly name to search for.\n     * @param [bagType] bag type to narrow search by.\n     *\n     * @return an array of bags with matching friendlyName attribute.\n     */\n    getBagsByFriendlyName: function(friendlyName, bagType) {\n      return _getBagsByAttribute(\n        pfx.safeContents, 'friendlyName', friendlyName, bagType);\n    },\n\n    /**\n     * DEPRECATED: use getBags() instead.\n     *\n     * Get bags with matching localKeyId attribute.\n     *\n     * @param localKeyId the localKeyId to search for.\n     * @param [bagType] bag type to narrow search by.\n     *\n     * @return an array of bags with matching localKeyId attribute.\n     */\n    getBagsByLocalKeyId: function(localKeyId, bagType) {\n      return _getBagsByAttribute(\n        pfx.safeContents, 'localKeyId', localKeyId, bagType);\n    }\n  };\n\n  if(capture.version.charCodeAt(0) !== 3) {\n    var error = new Error('PKCS#12 PFX of version other than 3 not supported.');\n    error.version = capture.version.charCodeAt(0);\n    throw error;\n  }\n\n  if(asn1.derToOid(capture.contentType) !== pki.oids.data) {\n    var error = new Error('Only PKCS#12 PFX in password integrity mode supported.');\n    error.oid = asn1.derToOid(capture.contentType);\n    throw error;\n  }\n\n  var data = capture.content.value[0];\n  if(data.tagClass !== asn1.Class.UNIVERSAL ||\n     data.type !== asn1.Type.OCTETSTRING) {\n    throw new Error('PKCS#12 authSafe content data is not an OCTET STRING.');\n  }\n  data = _decodePkcs7Data(data);\n\n  // check for MAC\n  if(capture.mac) {\n    var md = null;\n    var macKeyBytes = 0;\n    var macAlgorithm = asn1.derToOid(capture.macAlgorithm);\n    switch(macAlgorithm) {\n    case pki.oids.sha1:\n      md = forge.md.sha1.create();\n      macKeyBytes = 20;\n      break;\n    case pki.oids.sha256:\n      md = forge.md.sha256.create();\n      macKeyBytes = 32;\n      break;\n    case pki.oids.sha384:\n      md = forge.md.sha384.create();\n      macKeyBytes = 48;\n      break;\n    case pki.oids.sha512:\n      md = forge.md.sha512.create();\n      macKeyBytes = 64;\n      break;\n    case pki.oids.md5:\n      md = forge.md.md5.create();\n      macKeyBytes = 16;\n      break;\n    }\n    if(md === null) {\n      throw new Error('PKCS#12 uses unsupported MAC algorithm: ' + macAlgorithm);\n    }\n\n    // verify MAC (iterations default to 1)\n    var macSalt = new forge.util.ByteBuffer(capture.macSalt);\n    var macIterations = (('macIterations' in capture) ?\n      parseInt(forge.util.bytesToHex(capture.macIterations), 16) : 1);\n    var macKey = p12.generateKey(\n      password, macSalt, 3, macIterations, macKeyBytes, md);\n    var mac = forge.hmac.create();\n    mac.start(md, macKey);\n    mac.update(data.value);\n    var macValue = mac.getMac();\n    if(macValue.getBytes() !== capture.macDigest) {\n      throw new Error('PKCS#12 MAC could not be verified. Invalid password?');\n    }\n  }\n\n  _decodeAuthenticatedSafe(pfx, data.value, strict, password);\n  return pfx;\n};\n\n/**\n * Decodes PKCS#7 Data. PKCS#7 (RFC 2315) defines \"Data\" as an OCTET STRING,\n * but it is sometimes an OCTET STRING that is composed/constructed of chunks,\n * each its own OCTET STRING. This is BER-encoding vs. DER-encoding. This\n * function transforms this corner-case into the usual simple,\n * non-composed/constructed OCTET STRING.\n *\n * This function may be moved to ASN.1 at some point to better deal with\n * more BER-encoding issues, should they arise.\n *\n * @param data the ASN.1 Data object to transform.\n */\nfunction _decodePkcs7Data(data) {\n  // handle special case of \"chunked\" data content: an octet string composed\n  // of other octet strings\n  if(data.composed || data.constructed) {\n    var value = forge.util.createBuffer();\n    for(var i = 0; i < data.value.length; ++i) {\n      value.putBytes(data.value[i].value);\n    }\n    data.composed = data.constructed = false;\n    data.value = value.getBytes();\n  }\n  return data;\n}\n\n/**\n * Decode PKCS#12 AuthenticatedSafe (BER encoded) into PFX object.\n *\n * The AuthenticatedSafe is a BER-encoded SEQUENCE OF ContentInfo.\n *\n * @param pfx The PKCS#12 PFX object to fill.\n * @param {String} authSafe BER-encoded AuthenticatedSafe.\n * @param strict true to use strict DER decoding, false not to.\n * @param {String} password Password to decrypt with (optional).\n */\nfunction _decodeAuthenticatedSafe(pfx, authSafe, strict, password) {\n  authSafe = asn1.fromDer(authSafe, strict);  /* actually it's BER encoded */\n\n  if(authSafe.tagClass !== asn1.Class.UNIVERSAL ||\n     authSafe.type !== asn1.Type.SEQUENCE ||\n     authSafe.constructed !== true) {\n    throw new Error('PKCS#12 AuthenticatedSafe expected to be a ' +\n      'SEQUENCE OF ContentInfo');\n  }\n\n  for(var i = 0; i < authSafe.value.length; i++) {\n    var contentInfo = authSafe.value[i];\n\n    // validate contentInfo and capture data\n    var capture = {};\n    var errors = [];\n    if(!asn1.validate(contentInfo, contentInfoValidator, capture, errors)) {\n      var error = new Error('Cannot read ContentInfo.');\n      error.errors = errors;\n      throw error;\n    }\n\n    var obj = {\n      encrypted: false\n    };\n    var safeContents = null;\n    var data = capture.content.value[0];\n    switch(asn1.derToOid(capture.contentType)) {\n    case pki.oids.data:\n      if(data.tagClass !== asn1.Class.UNIVERSAL ||\n         data.type !== asn1.Type.OCTETSTRING) {\n        throw new Error('PKCS#12 SafeContents Data is not an OCTET STRING.');\n      }\n      safeContents = _decodePkcs7Data(data).value;\n      break;\n    case pki.oids.encryptedData:\n      safeContents = _decryptSafeContents(data, password);\n      obj.encrypted = true;\n      break;\n    default:\n      var error = new Error('Unsupported PKCS#12 contentType.');\n      error.contentType = asn1.derToOid(capture.contentType);\n      throw error;\n    }\n\n    obj.safeBags = _decodeSafeContents(safeContents, strict, password);\n    pfx.safeContents.push(obj);\n  }\n}\n\n/**\n * Decrypt PKCS#7 EncryptedData structure.\n *\n * @param data ASN.1 encoded EncryptedContentInfo object.\n * @param password The user-provided password.\n *\n * @return The decrypted SafeContents (ASN.1 object).\n */\nfunction _decryptSafeContents(data, password) {\n  var capture = {};\n  var errors = [];\n  if(!asn1.validate(\n    data, forge.pkcs7.asn1.encryptedDataValidator, capture, errors)) {\n    var error = new Error('Cannot read EncryptedContentInfo.');\n    error.errors = errors;\n    throw error;\n  }\n\n  var oid = asn1.derToOid(capture.contentType);\n  if(oid !== pki.oids.data) {\n    var error = new Error(\n      'PKCS#12 EncryptedContentInfo ContentType is not Data.');\n    error.oid = oid;\n    throw error;\n  }\n\n  // get cipher\n  oid = asn1.derToOid(capture.encAlgorithm);\n  var cipher = pki.pbe.getCipher(oid, capture.encParameter, password);\n\n  // get encrypted data\n  var encryptedContentAsn1 = _decodePkcs7Data(capture.encryptedContentAsn1);\n  var encrypted = forge.util.createBuffer(encryptedContentAsn1.value);\n\n  cipher.update(encrypted);\n  if(!cipher.finish()) {\n    throw new Error('Failed to decrypt PKCS#12 SafeContents.');\n  }\n\n  return cipher.output.getBytes();\n}\n\n/**\n * Decode PKCS#12 SafeContents (BER-encoded) into array of Bag objects.\n *\n * The safeContents is a BER-encoded SEQUENCE OF SafeBag.\n *\n * @param {String} safeContents BER-encoded safeContents.\n * @param strict true to use strict DER decoding, false not to.\n * @param {String} password Password to decrypt with (optional).\n *\n * @return {Array} Array of Bag objects.\n */\nfunction _decodeSafeContents(safeContents, strict, password) {\n  // if strict and no safe contents, return empty safes\n  if(!strict && safeContents.length === 0) {\n    return [];\n  }\n\n  // actually it's BER-encoded\n  safeContents = asn1.fromDer(safeContents, strict);\n\n  if(safeContents.tagClass !== asn1.Class.UNIVERSAL ||\n    safeContents.type !== asn1.Type.SEQUENCE ||\n    safeContents.constructed !== true) {\n    throw new Error(\n      'PKCS#12 SafeContents expected to be a SEQUENCE OF SafeBag.');\n  }\n\n  var res = [];\n  for(var i = 0; i < safeContents.value.length; i++) {\n    var safeBag = safeContents.value[i];\n\n    // validate SafeBag and capture data\n    var capture = {};\n    var errors = [];\n    if(!asn1.validate(safeBag, safeBagValidator, capture, errors)) {\n      var error = new Error('Cannot read SafeBag.');\n      error.errors = errors;\n      throw error;\n    }\n\n    /* Create bag object and push to result array. */\n    var bag = {\n      type: asn1.derToOid(capture.bagId),\n      attributes: _decodeBagAttributes(capture.bagAttributes)\n    };\n    res.push(bag);\n\n    var validator, decoder;\n    var bagAsn1 = capture.bagValue.value[0];\n    switch(bag.type) {\n      case pki.oids.pkcs8ShroudedKeyBag:\n        /* bagAsn1 has a EncryptedPrivateKeyInfo, which we need to decrypt.\n           Afterwards we can handle it like a keyBag,\n           which is a PrivateKeyInfo. */\n        bagAsn1 = pki.decryptPrivateKeyInfo(bagAsn1, password);\n        if(bagAsn1 === null) {\n          throw new Error(\n            'Unable to decrypt PKCS#8 ShroudedKeyBag, wrong password?');\n        }\n\n        /* fall through */\n      case pki.oids.keyBag:\n        /* A PKCS#12 keyBag is a simple PrivateKeyInfo as understood by our\n           PKI module, hence we don't have to do validation/capturing here,\n           just pass what we already got. */\n        try {\n          bag.key = pki.privateKeyFromAsn1(bagAsn1);\n        } catch(e) {\n          // ignore unknown key type, pass asn1 value\n          bag.key = null;\n          bag.asn1 = bagAsn1;\n        }\n        continue;  /* Nothing more to do. */\n\n      case pki.oids.certBag:\n        /* A PKCS#12 certBag can wrap both X.509 and sdsi certificates.\n           Therefore put the SafeBag content through another validator to\n           capture the fields.  Afterwards check & store the results. */\n        validator = certBagValidator;\n        decoder = function() {\n          if(asn1.derToOid(capture.certId) !== pki.oids.x509Certificate) {\n            var error = new Error(\n              'Unsupported certificate type, only X.509 supported.');\n            error.oid = asn1.derToOid(capture.certId);\n            throw error;\n          }\n\n          // true=produce cert hash\n          var certAsn1 = asn1.fromDer(capture.cert, strict);\n          try {\n            bag.cert = pki.certificateFromAsn1(certAsn1, true);\n          } catch(e) {\n            // ignore unknown cert type, pass asn1 value\n            bag.cert = null;\n            bag.asn1 = certAsn1;\n          }\n        };\n        break;\n\n      default:\n        var error = new Error('Unsupported PKCS#12 SafeBag type.');\n        error.oid = bag.type;\n        throw error;\n    }\n\n    /* Validate SafeBag value (i.e. CertBag, etc.) and capture data if needed. */\n    if(validator !== undefined &&\n       !asn1.validate(bagAsn1, validator, capture, errors)) {\n      var error = new Error('Cannot read PKCS#12 ' + validator.name);\n      error.errors = errors;\n      throw error;\n    }\n\n    /* Call decoder function from above to store the results. */\n    decoder();\n  }\n\n  return res;\n}\n\n/**\n * Decode PKCS#12 SET OF PKCS12Attribute into JavaScript object.\n *\n * @param attributes SET OF PKCS12Attribute (ASN.1 object).\n *\n * @return the decoded attributes.\n */\nfunction _decodeBagAttributes(attributes) {\n  var decodedAttrs = {};\n\n  if(attributes !== undefined) {\n    for(var i = 0; i < attributes.length; ++i) {\n      var capture = {};\n      var errors = [];\n      if(!asn1.validate(attributes[i], attributeValidator, capture, errors)) {\n        var error = new Error('Cannot read PKCS#12 BagAttribute.');\n        error.errors = errors;\n        throw error;\n      }\n\n      var oid = asn1.derToOid(capture.oid);\n      if(pki.oids[oid] === undefined) {\n        // unsupported attribute type, ignore.\n        continue;\n      }\n\n      decodedAttrs[pki.oids[oid]] = [];\n      for(var j = 0; j < capture.values.length; ++j) {\n        decodedAttrs[pki.oids[oid]].push(capture.values[j].value);\n      }\n    }\n  }\n\n  return decodedAttrs;\n}\n\n/**\n * Wraps a private key and certificate in a PKCS#12 PFX wrapper. If a\n * password is provided then the private key will be encrypted.\n *\n * An entire certificate chain may also be included. To do this, pass\n * an array for the \"cert\" parameter where the first certificate is\n * the one that is paired with the private key and each subsequent one\n * verifies the previous one. The certificates may be in PEM format or\n * have been already parsed by Forge.\n *\n * @todo implement password-based-encryption for the whole package\n *\n * @param key the private key.\n * @param cert the certificate (may be an array of certificates in order\n *          to specify a certificate chain).\n * @param password the password to use, null for none.\n * @param options:\n *          algorithm the encryption algorithm to use\n *            ('aes128', 'aes192', 'aes256', '3des'), defaults to 'aes128'.\n *          count the iteration count to use.\n *          saltSize the salt size to use.\n *          useMac true to include a MAC, false not to, defaults to true.\n *          localKeyId the local key ID to use, in hex.\n *          friendlyName the friendly name to use.\n *          generateLocalKeyId true to generate a random local key ID,\n *            false not to, defaults to true.\n *\n * @return the PKCS#12 PFX ASN.1 object.\n */\np12.toPkcs12Asn1 = function(key, cert, password, options) {\n  // set default options\n  options = options || {};\n  options.saltSize = options.saltSize || 8;\n  options.count = options.count || 2048;\n  options.algorithm = options.algorithm || options.encAlgorithm || 'aes128';\n  if(!('useMac' in options)) {\n    options.useMac = true;\n  }\n  if(!('localKeyId' in options)) {\n    options.localKeyId = null;\n  }\n  if(!('generateLocalKeyId' in options)) {\n    options.generateLocalKeyId = true;\n  }\n\n  var localKeyId = options.localKeyId;\n  var bagAttrs;\n  if(localKeyId !== null) {\n    localKeyId = forge.util.hexToBytes(localKeyId);\n  } else if(options.generateLocalKeyId) {\n    // use SHA-1 of paired cert, if available\n    if(cert) {\n      var pairedCert = forge.util.isArray(cert) ? cert[0] : cert;\n      if(typeof pairedCert === 'string') {\n        pairedCert = pki.certificateFromPem(pairedCert);\n      }\n      var sha1 = forge.md.sha1.create();\n      sha1.update(asn1.toDer(pki.certificateToAsn1(pairedCert)).getBytes());\n      localKeyId = sha1.digest().getBytes();\n    } else {\n      // FIXME: consider using SHA-1 of public key (which can be generated\n      // from private key components), see: cert.generateSubjectKeyIdentifier\n      // generate random bytes\n      localKeyId = forge.random.getBytes(20);\n    }\n  }\n\n  var attrs = [];\n  if(localKeyId !== null) {\n    attrs.push(\n      // localKeyID\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n        // attrId\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\n          asn1.oidToDer(pki.oids.localKeyId).getBytes()),\n        // attrValues\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [\n          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false,\n            localKeyId)\n        ])\n      ]));\n  }\n  if('friendlyName' in options) {\n    attrs.push(\n      // friendlyName\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n        // attrId\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\n          asn1.oidToDer(pki.oids.friendlyName).getBytes()),\n        // attrValues\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [\n          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BMPSTRING, false,\n            options.friendlyName)\n        ])\n      ]));\n  }\n\n  if(attrs.length > 0) {\n    bagAttrs = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, attrs);\n  }\n\n  // collect contents for AuthenticatedSafe\n  var contents = [];\n\n  // create safe bag(s) for certificate chain\n  var chain = [];\n  if(cert !== null) {\n    if(forge.util.isArray(cert)) {\n      chain = cert;\n    } else {\n      chain = [cert];\n    }\n  }\n\n  var certSafeBags = [];\n  for(var i = 0; i < chain.length; ++i) {\n    // convert cert from PEM as necessary\n    cert = chain[i];\n    if(typeof cert === 'string') {\n      cert = pki.certificateFromPem(cert);\n    }\n\n    // SafeBag\n    var certBagAttrs = (i === 0) ? bagAttrs : undefined;\n    var certAsn1 = pki.certificateToAsn1(cert);\n    var certSafeBag =\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n        // bagId\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\n          asn1.oidToDer(pki.oids.certBag).getBytes()),\n        // bagValue\n        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\n          // CertBag\n          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n            // certId\n            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\n              asn1.oidToDer(pki.oids.x509Certificate).getBytes()),\n            // certValue (x509Certificate)\n            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\n              asn1.create(\n                asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false,\n                asn1.toDer(certAsn1).getBytes())\n            ])])]),\n        // bagAttributes (OPTIONAL)\n        certBagAttrs\n      ]);\n    certSafeBags.push(certSafeBag);\n  }\n\n  if(certSafeBags.length > 0) {\n    // SafeContents\n    var certSafeContents = asn1.create(\n      asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, certSafeBags);\n\n    // ContentInfo\n    var certCI =\n      // PKCS#7 ContentInfo\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n        // contentType\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\n          // OID for the content type is 'data'\n          asn1.oidToDer(pki.oids.data).getBytes()),\n        // content\n        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\n          asn1.create(\n            asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false,\n            asn1.toDer(certSafeContents).getBytes())\n        ])\n      ]);\n    contents.push(certCI);\n  }\n\n  // create safe contents for private key\n  var keyBag = null;\n  if(key !== null) {\n    // SafeBag\n    var pkAsn1 = pki.wrapRsaPrivateKey(pki.privateKeyToAsn1(key));\n    if(password === null) {\n      // no encryption\n      keyBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n        // bagId\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\n          asn1.oidToDer(pki.oids.keyBag).getBytes()),\n        // bagValue\n        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\n          // PrivateKeyInfo\n          pkAsn1\n        ]),\n        // bagAttributes (OPTIONAL)\n        bagAttrs\n      ]);\n    } else {\n      // encrypted PrivateKeyInfo\n      keyBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n        // bagId\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\n          asn1.oidToDer(pki.oids.pkcs8ShroudedKeyBag).getBytes()),\n        // bagValue\n        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\n          // EncryptedPrivateKeyInfo\n          pki.encryptPrivateKeyInfo(pkAsn1, password, options)\n        ]),\n        // bagAttributes (OPTIONAL)\n        bagAttrs\n      ]);\n    }\n\n    // SafeContents\n    var keySafeContents =\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [keyBag]);\n\n    // ContentInfo\n    var keyCI =\n      // PKCS#7 ContentInfo\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n        // contentType\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\n          // OID for the content type is 'data'\n          asn1.oidToDer(pki.oids.data).getBytes()),\n        // content\n        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\n          asn1.create(\n            asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false,\n            asn1.toDer(keySafeContents).getBytes())\n        ])\n      ]);\n    contents.push(keyCI);\n  }\n\n  // create AuthenticatedSafe by stringing together the contents\n  var safe = asn1.create(\n    asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, contents);\n\n  var macData;\n  if(options.useMac) {\n    // MacData\n    var sha1 = forge.md.sha1.create();\n    var macSalt = new forge.util.ByteBuffer(\n      forge.random.getBytes(options.saltSize));\n    var count = options.count;\n    // 160-bit key\n    var key = p12.generateKey(password, macSalt, 3, count, 20);\n    var mac = forge.hmac.create();\n    mac.start(sha1, key);\n    mac.update(asn1.toDer(safe).getBytes());\n    var macValue = mac.getMac();\n    macData = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n      // mac DigestInfo\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n        // digestAlgorithm\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n          // algorithm = SHA-1\n          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\n            asn1.oidToDer(pki.oids.sha1).getBytes()),\n          // parameters = Null\n          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')\n        ]),\n        // digest\n        asn1.create(\n          asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING,\n          false, macValue.getBytes())\n      ]),\n      // macSalt OCTET STRING\n      asn1.create(\n        asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, macSalt.getBytes()),\n      // iterations INTEGER (XXX: Only support count < 65536)\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\n        asn1.integerToDer(count).getBytes()\n      )\n    ]);\n  }\n\n  // PFX\n  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n    // version (3)\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\n      asn1.integerToDer(3).getBytes()),\n    // PKCS#7 ContentInfo\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n      // contentType\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\n        // OID for the content type is 'data'\n        asn1.oidToDer(pki.oids.data).getBytes()),\n      // content\n      asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\n        asn1.create(\n          asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false,\n          asn1.toDer(safe).getBytes())\n      ])\n    ]),\n    macData\n  ]);\n};\n\n/**\n * Derives a PKCS#12 key.\n *\n * @param password the password to derive the key material from, null or\n *          undefined for none.\n * @param salt the salt, as a ByteBuffer, to use.\n * @param id the PKCS#12 ID byte (1 = key material, 2 = IV, 3 = MAC).\n * @param iter the iteration count.\n * @param n the number of bytes to derive from the password.\n * @param md the message digest to use, defaults to SHA-1.\n *\n * @return a ByteBuffer with the bytes derived from the password.\n */\np12.generateKey = forge.pbe.generatePkcs12Key;\n","/**\n * Node.js module for Forge message digests.\n *\n * @author Dave Longley\n *\n * Copyright 2011-2017 Digital Bazaar, Inc.\n */\nvar forge = require('./forge');\n\nmodule.exports = forge.md = forge.md || {};\nforge.md.algorithms = forge.md.algorithms || {};\n","/**\n * Javascript implementation of ASN.1 validators for PKCS#7 v1.5.\n *\n * @author Dave Longley\n * @author Stefan Siegl\n *\n * Copyright (c) 2012-2015 Digital Bazaar, Inc.\n * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>\n *\n * The ASN.1 representation of PKCS#7 is as follows\n * (see RFC #2315 for details, http://www.ietf.org/rfc/rfc2315.txt):\n *\n * A PKCS#7 message consists of a ContentInfo on root level, which may\n * contain any number of further ContentInfo nested into it.\n *\n * ContentInfo ::= SEQUENCE {\n *   contentType                ContentType,\n *   content               [0]  EXPLICIT ANY DEFINED BY contentType OPTIONAL\n * }\n *\n * ContentType ::= OBJECT IDENTIFIER\n *\n * EnvelopedData ::= SEQUENCE {\n *   version                    Version,\n *   recipientInfos             RecipientInfos,\n *   encryptedContentInfo       EncryptedContentInfo\n * }\n *\n * EncryptedData ::= SEQUENCE {\n *   version                    Version,\n *   encryptedContentInfo       EncryptedContentInfo\n * }\n *\n * id-signedData OBJECT IDENTIFIER ::= { iso(1) member-body(2)\n *   us(840) rsadsi(113549) pkcs(1) pkcs7(7) 2 }\n *\n * SignedData ::= SEQUENCE {\n *   version           INTEGER,\n *   digestAlgorithms  DigestAlgorithmIdentifiers,\n *   contentInfo       ContentInfo,\n *   certificates      [0] IMPLICIT Certificates OPTIONAL,\n *   crls              [1] IMPLICIT CertificateRevocationLists OPTIONAL,\n *   signerInfos       SignerInfos\n * }\n *\n * SignerInfos ::= SET OF SignerInfo\n *\n * SignerInfo ::= SEQUENCE {\n *   version                    Version,\n *   issuerAndSerialNumber      IssuerAndSerialNumber,\n *   digestAlgorithm            DigestAlgorithmIdentifier,\n *   authenticatedAttributes    [0] IMPLICIT Attributes OPTIONAL,\n *   digestEncryptionAlgorithm  DigestEncryptionAlgorithmIdentifier,\n *   encryptedDigest            EncryptedDigest,\n *   unauthenticatedAttributes  [1] IMPLICIT Attributes OPTIONAL\n * }\n *\n * EncryptedDigest ::= OCTET STRING\n *\n * Attributes ::= SET OF Attribute\n *\n * Attribute ::= SEQUENCE {\n *   attrType    OBJECT IDENTIFIER,\n *   attrValues  SET OF AttributeValue\n * }\n *\n * AttributeValue ::= ANY\n *\n * Version ::= INTEGER\n *\n * RecipientInfos ::= SET OF RecipientInfo\n *\n * EncryptedContentInfo ::= SEQUENCE {\n *   contentType                 ContentType,\n *   contentEncryptionAlgorithm  ContentEncryptionAlgorithmIdentifier,\n *   encryptedContent       [0]  IMPLICIT EncryptedContent OPTIONAL\n * }\n *\n * ContentEncryptionAlgorithmIdentifier ::= AlgorithmIdentifier\n *\n * The AlgorithmIdentifier contains an Object Identifier (OID) and parameters\n * for the algorithm, if any. In the case of AES and DES3, there is only one,\n * the IV.\n *\n * AlgorithmIdentifer ::= SEQUENCE {\n *    algorithm OBJECT IDENTIFIER,\n *    parameters ANY DEFINED BY algorithm OPTIONAL\n * }\n *\n * EncryptedContent ::= OCTET STRING\n *\n * RecipientInfo ::= SEQUENCE {\n *   version                     Version,\n *   issuerAndSerialNumber       IssuerAndSerialNumber,\n *   keyEncryptionAlgorithm      KeyEncryptionAlgorithmIdentifier,\n *   encryptedKey                EncryptedKey\n * }\n *\n * IssuerAndSerialNumber ::= SEQUENCE {\n *   issuer                      Name,\n *   serialNumber                CertificateSerialNumber\n * }\n *\n * CertificateSerialNumber ::= INTEGER\n *\n * KeyEncryptionAlgorithmIdentifier ::= AlgorithmIdentifier\n *\n * EncryptedKey ::= OCTET STRING\n */\nvar forge = require('./forge');\nrequire('./asn1');\nrequire('./util');\n\n// shortcut for ASN.1 API\nvar asn1 = forge.asn1;\n\n// shortcut for PKCS#7 API\nvar p7v = module.exports = forge.pkcs7asn1 = forge.pkcs7asn1 || {};\nforge.pkcs7 = forge.pkcs7 || {};\nforge.pkcs7.asn1 = p7v;\n\nvar contentInfoValidator = {\n  name: 'ContentInfo',\n  tagClass: asn1.Class.UNIVERSAL,\n  type: asn1.Type.SEQUENCE,\n  constructed: true,\n  value: [{\n    name: 'ContentInfo.ContentType',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.OID,\n    constructed: false,\n    capture: 'contentType'\n  }, {\n    name: 'ContentInfo.content',\n    tagClass: asn1.Class.CONTEXT_SPECIFIC,\n    type: 0,\n    constructed: true,\n    optional: true,\n    captureAsn1: 'content'\n  }]\n};\np7v.contentInfoValidator = contentInfoValidator;\n\nvar encryptedContentInfoValidator = {\n  name: 'EncryptedContentInfo',\n  tagClass: asn1.Class.UNIVERSAL,\n  type: asn1.Type.SEQUENCE,\n  constructed: true,\n  value: [{\n    name: 'EncryptedContentInfo.contentType',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.OID,\n    constructed: false,\n    capture: 'contentType'\n  }, {\n    name: 'EncryptedContentInfo.contentEncryptionAlgorithm',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SEQUENCE,\n    constructed: true,\n    value: [{\n      name: 'EncryptedContentInfo.contentEncryptionAlgorithm.algorithm',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.OID,\n      constructed: false,\n      capture: 'encAlgorithm'\n    }, {\n      name: 'EncryptedContentInfo.contentEncryptionAlgorithm.parameter',\n      tagClass: asn1.Class.UNIVERSAL,\n      captureAsn1: 'encParameter'\n    }]\n  }, {\n    name: 'EncryptedContentInfo.encryptedContent',\n    tagClass: asn1.Class.CONTEXT_SPECIFIC,\n    type: 0,\n    /* The PKCS#7 structure output by OpenSSL somewhat differs from what\n     * other implementations do generate.\n     *\n     * OpenSSL generates a structure like this:\n     * SEQUENCE {\n     *    ...\n     *    [0]\n     *       26 DA 67 D2 17 9C 45 3C B1 2A A8 59 2F 29 33 38\n     *       C3 C3 DF 86 71 74 7A 19 9F 40 D0 29 BE 85 90 45\n     *       ...\n     * }\n     *\n     * Whereas other implementations (and this PKCS#7 module) generate:\n     * SEQUENCE {\n     *    ...\n     *    [0] {\n     *       OCTET STRING\n     *          26 DA 67 D2 17 9C 45 3C B1 2A A8 59 2F 29 33 38\n     *          C3 C3 DF 86 71 74 7A 19 9F 40 D0 29 BE 85 90 45\n     *          ...\n     *    }\n     * }\n     *\n     * In order to support both, we just capture the context specific\n     * field here.  The OCTET STRING bit is removed below.\n     */\n    capture: 'encryptedContent',\n    captureAsn1: 'encryptedContentAsn1'\n  }]\n};\n\np7v.envelopedDataValidator = {\n  name: 'EnvelopedData',\n  tagClass: asn1.Class.UNIVERSAL,\n  type: asn1.Type.SEQUENCE,\n  constructed: true,\n  value: [{\n    name: 'EnvelopedData.Version',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.INTEGER,\n    constructed: false,\n    capture: 'version'\n  }, {\n    name: 'EnvelopedData.RecipientInfos',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SET,\n    constructed: true,\n    captureAsn1: 'recipientInfos'\n  }].concat(encryptedContentInfoValidator)\n};\n\np7v.encryptedDataValidator = {\n  name: 'EncryptedData',\n  tagClass: asn1.Class.UNIVERSAL,\n  type: asn1.Type.SEQUENCE,\n  constructed: true,\n  value: [{\n    name: 'EncryptedData.Version',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.INTEGER,\n    constructed: false,\n    capture: 'version'\n  }].concat(encryptedContentInfoValidator)\n};\n\nvar signerValidator = {\n  name: 'SignerInfo',\n  tagClass: asn1.Class.UNIVERSAL,\n  type: asn1.Type.SEQUENCE,\n  constructed: true,\n  value: [{\n    name: 'SignerInfo.version',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.INTEGER,\n    constructed: false\n  }, {\n    name: 'SignerInfo.issuerAndSerialNumber',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SEQUENCE,\n    constructed: true,\n    value: [{\n      name: 'SignerInfo.issuerAndSerialNumber.issuer',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.SEQUENCE,\n      constructed: true,\n      captureAsn1: 'issuer'\n    }, {\n      name: 'SignerInfo.issuerAndSerialNumber.serialNumber',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.INTEGER,\n      constructed: false,\n      capture: 'serial'\n    }]\n  }, {\n    name: 'SignerInfo.digestAlgorithm',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SEQUENCE,\n    constructed: true,\n    value: [{\n      name: 'SignerInfo.digestAlgorithm.algorithm',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.OID,\n      constructed: false,\n      capture: 'digestAlgorithm'\n    }, {\n      name: 'SignerInfo.digestAlgorithm.parameter',\n      tagClass: asn1.Class.UNIVERSAL,\n      constructed: false,\n      captureAsn1: 'digestParameter',\n      optional: true\n    }]\n  }, {\n    name: 'SignerInfo.authenticatedAttributes',\n    tagClass: asn1.Class.CONTEXT_SPECIFIC,\n    type: 0,\n    constructed: true,\n    optional: true,\n    capture: 'authenticatedAttributes'\n  }, {\n    name: 'SignerInfo.digestEncryptionAlgorithm',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SEQUENCE,\n    constructed: true,\n    capture: 'signatureAlgorithm'\n  }, {\n    name: 'SignerInfo.encryptedDigest',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.OCTETSTRING,\n    constructed: false,\n    capture: 'signature'\n  }, {\n    name: 'SignerInfo.unauthenticatedAttributes',\n    tagClass: asn1.Class.CONTEXT_SPECIFIC,\n    type: 1,\n    constructed: true,\n    optional: true,\n    capture: 'unauthenticatedAttributes'\n  }]\n};\n\np7v.signedDataValidator = {\n  name: 'SignedData',\n  tagClass: asn1.Class.UNIVERSAL,\n  type: asn1.Type.SEQUENCE,\n  constructed: true,\n  value: [{\n    name: 'SignedData.Version',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.INTEGER,\n    constructed: false,\n    capture: 'version'\n  }, {\n    name: 'SignedData.DigestAlgorithms',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SET,\n    constructed: true,\n    captureAsn1: 'digestAlgorithms'\n  },\n  contentInfoValidator,\n  {\n    name: 'SignedData.Certificates',\n    tagClass: asn1.Class.CONTEXT_SPECIFIC,\n    type: 0,\n    optional: true,\n    captureAsn1: 'certificates'\n  }, {\n    name: 'SignedData.CertificateRevocationLists',\n    tagClass: asn1.Class.CONTEXT_SPECIFIC,\n    type: 1,\n    optional: true,\n    captureAsn1: 'crls'\n  }, {\n    name: 'SignedData.SignerInfos',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SET,\n    capture: 'signerInfos',\n    optional: true,\n    value: [signerValidator]\n  }]\n};\n\np7v.recipientInfoValidator = {\n  name: 'RecipientInfo',\n  tagClass: asn1.Class.UNIVERSAL,\n  type: asn1.Type.SEQUENCE,\n  constructed: true,\n  value: [{\n    name: 'RecipientInfo.version',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.INTEGER,\n    constructed: false,\n    capture: 'version'\n  }, {\n    name: 'RecipientInfo.issuerAndSerial',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SEQUENCE,\n    constructed: true,\n    value: [{\n      name: 'RecipientInfo.issuerAndSerial.issuer',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.SEQUENCE,\n      constructed: true,\n      captureAsn1: 'issuer'\n    }, {\n      name: 'RecipientInfo.issuerAndSerial.serialNumber',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.INTEGER,\n      constructed: false,\n      capture: 'serial'\n    }]\n  }, {\n    name: 'RecipientInfo.keyEncryptionAlgorithm',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SEQUENCE,\n    constructed: true,\n    value: [{\n      name: 'RecipientInfo.keyEncryptionAlgorithm.algorithm',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.OID,\n      constructed: false,\n      capture: 'encAlgorithm'\n    }, {\n      name: 'RecipientInfo.keyEncryptionAlgorithm.parameter',\n      tagClass: asn1.Class.UNIVERSAL,\n      constructed: false,\n      captureAsn1: 'encParameter',\n      optional: true\n    }]\n  }, {\n    name: 'RecipientInfo.encryptedKey',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.OCTETSTRING,\n    constructed: false,\n    capture: 'encKey'\n  }]\n};\n","/**\n * Object IDs for ASN.1.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2010-2013 Digital Bazaar, Inc.\n */\nvar forge = require('./forge');\n\nforge.pki = forge.pki || {};\nvar oids = module.exports = forge.pki.oids = forge.oids = forge.oids || {};\n\n// set id to name mapping and name to id mapping\nfunction _IN(id, name) {\n  oids[id] = name;\n  oids[name] = id;\n}\n// set id to name mapping only\nfunction _I_(id, name) {\n  oids[id] = name;\n}\n\n// algorithm OIDs\n_IN('1.2.840.113549.1.1.1', 'rsaEncryption');\n// Note: md2 & md4 not implemented\n//_IN('1.2.840.113549.1.1.2', 'md2WithRSAEncryption');\n//_IN('1.2.840.113549.1.1.3', 'md4WithRSAEncryption');\n_IN('1.2.840.113549.1.1.4', 'md5WithRSAEncryption');\n_IN('1.2.840.113549.1.1.5', 'sha1WithRSAEncryption');\n_IN('1.2.840.113549.1.1.7', 'RSAES-OAEP');\n_IN('1.2.840.113549.1.1.8', 'mgf1');\n_IN('1.2.840.113549.1.1.9', 'pSpecified');\n_IN('1.2.840.113549.1.1.10', 'RSASSA-PSS');\n_IN('1.2.840.113549.1.1.11', 'sha256WithRSAEncryption');\n_IN('1.2.840.113549.1.1.12', 'sha384WithRSAEncryption');\n_IN('1.2.840.113549.1.1.13', 'sha512WithRSAEncryption');\n// Edwards-curve Digital Signature Algorithm (EdDSA) Ed25519\n_IN('1.3.101.112', 'EdDSA25519');\n\n_IN('1.2.840.10040.4.3', 'dsa-with-sha1');\n\n_IN('1.3.14.3.2.7', 'desCBC');\n\n_IN('1.3.14.3.2.26', 'sha1');\n// Deprecated equivalent of sha1WithRSAEncryption\n_IN('1.3.14.3.2.29', 'sha1WithRSASignature');\n_IN('2.16.840.1.101.3.4.2.1', 'sha256');\n_IN('2.16.840.1.101.3.4.2.2', 'sha384');\n_IN('2.16.840.1.101.3.4.2.3', 'sha512');\n_IN('2.16.840.1.101.3.4.2.4', 'sha224');\n_IN('2.16.840.1.101.3.4.2.5', 'sha512-224');\n_IN('2.16.840.1.101.3.4.2.6', 'sha512-256');\n_IN('1.2.840.113549.2.2', 'md2');\n_IN('1.2.840.113549.2.5', 'md5');\n\n// pkcs#7 content types\n_IN('1.2.840.113549.1.7.1', 'data');\n_IN('1.2.840.113549.1.7.2', 'signedData');\n_IN('1.2.840.113549.1.7.3', 'envelopedData');\n_IN('1.2.840.113549.1.7.4', 'signedAndEnvelopedData');\n_IN('1.2.840.113549.1.7.5', 'digestedData');\n_IN('1.2.840.113549.1.7.6', 'encryptedData');\n\n// pkcs#9 oids\n_IN('1.2.840.113549.1.9.1', 'emailAddress');\n_IN('1.2.840.113549.1.9.2', 'unstructuredName');\n_IN('1.2.840.113549.1.9.3', 'contentType');\n_IN('1.2.840.113549.1.9.4', 'messageDigest');\n_IN('1.2.840.113549.1.9.5', 'signingTime');\n_IN('1.2.840.113549.1.9.6', 'counterSignature');\n_IN('1.2.840.113549.1.9.7', 'challengePassword');\n_IN('1.2.840.113549.1.9.8', 'unstructuredAddress');\n_IN('1.2.840.113549.1.9.14', 'extensionRequest');\n\n_IN('1.2.840.113549.1.9.20', 'friendlyName');\n_IN('1.2.840.113549.1.9.21', 'localKeyId');\n_IN('1.2.840.113549.1.9.22.1', 'x509Certificate');\n\n// pkcs#12 safe bags\n_IN('1.2.840.113549.1.12.10.1.1', 'keyBag');\n_IN('1.2.840.113549.1.12.10.1.2', 'pkcs8ShroudedKeyBag');\n_IN('1.2.840.113549.1.12.10.1.3', 'certBag');\n_IN('1.2.840.113549.1.12.10.1.4', 'crlBag');\n_IN('1.2.840.113549.1.12.10.1.5', 'secretBag');\n_IN('1.2.840.113549.1.12.10.1.6', 'safeContentsBag');\n\n// password-based-encryption for pkcs#12\n_IN('1.2.840.113549.1.5.13', 'pkcs5PBES2');\n_IN('1.2.840.113549.1.5.12', 'pkcs5PBKDF2');\n\n_IN('1.2.840.113549.1.12.1.1', 'pbeWithSHAAnd128BitRC4');\n_IN('1.2.840.113549.1.12.1.2', 'pbeWithSHAAnd40BitRC4');\n_IN('1.2.840.113549.1.12.1.3', 'pbeWithSHAAnd3-KeyTripleDES-CBC');\n_IN('1.2.840.113549.1.12.1.4', 'pbeWithSHAAnd2-KeyTripleDES-CBC');\n_IN('1.2.840.113549.1.12.1.5', 'pbeWithSHAAnd128BitRC2-CBC');\n_IN('1.2.840.113549.1.12.1.6', 'pbewithSHAAnd40BitRC2-CBC');\n\n// hmac OIDs\n_IN('1.2.840.113549.2.7', 'hmacWithSHA1');\n_IN('1.2.840.113549.2.8', 'hmacWithSHA224');\n_IN('1.2.840.113549.2.9', 'hmacWithSHA256');\n_IN('1.2.840.113549.2.10', 'hmacWithSHA384');\n_IN('1.2.840.113549.2.11', 'hmacWithSHA512');\n\n// symmetric key algorithm oids\n_IN('1.2.840.113549.3.7', 'des-EDE3-CBC');\n_IN('2.16.840.1.101.3.4.1.2', 'aes128-CBC');\n_IN('2.16.840.1.101.3.4.1.22', 'aes192-CBC');\n_IN('2.16.840.1.101.3.4.1.42', 'aes256-CBC');\n\n// certificate issuer/subject OIDs\n_IN('2.5.4.3', 'commonName');\n_IN('2.5.4.4', 'surname');\n_IN('2.5.4.5', 'serialNumber');\n_IN('2.5.4.6', 'countryName');\n_IN('2.5.4.7', 'localityName');\n_IN('2.5.4.8', 'stateOrProvinceName');\n_IN('2.5.4.9', 'streetAddress');\n_IN('2.5.4.10', 'organizationName');\n_IN('2.5.4.11', 'organizationalUnitName');\n_IN('2.5.4.12', 'title');\n_IN('2.5.4.13', 'description');\n_IN('2.5.4.15', 'businessCategory');\n_IN('2.5.4.17', 'postalCode');\n_IN('2.5.4.42', 'givenName');\n_IN('1.3.6.1.4.1.311.60.2.1.2', 'jurisdictionOfIncorporationStateOrProvinceName');\n_IN('1.3.6.1.4.1.311.60.2.1.3', 'jurisdictionOfIncorporationCountryName');\n\n// X.509 extension OIDs\n_IN('2.16.840.1.113730.1.1', 'nsCertType');\n_IN('2.16.840.1.113730.1.13', 'nsComment'); // deprecated in theory; still widely used\n_I_('2.5.29.1', 'authorityKeyIdentifier'); // deprecated, use .35\n_I_('2.5.29.2', 'keyAttributes'); // obsolete use .37 or .15\n_I_('2.5.29.3', 'certificatePolicies'); // deprecated, use .32\n_I_('2.5.29.4', 'keyUsageRestriction'); // obsolete use .37 or .15\n_I_('2.5.29.5', 'policyMapping'); // deprecated use .33\n_I_('2.5.29.6', 'subtreesConstraint'); // obsolete use .30\n_I_('2.5.29.7', 'subjectAltName'); // deprecated use .17\n_I_('2.5.29.8', 'issuerAltName'); // deprecated use .18\n_I_('2.5.29.9', 'subjectDirectoryAttributes');\n_I_('2.5.29.10', 'basicConstraints'); // deprecated use .19\n_I_('2.5.29.11', 'nameConstraints'); // deprecated use .30\n_I_('2.5.29.12', 'policyConstraints'); // deprecated use .36\n_I_('2.5.29.13', 'basicConstraints'); // deprecated use .19\n_IN('2.5.29.14', 'subjectKeyIdentifier');\n_IN('2.5.29.15', 'keyUsage');\n_I_('2.5.29.16', 'privateKeyUsagePeriod');\n_IN('2.5.29.17', 'subjectAltName');\n_IN('2.5.29.18', 'issuerAltName');\n_IN('2.5.29.19', 'basicConstraints');\n_I_('2.5.29.20', 'cRLNumber');\n_I_('2.5.29.21', 'cRLReason');\n_I_('2.5.29.22', 'expirationDate');\n_I_('2.5.29.23', 'instructionCode');\n_I_('2.5.29.24', 'invalidityDate');\n_I_('2.5.29.25', 'cRLDistributionPoints'); // deprecated use .31\n_I_('2.5.29.26', 'issuingDistributionPoint'); // deprecated use .28\n_I_('2.5.29.27', 'deltaCRLIndicator');\n_I_('2.5.29.28', 'issuingDistributionPoint');\n_I_('2.5.29.29', 'certificateIssuer');\n_I_('2.5.29.30', 'nameConstraints');\n_IN('2.5.29.31', 'cRLDistributionPoints');\n_IN('2.5.29.32', 'certificatePolicies');\n_I_('2.5.29.33', 'policyMappings');\n_I_('2.5.29.34', 'policyConstraints'); // deprecated use .36\n_IN('2.5.29.35', 'authorityKeyIdentifier');\n_I_('2.5.29.36', 'policyConstraints');\n_IN('2.5.29.37', 'extKeyUsage');\n_I_('2.5.29.46', 'freshestCRL');\n_I_('2.5.29.54', 'inhibitAnyPolicy');\n\n// extKeyUsage purposes\n_IN('1.3.6.1.4.1.11129.2.4.2', 'timestampList');\n_IN('1.3.6.1.5.5.7.1.1', 'authorityInfoAccess');\n_IN('1.3.6.1.5.5.7.3.1', 'serverAuth');\n_IN('1.3.6.1.5.5.7.3.2', 'clientAuth');\n_IN('1.3.6.1.5.5.7.3.3', 'codeSigning');\n_IN('1.3.6.1.5.5.7.3.4', 'emailProtection');\n_IN('1.3.6.1.5.5.7.3.8', 'timeStamping');\n"],"sourceRoot":""}